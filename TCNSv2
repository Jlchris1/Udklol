-- Control NPC LocalScript (stable freeze-under-NPC behaviour)
-- Ensures the local player stands entirely still directly underneath the NPC.
-- Improved: when NPC stands on a thin part, player Y locks to the top face of that thin part
-- (so heightBelow textbox behaves identically for thin vs thick supports).

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local StarterGui = game:GetService("StarterGui")
local Workspace = game:GetService("Workspace")
local PhysicsService = game:GetService("PhysicsService")

local player = Players.LocalPlayer
local camera = Workspace.CurrentCamera

-- CONFIG
local DEFAULT_HEIGHT_GAP = 0.05         -- positive -> player sits below NPC surface by this amount
local WALK_THRESHOLD = 0.02
local MOVE_DISTANCE = 100
local FIXED_YAW_RAD = math.rad(90)

-- Align tuning (made very aggressive for a rock-solid lock)
local ALIGN_MAX_FORCE = 1e12
local ALIGN_RESPONSIVENESS = 200
local ALIGN_MAX_TORQUE = 1e12
local ALIGN_MAX_VELOCITY = 1e6

-- Platform tuning
local NPC_PLATFORM_SIZE = Vector3.new(16, 2, 16)
local PLAYER_PLATFORM_SIZE = Vector3.new(6, 1, 6)
local PLATFORM_Y_OFFSET = 0.5
local PLAYER_PLATFORM_DEPTH = 3

-- Behavior
local allowUnderground = true

-- UI (omitted comment — same as previous; UI creation identical to earlier script)
local gui = Instance.new("ScreenGui")
gui.Name = "ControlNPCGui"
gui.ResetOnSpawn = false
gui.IgnoreGuiInset = true
gui.Parent = player:WaitForChild("PlayerGui")
gui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
pcall(function() gui.DisplayOrder = 9999 end)

local frame = Instance.new("Frame")
frame.Name = "ControlPanel"
frame.BackgroundColor3 = Color3.fromRGB(30,30,30)
frame.BorderSizePixel = 0
frame.AnchorPoint = Vector2.new(0,0)
frame.ZIndex = 1000
frame.Parent = gui
frame.Visible = true
frame.Size = UDim2.new(0, 320, 0, 190)
frame.Position = UDim2.new(0, 10, 0, 10)

local title = Instance.new("TextLabel", frame)
title.Size = UDim2.new(1, 0, 0, 20)
title.BackgroundTransparency = 1
title.Text = "NPC Control"
title.TextColor3 = Color3.fromRGB(255,255,255)
title.Font = Enum.Font.SourceSansBold
title.TextSize = 14
title.ZIndex = 1001

local toggleBtn = Instance.new("TextButton", frame)
toggleBtn.Size = UDim2.new(1, -12, 0, 26)
toggleBtn.Position = UDim2.new(0, 6, 0, 24)
toggleBtn.Text = "Toggle Control: OFF"
toggleBtn.Font = Enum.Font.SourceSans
toggleBtn.TextSize = 13
toggleBtn.ZIndex = 1001

local walkToggle = Instance.new("TextButton", frame)
walkToggle.Size = UDim2.new(0.48, -6, 0, 20)
walkToggle.Position = UDim2.new(0, 6, 0, 56)
walkToggle.Text = "WalkTo: On"
walkToggle.Font = Enum.Font.SourceSans
walkToggle.TextSize = 12
walkToggle.ZIndex = 1001

local killBtn = Instance.new("TextButton", frame)
killBtn.Size = UDim2.new(0.48, -6, 0, 20)
killBtn.Position = UDim2.new(0.52, 0, 0, 56)
killBtn.Text = "Kill NPC"
killBtn.Font = Enum.Font.SourceSans
killBtn.TextSize = 12
killBtn.ZIndex = 1001

local noclipBtn = Instance.new("TextButton", frame)
noclipBtn.Size = UDim2.new(0.48, -6, 0, 20)
noclipBtn.Position = UDim2.new(0.02, 0, 0, 86)
noclipBtn.Text = "NPC Noclip: Off"
noclipBtn.Font = Enum.Font.SourceSans
noclipBtn.TextSize = 12
noclipBtn.ZIndex = 1001

local heightLabel = Instance.new("TextLabel", frame)
heightLabel.Size = UDim2.new(0.6, -6, 0, 18)
heightLabel.Position = UDim2.new(0.5, 6, 0, 86)
heightLabel.Text = "Height Below (studs):"
heightLabel.Font = Enum.Font.SourceSans
heightLabel.TextSize = 12
heightLabel.TextColor3 = Color3.new(1,1,1)
heightLabel.BackgroundTransparency = 1
heightLabel.ZIndex = 1001

local heightBox = Instance.new("TextBox", frame)
heightBox.Size = UDim2.new(0.4, -6, 0, 18)
heightBox.Position = UDim2.new(0.8, -54, 0, 86)
heightBox.Text = tostring(DEFAULT_HEIGHT_GAP)
heightBox.Font = Enum.Font.SourceSans
heightBox.TextSize = 12
heightBox.ClearTextOnFocus = false
heightBox.ZIndex = 1001
heightBox.TextEditable = true

local upBtn = Instance.new("TextButton", frame)
upBtn.Size = UDim2.new(0.195, -4, 0, 20)
upBtn.Position = UDim2.new(0.5, 4, 0, 112)
upBtn.Text = "▲"
upBtn.Font = Enum.Font.SourceSansBold
upBtn.TextSize = 14
upBtn.ZIndex = 1001

local downBtn = Instance.new("TextButton", frame)
downBtn.Size = UDim2.new(0.195, -4, 0, 20)
downBtn.Position = UDim2.new(0.705, 0, 0, 112)
downBtn.Text = "▼"
downBtn.Font = Enum.Font.SourceSansBold
downBtn.TextSize = 14
downBtn.ZIndex = 1001

local speedLabel = Instance.new("TextLabel", frame)
speedLabel.Size = UDim2.new(0.5, -6, 0, 16)
speedLabel.Position = UDim2.new(0, 6, 0, 144)
speedLabel.Text = "NPC Speed:"
speedLabel.Font = Enum.Font.SourceSans
speedLabel.TextSize = 11
speedLabel.TextColor3 = Color3.new(1,1,1)
speedLabel.BackgroundTransparency = 1
speedLabel.ZIndex = 1001

local speedBox = Instance.new("TextBox", frame)
speedBox.Size = UDim2.new(0.5, -6, 0, 16)
speedBox.Position = UDim2.new(0.5, 0, 0, 144)
speedBox.Text = "16"
speedBox.Font = Enum.Font.SourceSans
speedBox.TextSize = 11
speedBox.ClearTextOnFocus = false
speedBox.ZIndex = 1001

local jumpLabel = Instance.new("TextLabel", frame)
jumpLabel.Size = UDim2.new(0.5, -6, 0, 16)
jumpLabel.Position = UDim2.new(0, 6, 0, 164)
jumpLabel.Text = "NPC JumpPower:"
jumpLabel.Font = Enum.Font.SourceSans
jumpLabel.TextSize = 11
jumpLabel.TextColor3 = Color3.new(1,1,1)
jumpLabel.BackgroundTransparency = 1
jumpLabel.ZIndex = 1001

local jumpBox = Instance.new("TextBox", frame)
jumpBox.Size = UDim2.new(0.5, -6, 0, 16)
jumpBox.Position = UDim2.new(0.5, 0, 0, 164)
jumpBox.Text = "50"
jumpBox.Font = Enum.Font.SourceSans
jumpBox.TextSize = 11
jumpBox.ClearTextOnFocus = false
jumpBox.ZIndex = 1001

local visibilityToggle = Instance.new("TextButton")
visibilityToggle.Name = "VisibilityToggle"
visibilityToggle.Size = UDim2.new(0, 40, 0, 40)
visibilityToggle.AnchorPoint = Vector2.new(1, 0)
visibilityToggle.Position = UDim2.new(1, -8, 0, 8)
visibilityToggle.BackgroundColor3 = Color3.fromRGB(40,40,40)
visibilityToggle.BorderSizePixel = 0
visibilityToggle.Text = "▣"
visibilityToggle.Font = Enum.Font.SourceSansBold
visibilityToggle.TextSize = 18
visibilityToggle.Parent = gui
visibilityToggle.ZIndex = 1100
visibilityToggle.AutoButtonColor = true
visibilityToggle.Active = true
visibilityToggle.Selectable = true

-- State
local active = false
local controlledNPC = nil
local npcHumanoid = nil
local npcRoot = nil
local heartbeatConn = nil
local jumpConn = nil
local charAddedConn = nil
local playerDiedConn = nil
local npcDiedConn = nil
local npcPlatformStandConn = nil

local walkEnabled = true
local npcOriginalWalkSpeed = nil

local changedNPCParts = {}
local changedPlayerParts = {}

local myOriginalJumpPower = nil
local myOriginalAutoRotate = nil
local myOriginalWalkSpeed = nil

local wasPlayerMoving = false

local playerAttachment = nil
local npcAttachment = nil
local alignPos = nil
local alignOri = nil

-- Platforms
local npcSupportPlatform = nil
local playerSupportPlatform = nil

local heightBelow = DEFAULT_HEIGHT_GAP

-- NPC noclip
local npcNoclipToggle = false
local npcNoclipParts = {}
local function setNpcNoClip(enabled)
    if not controlledNPC or not npcRoot then return end
    if enabled then
        createNpcSupportPlatform()
        pcall(function()
            npcSupportPlatform.Size = NPC_PLATFORM_SIZE
            npcSupportPlatform.CFrame = CFrame.new(npcRoot.Position.X, npcRoot.Position.Y - 1 - PLATFORM_Y_OFFSET, npcRoot.Position.Z)
        end)

        npcNoclipParts = {}
        for _,v in ipairs(controlledNPC:GetDescendants()) do
            if v:IsA("BasePart") then
                table.insert(npcNoclipParts, {part = v, prev = v.CanCollide})
                pcall(function() v.CanCollide = false end)
            end
        end
    else
        for _,row in ipairs(npcNoclipParts) do
            local p = row.part
            local prev = row.prev
            pcall(function() if p and p.Parent then p.CanCollide = prev end end)
        end
        npcNoclipParts = {}
    end
end

-- Utility functions
local function modelHeight(model)
    if not model then return 5 end
    local ok, size = pcall(function() return model:GetExtentsSize() end)
    if ok and size then return size.Y end
    return 5
end

local function findNearestNPC()
    local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
    if not hrp then return nil end
    local myPos = hrp.Position
    local nearest, nd = nil, math.huge
    for _,m in ipairs(workspace:GetDescendants()) do
        if m:IsA("Model") then
            local hum = m:FindFirstChildOfClass("Humanoid")
            local root = m:FindFirstChild("HumanoidRootPart") or m.PrimaryPart
            if hum and root and hum.Health > 0 and Players:GetPlayerFromCharacter(m) == nil then
                local d = (root.Position - myPos).Magnitude
                if d < nd then nd = d; nearest = m end
            end
        end
    end
    return nearest
end

-- Raycast downward from a given origin, blacklisting NPC/player
local function rayDown(origin, distance)
    local dir = Vector3.new(0, -math.abs(distance), 0)
    local rayParams = RaycastParams.new()
    rayParams.FilterType = Enum.RaycastFilterType.Blacklist
    local blacklist = {}
    if controlledNPC then
        for _, v in ipairs(controlledNPC:GetDescendants()) do if v:IsA("BasePart") then table.insert(blacklist, v) end end
    end
    if player and player.Character then
        for _, v in ipairs(player.Character:GetDescendants()) do if v:IsA("BasePart") then table.insert(blacklist, v) end end
    end
    rayParams.FilterDescendantsInstances = blacklist
    return Workspace:Raycast(origin, dir, rayParams)
end

-- Improved supporting-surface finder:
-- For each NPC basepart, cast down starting just above the part's bottom; when a part is hit,
-- compute its top Y (hitPart.Position.Y + hitPart.Size.Y/2) and treat that as the candidate surface Y.
-- Only accept candidate tops that are actually below the NPC part bottom (prevents overhangs)
-- and pick the highest candidate top across all parts.
local function findSupportingSurface()
    if not controlledNPC then return nil, nil end
    local bestY = nil
    local bestPart = nil
    local EPSILON = 0.04
    local TOL = 0.02

    for _,p in ipairs(controlledNPC:GetDescendants()) do
        if p:IsA("BasePart") then
            -- bottom Y of the NPC part in worldspace
            local partBottomY = p.Position.Y - (p.Size.Y * 0.5)
            -- ray origin just above that bottom face
            local origin = Vector3.new(p.Position.X, partBottomY + EPSILON, p.Position.Z)
            local res = rayDown(origin, 500)
            if res and res.Instance then
                -- If hit a BasePart-like instance, derive the part top Y explicitly.
                if res.Instance:IsA("BasePart") then
                    local hitPart = res.Instance
                    local hitTopY = hitPart.Position.Y + (hitPart.Size.Y * 0.5)
                    -- accept only if the part top is below (or essentially equal) to the NPC part bottom
                    if hitTopY <= partBottomY + TOL then
                        -- sanity: ensure the top is actually below the ray origin (avoids weird above hits)
                        if hitTopY < origin.Y - 1e-5 then
                            if (not bestY) or (hitTopY > bestY) then
                                bestY = hitTopY
                                bestPart = hitPart
                            end
                        end
                    end
                else
                    -- fallback: for non-BasePart hits use exact hit point if it's below the part bottom
                    local hitY = res.Position and res.Position.Y
                    if hitY and hitY <= partBottomY + TOL and hitY < origin.Y - 1e-5 then
                        if (not bestY) or (hitY > bestY) then
                            bestY = hitY
                            bestPart = res.Instance
                        end
                    end
                end
            end
        end
    end

    -- fallback long ray from above NPC root if no part-level hits were accepted
    if not bestY and npcRoot then
        local origin = Vector3.new(npcRoot.Position.X, npcRoot.Position.Y + 50, npcRoot.Position.Z)
        local res = rayDown(origin, 500)
        if res and res.Instance then
            if res.Instance:IsA("BasePart") then
                local hitPart = res.Instance
                local hitTopY = hitPart.Position.Y + (hitPart.Size.Y * 0.5)
                if hitTopY < npcRoot.Position.Y - 1e-4 then
                    bestY = hitTopY
                    bestPart = hitPart
                end
            else
                if res.Position and res.Position.Y < npcRoot.Position.Y - 1e-4 then
                    bestY = res.Position.Y
                    bestPart = res.Instance
                end
            end
        end
    end

    return bestY, bestPart
end

local function safeSetPartPropsAsNoCollision(part)
    if not part then return end
    pcall(function()
        table.insert(changedNPCParts, part)
        part.CanCollide = false
        if pcall(function() return part.CanTouch end) then
            pcall(function() part.CanTouch = false end)
        end
        pcall(function() part.Massless = true end)
    end)
end

local function neutralizeNPC(model)
    if not model then return end
    for _,desc in ipairs(model:GetDescendants()) do
        if desc:IsA("Script") or desc:IsA("LocalScript") or desc:IsA("ModuleScript") then
            pcall(function() desc:Destroy() end)
        end
        if desc:IsA("BasePart") then
            safeSetPartPropsAsNoCollision(desc)
            pcall(function()
                if pcall(function() PhysicsService:GetCollisionGroups() end) then
                    pcall(function() PhysicsService:CreateCollisionGroup("ControlNPC_NoPlayer") end)
                    pcall(function() PhysicsService:CreateCollisionGroup("ControlNPC_PlayersGroup") end)
                    pcall(function() PhysicsService:CollisionGroupSetCollidable("ControlNPC_NoPlayer", "ControlNPC_PlayersGroup", false) end)
                    pcall(function() PhysicsService:SetPartCollisionGroup(desc, "ControlNPC_NoPlayer") end)
                end
            end)
        end
    end
end

local function assignPlayerPartsToPlayersGroup()
    local char = player.Character
    if not char then return end
    for _,desc in ipairs(char:GetDescendants()) do
        if desc:IsA("BasePart") then
            pcall(function()
                table.insert(changedPlayerParts, desc)
                if pcall(function() PhysicsService:GetCollisionGroups() end) then
                    pcall(function() PhysicsService:SetPartCollisionGroup(desc, "ControlNPC_PlayersGroup") end)
                end
            end)
        end
    end
end

local function revertCollisionGroups()
    for _,part in ipairs(changedNPCParts) do
        pcall(function()
            if part and part.Parent then
                part.CanCollide = true
                if pcall(function() return part.CanTouch end) then
                    pcall(function() part.CanTouch = true end)
                end
                pcall(function() PhysicsService:SetPartCollisionGroup(part, "Default") end)
            end
        end)
    end
    changedNPCParts = {}

    for _,part in ipairs(changedPlayerParts) do
        pcall(function()
            if part and part.Parent then
                pcall(function() PhysicsService:SetPartCollisionGroup(part, "Default") end)
            end
        end)
    end
    changedPlayerParts = {}
end

local function restoreCamera()
    camera.CameraType = Enum.CameraType.Custom
    pcall(function()
        if player.Character then
            local hum = player.Character:FindFirstChildWhichIsA("Humanoid")
            if hum then camera.CameraSubject = hum end
        end
    end)
end

-- Create/destroy NPC platform
local function createNpcSupportPlatform()
    if npcSupportPlatform and npcSupportPlatform.Parent then return end
    npcSupportPlatform = Instance.new("Part")
    npcSupportPlatform.Name = "ControlNPC_NPCSupportPlatform"
    npcSupportPlatform.Size = NPC_PLATFORM_SIZE
    npcSupportPlatform.Anchored = true
    npcSupportPlatform.CanCollide = true
    npcSupportPlatform.Transparency = 1
    npcSupportPlatform.Locked = true
    npcSupportPlatform.CastShadow = false
    npcSupportPlatform.Parent = Workspace
    pcall(function()
        if pcall(function() PhysicsService:GetCollisionGroups() end) then
            pcall(function() PhysicsService:SetPartCollisionGroup(npcSupportPlatform, "ControlNPC_PlayersGroup") end)
        end
    end)
end

local function destroyNpcSupportPlatform()
    if npcSupportPlatform then
        pcall(function() npcSupportPlatform:Destroy() end)
        npcSupportPlatform = nil
    end
end

-- Create/destroy player platform
local function createPlayerSupportPlatform()
    if playerSupportPlatform and playerSupportPlatform.Parent then return end
    playerSupportPlatform = Instance.new("Part")
    playerSupportPlatform.Name = "ControlNPC_PlayerSupportPlatform"
    playerSupportPlatform.Size = PLAYER_PLATFORM_SIZE
    playerSupportPlatform.Anchored = true
    playerSupportPlatform.CanCollide = true
    playerSupportPlatform.Transparency = 1
    playerSupportPlatform.Locked = true
    playerSupportPlatform.CastShadow = false
    playerSupportPlatform.Parent = Workspace
    pcall(function()
        if pcall(function() PhysicsService:GetCollisionGroups() end) then
            pcall(function() PhysicsService:SetPartCollisionGroup(playerSupportPlatform, "ControlNPC_PlayersGroup") end)
        end
    end)
end

local function destroyPlayerSupportPlatform()
    if playerSupportPlatform then
        pcall(function() playerSupportPlatform:Destroy() end)
        playerSupportPlatform = nil
    end
end

-- zero velocities helper
local function zeroCharacterVelocities(character)
    if not character then return end
    for _,desc in ipairs(character:GetDescendants()) do
        if desc:IsA("BasePart") then
            pcall(function()
                desc.Velocity = Vector3.new(0,0,0)
                desc.RotVelocity = Vector3.new(0,0,0)
                if pcall(function() return desc.AssemblyLinearVelocity end) then
                    desc.AssemblyLinearVelocity = Vector3.new(0,0,0)
                end
                if pcall(function() return desc.AssemblyAngularVelocity end) then
                    desc.AssemblyAngularVelocity = Vector3.new(0,0,0)
                end
            end)
        end
    end
end

-- immediate clamp used at start and on jump
local function immediateClampUnderNPC()
    local myChar = player.Character
    local myHum = myChar and myChar:FindFirstChildWhichIsA("Humanoid")
    local myHRP = myChar and myChar:FindFirstChild("HumanoidRootPart")
    if not (myChar and myHum and myHRP and controlledNPC and npcRoot) then return end

    local bottomY, surfacePart = findSupportingSurface()

    if not bottomY then
        local npcLowest = math.huge
        for _,p in ipairs(controlledNPC:GetDescendants()) do
            if p:IsA("BasePart") then
                local partBottom = p.Position.Y - (p.Size.Y * 0.5)
                if partBottom < npcLowest then npcLowest = partBottom end
            end
        end
        if npcLowest < math.huge then
            bottomY = npcLowest
        else
            bottomY = npcRoot.Position.Y
        end
    end

    local playerH = modelHeight(myChar)
    local desiredHRPY = bottomY - heightBelow - (playerH * 0.5)
    local finalY = desiredHRPY

    if npcAttachment then
        local targetPos = Vector3.new(npcRoot.Position.X, finalY, npcRoot.Position.Z)
        pcall(function() npcAttachment.WorldPosition = targetPos end)
    end

    -- strong immediate snap: temporarily PlatformStand + repeated HRP set to ensure initial lock
    pcall(function() myHum.PlatformStand = true end)
    for i=1,6 do
        pcall(function()
            myHRP.CFrame = CFrame.new(npcRoot.Position.X, finalY, npcRoot.Position.Z) * CFrame.Angles(0, FIXED_YAW_RAD, 0)
            zeroCharacterVelocities(myChar)
        end)
        task.wait(0.01)
    end
    -- keep PlatformStand true (we want the player to remain frozen). We'll restore on cleanup.
end

-- Jump handler
local function onJumpRequest()
    if active and npcHumanoid then
        pcall(function() npcHumanoid.Jump = true end)
        immediateClampUnderNPC()
    end
end

local function clampCharacterPartsBelow(character, clampY)
    if not character then return end
    for _,desc in ipairs(character:GetDescendants()) do
        if desc:IsA("BasePart") and desc.Name ~= "HumanoidRootPart" then
            local topY = desc.Position.Y + (desc.Size.Y * 0.5)
            if topY > clampY then
                local delta = topY - clampY
                pcall(function()
                    desc.CFrame = desc.CFrame - Vector3.new(0, delta, 0)
                    desc.Velocity = Vector3.new(0,0,0)
                    desc.RotVelocity = Vector3.new(0,0,0)
                end)
            end
        end
    end
end

-- Heartbeat: main loop
local accumulatorZeroVel = 0
local function heartbeat(dt)
    if not active then return end
    if not controlledNPC or not controlledNPC.Parent then cleanup(); return end
    if not npcHumanoid or npcHumanoid.Health <= 0 then cleanup(); return end

    local myChar = player.Character
    if not myChar or not myChar.Parent then
        if npcHumanoid and npcHumanoid.Health > 0 then pcall(function() npcHumanoid.Health = 0 end) end
        cleanup()
        return
    end

    local myHum = myChar:FindFirstChildWhichIsA("Humanoid")
    local myHRP = myChar:FindFirstChild("HumanoidRootPart")
    if not myHum or not myHRP then return end

    -- keep camera on NPC
    if npcHumanoid then
        camera.CameraType = Enum.CameraType.Custom
        pcall(function() camera.CameraSubject = npcHumanoid end)
    end

    -- determine bottomY under NPC
    local bottomY, surfacePart = findSupportingSurface()

    if not bottomY then
        local npcLowest = math.huge
        for _,p in ipairs(controlledNPC:GetDescendants()) do
            if p:IsA("BasePart") then
                local partBottom = p.Position.Y - (p.Size.Y * 0.5)
                if partBottom < npcLowest then npcLowest = partBottom end
            end
        end
        local extY = modelHeight(controlledNPC)
        bottomY = npcLowest < math.huge and npcLowest or (npcRoot.Position.Y - extY/2)
    end

    -- compute desired HRP Y
    local playerH = modelHeight(myChar)
    local desiredHRPY = bottomY - heightBelow - (playerH * 0.5)
    local finalY = desiredHRPY

    -- update npcAttachment target each frame (align will keep player locked)
    if npcAttachment then
        local targetPos = Vector3.new(npcRoot.Position.X, finalY, npcRoot.Position.Z)
        pcall(function() npcAttachment.WorldPosition = targetPos end)
    end

    -- Move npcSupportPlatform under NPC (conservative placement)
    if npcSupportPlatform then
        pcall(function()
            -- if we have surfacePart (the top of the supporting part) use it to position platform slightly below support top,
            -- otherwise fallback to under NPC root.
            if surfacePart and surfacePart:IsA("BasePart") then
                local belowY = surfacePart.Position.Y - (surfacePart.Size.Y * 0.5) - (npcSupportPlatform.Size.Y * 0.5) - PLATFORM_Y_OFFSET
                npcSupportPlatform.CFrame = CFrame.new(surfacePart.Position.X, belowY, surfacePart.Position.Z)
            else
                local platformY = finalY - (playerH * 0.5) - PLATFORM_Y_OFFSET
                npcSupportPlatform.CFrame = CFrame.new(npcRoot.Position.X, platformY, npcRoot.Position.Z)
            end
            npcSupportPlatform.Size = NPC_PLATFORM_SIZE
        end)
    end

    -- ensure player platform exists and is moved under player
    if playerSupportPlatform then
        pcall(function()
            local platformY = myHRP.Position.Y - (playerH * 0.5) - PLAYER_PLATFORM_DEPTH
            playerSupportPlatform.CFrame = CFrame.new(myHRP.Position.X, platformY, myHRP.Position.Z)
            playerSupportPlatform.Size = PLAYER_PLATFORM_SIZE
        end)
    else
        createPlayerSupportPlatform()
    end

    -- Clamp other parts below the surface
    clampCharacterPartsBelow(myChar, bottomY - heightBelow)

    -- Keep the humanoid in PlatformStand and zero velocities occasionally (not every frame) to avoid jitter
    pcall(function() myHum.PlatformStand = true end)
    accumulatorZeroVel = accumulatorZeroVel + dt
    if accumulatorZeroVel >= 0.12 then
        accumulatorZeroVel = 0
        zeroCharacterVelocities(myChar)
    end

    -- WalkTo & speed logic for NPC following player's movement input
    if npcHumanoid and npcRoot and npcHumanoid.Health > 0 then
        local md = myHum and myHum.MoveDirection or Vector3.new(0,0,0)
        local desiredSpeed = tonumber(speedBox.Text) or 16
        local isMoving = (md and md.Magnitude > WALK_THRESHOLD) and walkEnabled

        if isMoving then
            if not wasPlayerMoving then
                pcall(function() npcHumanoid.WalkSpeed = desiredSpeed end)
            end
            local dirFlat = Vector3.new(md.X, 0, md.Z)
            if dirFlat.Magnitude < 1e-4 then
                dirFlat = Vector3.new(npcRoot.CFrame.LookVector.X, 0, npcRoot.CFrame.LookVector.Z)
            end
            dirFlat = dirFlat.Unit
            local destination = npcRoot.Position + dirFlat * MOVE_DISTANCE
            pcall(function() npcHumanoid:MoveTo(destination) end)
        else
            pcall(function()
                npcHumanoid:MoveTo(npcRoot.Position)
                npcHumanoid.WalkSpeed = 0
            end)
        end

        wasPlayerMoving = isMoving
    end

    -- NPC JumpPower
    if npcHumanoid then
        local jp = tonumber(jumpBox.Text)
        if jp and jp > 1 then pcall(function() npcHumanoid.JumpPower = jp end) end
    end
end

local function teleportPlayerAbove(pos, height)
    height = height or 10
    local myChar = player.Character
    if not myChar then return end
    local myHRP = myChar:FindFirstChild("HumanoidRootPart")
    if not myHRP then return end
    pcall(function()
        myHRP.CFrame = CFrame.new(pos + Vector3.new(0, height, 0)) * CFrame.Angles(0, FIXED_YAW_RAD, 0)
        zeroCharacterVelocities(myChar)
    end)
end

local function createAlignConstraintsForCharacter(hrp)
    if not hrp then return end
    pcall(function() if alignPos then alignPos:Destroy() end end)
    pcall(function() if alignOri then alignOri:Destroy() end end)
    pcall(function() if playerAttachment then playerAttachment:Destroy() end end)

    playerAttachment = Instance.new("Attachment")
    playerAttachment.Name = "ControlNPC_PlayerAttachment"
    playerAttachment.Parent = hrp
    playerAttachment.Position = Vector3.new(0,0,0)

    alignPos = Instance.new("AlignPosition")
    alignPos.Name = "ControlNPC_AlignPosition"
    alignPos.Attachment0 = playerAttachment
    alignPos.MaxForce = ALIGN_MAX_FORCE
    alignPos.Responsiveness = ALIGN_RESPONSIVENESS
    alignPos.MaxVelocity = ALIGN_MAX_VELOCITY
    alignPos.RigidityEnabled = true
    alignPos.ApplyAtCenterOfMass = false
    alignPos.Parent = hrp

    alignOri = Instance.new("AlignOrientation")
    alignOri.Name = "ControlNPC_AlignOrientation"
    alignOri.Attachment0 = playerAttachment
    alignOri.MaxTorque = ALIGN_MAX_TORQUE
    alignOri.Responsiveness = ALIGN_RESPONSIVENESS
    alignOri.PrimaryAxisOnly = false
    alignOri.RigidityEnabled = true
    alignOri.Parent = hrp
end

local function destroyAlignConstraints()
    pcall(function() if alignPos then alignPos:Destroy() end end)
    pcall(function() if alignOri then alignOri:Destroy() end end)
    pcall(function() if playerAttachment then playerAttachment:Destroy() end end)
    alignPos = nil; alignOri = nil; playerAttachment = nil; npcAttachment = nil
end

-- Enable control
local function enableControl()
    if active then return end
    local char = player.Character
    if not char then StarterGui:SetCore("ChatMakeSystemMessage", {Text = "No character found."}); return end

    local npc = findNearestNPC()
    if not npc then StarterGui:SetCore("ChatMakeSystemMessage", {Text = "No NPC found nearby."}); return end

    local hum = npc:FindFirstChildOfClass("Humanoid")
    local hrp = npc:FindFirstChild("HumanoidRootPart") or npc.PrimaryPart
    if not hum or not hrp then StarterGui:SetCore("ChatMakeSystemMessage", {Text = "Nearest NPC missing Humanoid/RootPart."}); return end

    controlledNPC = npc
    npcHumanoid = hum
    npcRoot = hrp
    active = true
    toggleBtn.Text = "Toggle Control: ON"
    walkEnabled = true
    walkToggle.Text = "WalkTo: On"

    pcall(function() npcOriginalWalkSpeed = npcHumanoid.WalkSpeed end)
    neutralizeNPC(controlledNPC)

    pcall(function()
        if pcall(function() PhysicsService:GetCollisionGroups() end) then
            pcall(function() PhysicsService:CreateCollisionGroup("ControlNPC_NoPlayer") end)
            pcall(function() PhysicsService:CreateCollisionGroup("ControlNPC_PlayersGroup") end)
            pcall(function() PhysicsService:CollisionGroupSetCollidable("ControlNPC_NoPlayer", "ControlNPC_PlayersGroup", false) end)
            assignPlayerPartsToPlayersGroup()
        end
    end)

    camera.CameraType = Enum.CameraType.Custom
    pcall(function() camera.CameraSubject = npcHumanoid end)

    if not heartbeatConn then heartbeatConn = RunService.Heartbeat:Connect(heartbeat) end
    if not jumpConn then jumpConn = UserInputService.JumpRequest:Connect(onJumpRequest) end

    local myChar = player.Character
    if myChar then
        local myHum = myChar:FindFirstChildWhichIsA("Humanoid")
        if myHum then
            pcall(function()
                myOriginalJumpPower = myHum.JumpPower
                myOriginalWalkSpeed = myHum.WalkSpeed
                myHum.JumpPower = 0
                myHum.WalkSpeed = 0
                pcall(function() myOriginalAutoRotate = myHum.AutoRotate; myHum.AutoRotate = false end)
            end)
        end

        local myHRP = myChar:FindFirstChild("HumanoidRootPart")
        if myHRP then
            -- create align and npc attachment
            createAlignConstraintsForCharacter(myHRP)

            npcAttachment = Instance.new("Attachment")
            npcAttachment.Name = "ControlNPC_NPCAttachment"
            npcAttachment.Parent = npcRoot

            if alignPos then alignPos.Attachment1 = npcAttachment end
            if alignOri then alignOri.Attachment1 = npcAttachment end

            -- create platforms immediately to avoid a single-frame fall
            createNpcSupportPlatform()
            createPlayerSupportPlatform()

            -- Strong immediate clamp, and keep PlatformStand true to fix player in place
            if myHum then
                pcall(function() myHum.PlatformStand = true end)
            end
            immediateClampUnderNPC()
            -- keep PlatformStand true (player intended to remain completely still)
        end
    end

    local function attachPlayerSignals()
        local myChar = player.Character
        if not myChar then return end
        local myHum = myChar:FindFirstChildWhichIsA("Humanoid")
        if myHum then
            if playerDiedConn then playerDiedConn:Disconnect(); playerDiedConn = nil end
            playerDiedConn = myHum.Died:Connect(function()
                if npcHumanoid and npcHumanoid.Health > 0 then pcall(function() npcHumanoid.Health = 0 end) end
                cleanup()
            end)
        end
    end
    attachPlayerSignals()

    -- respawn handling
    if not charAddedConn then
        charAddedConn = player.CharacterAdded:Connect(function(char)
            task.wait(0.08)
            pcall(function()
                if pcall(function() PhysicsService:GetCollisionGroups() end) then
                    assignPlayerPartsToPlayersGroup()
                end
            end)

            if active and controlledNPC and controlledNPC.Parent and npcRoot and npcRoot.Parent then
                local hrp = char:WaitForChild("HumanoidRootPart", 2)
                local myHum = char:FindFirstChildWhichIsA("Humanoid")
                if hrp then
                    createAlignConstraintsForCharacter(hrp)
                    npcAttachment = Instance.new("Attachment")
                    npcAttachment.Name = "ControlNPC_NPCAttachment"
                    npcAttachment.Parent = npcRoot
                    if alignPos then alignPos.Attachment1 = npcAttachment end
                    if alignOri then alignOri.Attachment1 = npcAttachment end

                    createNpcSupportPlatform()
                    createPlayerSupportPlatform()

                    if myHum then pcall(function() myHum.PlatformStand = true end) end
                    immediateClampUnderNPC()
                end
            end

            attachPlayerSignals()
        end)
    end

    -- npc platformstand watcher
    if npcHumanoid then
        if npcPlatformStandConn then npcPlatformStandConn:Disconnect() npcPlatformStandConn = nil end
        npcPlatformStandConn = npcHumanoid:GetPropertyChangedSignal("PlatformStand"):Connect(function()
            if npcHumanoid.PlatformStand then
                if npcNoclipToggle then setNpcNoClip(false) end
            else
                if npcNoclipToggle then setNpcNoClip(true) end
            end
        end)
    end

    if npcHumanoid then
        if npcDiedConn then npcDiedConn:Disconnect(); npcDiedConn = nil end
        npcDiedConn = npcHumanoid.Died:Connect(function()
            local deathPos
            pcall(function() deathPos = npcRoot and npcRoot.Position or controlledNPC.PrimaryPart and controlledNPC.PrimaryPart.Position end)
            if deathPos then teleportPlayerAbove(deathPos, 10) end
            cleanup()
        end)
    end
end

-- Disable control and cleanup
local function disableControl()
    if controlledNPC and npcRoot then
        local pos
        pcall(function() pos = npcRoot.Position end)
        if not pos and controlledNPC and controlledNPC.PrimaryPart then pcall(function() pos = controlledNPC.PrimaryPart.Position end) end
        if pos then teleportPlayerAbove(pos, 10) end
    end
    cleanup()
end

function cleanup()
    active = false
    walkEnabled = false
    wasPlayerMoving = false

    if npcHumanoid and npcOriginalWalkSpeed then
        pcall(function() npcHumanoid.WalkSpeed = npcOriginalWalkSpeed end)
    end

    if heartbeatConn then heartbeatConn:Disconnect() heartbeatConn = nil end
    if jumpConn then jumpConn:Disconnect() jumpConn = nil end
    if charAddedConn then charAddedConn:Disconnect() charAddedConn = nil end
    if playerDiedConn then playerDiedConn:Disconnect() playerDiedConn = nil end
    if npcDiedConn then npcDiedConn:Disconnect() npcDiedConn = nil end
    if npcPlatformStandConn then npcPlatformStandConn:Disconnect() npcPlatformStandConn = nil end

    destroyAlignConstraints()
    pcall(function() if npcAttachment then npcAttachment:Destroy() end end)
    npcAttachment = nil

    local myChar = player.Character
    if myChar then
        local myHum = myChar:FindFirstChildWhichIsA("Humanoid")
        if myHum then
            pcall(function()
                if myOriginalJumpPower then myHum.JumpPower = myOriginalJumpPower end
                if myOriginalWalkSpeed then myHum.WalkSpeed = myOriginalWalkSpeed end
                myHum.PlatformStand = false
                if myOriginalAutoRotate ~= nil then
                    pcall(function() myHum.AutoRotate = myOriginalAutoRotate end); myOriginalAutoRotate = nil
                else
                    pcall(function() myHum.AutoRotate = true end)
                end
            end)
        end
        zeroCharacterVelocities(myChar)
    end

    restoreCamera()
    pcall(function() revertCollisionGroups() end)
    destroyNpcSupportPlatform()
    destroyPlayerSupportPlatform()

    if npcNoclipToggle then setNpcNoClip(false) end

    controlledNPC = nil
    npcHumanoid = nil
    npcRoot = nil
    npcOriginalWalkSpeed = nil

    toggleBtn.Text = "Toggle Control: OFF"
    walkToggle.Text = "WalkTo: Off"
    noclipBtn.Text = "NPC Noclip: Off"
    npcNoclipToggle = false
end

local function killControlledNPC()
    if npcHumanoid then pcall(function() npcHumanoid.Health = 0 end) end
end

-- GUI bindings
toggleBtn.MouseButton1Click:Connect(function()
    if active then disableControl() else enableControl() end
end)

walkToggle.MouseButton1Click:Connect(function()
    walkEnabled = not walkEnabled
    walkToggle.Text = "WalkTo: " .. (walkEnabled and "On" or "Off")
    if not walkEnabled and npcHumanoid and npcRoot then
        pcall(function() npcHumanoid:MoveTo(npcRoot.Position); npcHumanoid.WalkSpeed = 0 end)
    end
end)

noclipBtn.MouseButton1Click:Connect(function()
    npcNoclipToggle = not npcNoclipToggle
    noclipBtn.Text = "NPC Noclip: " .. (npcNoclipToggle and "On" or "Off")
    if npcNoclipToggle then
        if npcHumanoid and not npcHumanoid.PlatformStand then setNpcNoClip(true) end
    else
        setNpcNoClip(false)
    end
end)

killBtn.MouseButton1Click:Connect(function() killControlledNPC() end)

heightBox.FocusLost:Connect(function()
    local n = tonumber(heightBox.Text)
    if n then heightBelow = n else heightBox.Text = tostring(heightBelow) end
    if active then immediateClampUnderNPC() end
end)

local adjusting = false
local adjustConn = nil
local ADJUST_STEP = 0.02
local ADJUST_INTERVAL = 0.05

local function startAdjusting(delta)
    adjusting = true
    if adjustConn then adjustConn:Disconnect() adjustConn = nil end
    adjustConn = RunService.Heartbeat:Connect(function(dt)
        if not adjusting then return end
        heightBelow = heightBelow + delta * (dt / ADJUST_INTERVAL) * ADJUST_STEP
        heightBox.Text = string.format("%.3f", heightBelow)
        if active then immediateClampUnderNPC() end
    end)
end

local function stopAdjusting()
    adjusting = false
    if adjustConn then adjustConn:Disconnect() adjustConn = nil end
end

upBtn.MouseButton1Down:Connect(function() startAdjusting(1) end)
upBtn.MouseButton1Up:Connect(stopAdjusting)
upBtn.MouseLeave:Connect(stopAdjusting)
downBtn.MouseButton1Down:Connect(function() startAdjusting(-1) end)
downBtn.MouseButton1Up:Connect(stopAdjusting)
downBtn.MouseLeave:Connect(stopAdjusting)

UserInputService.InputEnded:Connect(function(input, gameProcessed)
    if input.UserInputType == Enum.UserInputType.Touch or input.UserInputType == Enum.UserInputType.MouseButton1 then
        stopAdjusting()
    end
end)

visibilityToggle.MouseButton1Click:Connect(function()
    frame.Visible = not frame.Visible
    visibilityToggle.Text = frame.Visible and "▣" or "▢"
end)

script.AncestryChanged:Connect(function(_, parent)
    if not parent then cleanup() end
end)

StarterGui:SetCore("ChatMakeSystemMessage", {Text = "[ControlNPC] Ready. Player locks under the actual support top surface (thin parts handled correctly)."})
