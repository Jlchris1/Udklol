-- Devour Soul + Black Hole tools (LocalScript)
-- StarterPlayerScripts (client)
-- Key features:
--  * Multi-owner safe handle (prevents multiple clicks from stomping each other)
--  * Click-created temp BH attaches all parts of clicked NPC to the click location
--  * Persistent BH never auto-grabs NPC parts (only grabs world props)
--  * BH toggle fully releases previously-processed parts and stops future pickup
--  * Singularity instant-picks all NPCs in radius (keeps earlier behavior)

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local UserInputService = game:GetService("UserInputService")

local localPlayer = Players.LocalPlayer
if not localPlayer then return end
local Camera = Workspace.CurrentCamera

-- ======================
-- Small utilities
-- ======================
local function clamp(v,a,b) if v < a then return a elseif v > b then return b end return v end
local function isPlayerCharacter(model) return model and Players:GetPlayerFromCharacter(model) ~= nil end
local function isNPC(character)
    if not character or not character:IsA("Model") then return false end
    return character:FindFirstChildOfClass("Humanoid") ~= nil and not Players:GetPlayerFromCharacter(character)
end
local function isPartPlayerCharacter(part)
    if not part then return false end
    for _, pl in ipairs(Players:GetPlayers()) do
        local char = pl.Character
        if char and part:IsDescendantOf(char) then return true end
    end
    return false
end

local function stripBodyForces(part)
    if not part then return end
    for _, c in ipairs(part:GetChildren()) do
        if c:IsA("BodyPosition") or c:IsA("BodyGyro") or c:IsA("BodyVelocity")
        or c:IsA("BodyAngularVelocity") or c:IsA("BodyForce") or c:IsA("RocketPropulsion") then
            pcall(function() c:Destroy() end)
        end
    end
end

local function screenPosToWorldPosition(screenPos)
    if not Camera then Camera = Workspace.CurrentCamera end
    if not Camera then return nil end
    local ray = Camera:ScreenPointToRay(screenPos.X, screenPos.Y)
    local params = RaycastParams.new()
    params.FilterDescendantsInstances = { localPlayer.Character }
    params.FilterType = Enum.RaycastFilterType.Blacklist
    local res = Workspace:Raycast(ray.Origin, ray.Direction * 2000, params)
    if res then
        return res.Position, res.Instance
    else
        return ray.Origin + ray.Direction * 100, nil
    end
end

-- ======================
-- Config
-- ======================
local DEVOUR_NAME = "Devour Soul"
local BLACKHOLE_TOOL_NAME = "Black Hole"

local LIFT_STUDS = 25
local DRAIN_INTERVAL = 0.01
local DRAIN_PCT = 0.005
local ALIGN_MAX_FORCE = 9e9
local ALIGN_RESP = 1200
local ALIGN_ORI_RESP = 1200
local ANCHOR_SIZE = Vector3.new(1,1,1)
local EXPLOSION_VELOCITY = 70

local BH_FOLDER_NAME = "DevourBH_Folder"
local BH_CENTER_NAME = "DevourBH_Center"
local BH_ATTACHMENT_NAME = "DevourBH_Att"
local BH_PULL_FORCE = 6e7
local BH_PULL_RESP = 200
local BH_TORQUE = Vector3.new(0, 1e6, 0)

local SNAP_RADIUS = 8
local TEMP_BH_LIFETIME = 1
local CLICK_KILL_HP_TOGGLE_PERIOD = 0.3
local CLICK_KILL_TOGGLE_DURATION = 5
local SINGULARITY_RADIUS = 200
local SINGULARITY_HANDLE_LIFETIME = 10
local SINGULARITY_HIT_TOGGLE_PERIOD = 0.5
local SINGULARITY_HIT_TOGGLE_DURATION = 5
local SINGULARITY_ARRIVAL_KILL_DISTANCE = 3

-- ======================
-- Persistent BH (center following player)
-- ======================
local BHFolder = Workspace:FindFirstChild(BH_FOLDER_NAME)
if not BHFolder then BHFolder = Instance.new("Folder", Workspace); BHFolder.Name = BH_FOLDER_NAME end

local centerPart = BHFolder:FindFirstChild(BH_CENTER_NAME)
if not centerPart then
    centerPart = Instance.new("Part")
    centerPart.Name = BH_CENTER_NAME
    centerPart.Anchored = true
    centerPart.CanCollide = false
    centerPart.Transparency = 1
    centerPart.Size = Vector3.new(1,1,1)
    centerPart.Parent = BHFolder
end

local BH_Attachment = centerPart:FindFirstChild(BH_ATTACHMENT_NAME)
if not BH_Attachment then
    BH_Attachment = Instance.new("Attachment")
    BH_Attachment.Name = BH_ATTACHMENT_NAME
    BH_Attachment.Parent = centerPart
end

-- tracking tables for persistent BH
local processedParts = {}           -- processedParts[part] = true (parts currently managed by persistent BH)
local initiallyMasslessParts = {}   -- initiallyMasslessParts[part] = bool or nil
local initiallyAnchoredParts = {}   -- initiallyAnchoredParts[part] = bool or nil

-- flag to enable/disable persistent BH
local persistentBHEnabled = true

-- ======================
-- Multi-owner handle management
--  - single physical Handle per tool (Tool.Handle),
--  - but multiple logical owners may hold it at once.
--  - only destroy physical Handle when all owners release it.
-- ======================
local toolHandleOwners = {} -- toolHandleOwners[tool] = { ownerId = true, ... }

local function ensureHandleOwnersTable(tool)
    if not toolHandleOwners[tool] then toolHandleOwners[tool] = {} end
    return toolHandleOwners[tool]
end

-- create physical handle if missing, and register ownerId
local function addHandleOwner(tool, ownerId)
    if not tool or not ownerId then return end
    local owners = ensureHandleOwnersTable(tool)
    owners[ownerId] = true
    -- create physical Handle if missing
    if not tool:FindFirstChild("Handle") then
        local handle = Instance.new("Part")
        handle.Name = "Handle"
        handle.Size = Vector3.new(1,1,1)
        handle.Transparency = 0.5
        handle.CanCollide = false
        handle.Massless = true
        handle.Parent = tool
    end
    -- store owners count as attribute for debugging (optional)
    pcall(function() tool:SetAttribute("HandleOwnersCount", #(
        (function(t)
            local c=0 for _ in pairs(t) do c=c+1 end return c end)(owners)
    )) end)
end

-- remove ownerId; destroy physical Handle only when no owners remain
local function removeHandleOwner(tool, ownerId)
    if not tool or not ownerId then return end
    local owners = ensureHandleOwnersTable(tool)
    owners[ownerId] = nil
    local any = false
    for _ in pairs(owners) do any = true; break end
    if not any then
        -- no owners -> destroy physical Handle (safe)
        local h = tool:FindFirstChild("Handle")
        if h then pcall(function() h:Destroy() end) end
        toolHandleOwners[tool] = nil
        pcall(function() tool:SetAttribute("HandleOwnersCount", 0) end)
    else
        pcall(function() tool:SetAttribute("HandleOwnersCount", (function(t) local c=0; for _ in pairs(t) do c=c+1 end; return c end)(owners)) end)
    end
end

-- convenience: remove all owners for a tool (used when unequipping / cleanup)
local function clearAllHandleOwners(tool)
    if not tool then return end
    toolHandleOwners[tool] = nil
    local h = tool:FindFirstChild("Handle")
    if h then pcall(function() h:Destroy() end) end
    pcall(function() tool:SetAttribute("HandleOwnersCount", 0) end)
end

-- ======================
-- Persistent BH: process non-NPC world parts only
-- ======================
local function ForcePartToBH(v)
    if not persistentBHEnabled then return end
    if not v or not v:IsA("BasePart") then return end
    if v.Anchored then return end
    if v.Name == "Handle" then return end
    if processedParts[v] then return end
    if isPartPlayerCharacter(v) then return end
    if localPlayer.Character and v:IsDescendantOf(localPlayer.Character) then return end
    -- IMPORTANT: do not auto-pick NPC parts (parent with Humanoid)
    if v.Parent and v.Parent:FindFirstChildOfClass("Humanoid") then return end

    processedParts[v] = true
    initiallyAnchoredParts[v] = initiallyAnchoredParts[v] == nil and v.Anchored or initiallyAnchoredParts[v]
    initiallyMasslessParts[v] = initiallyMasslessParts[v] == nil and v.Massless or initiallyMasslessParts[v]

    pcall(function() v.Massless = true end)
    stripBodyForces(v)
    pcall(function() v.CanCollide = false end)

    local att = Instance.new("Attachment")
    att.Name = "DevourBH_Att_Part"
    att.Parent = v
    pcall(function() att.WorldCFrame = v.CFrame end)

    local ap = Instance.new("AlignPosition")
    ap.Name = "DevourBH_Align"
    ap.Attachment0 = att
    ap.Attachment1 = BH_Attachment
    ap.MaxForce = BH_PULL_FORCE
    ap.MaxVelocity = math.huge
    ap.Responsiveness = BH_PULL_RESP
    ap.Parent = v

    local ok, Torque = pcall(function() return Instance.new("Torque") end)
    if ok and Torque then
        Torque.Attachment0 = att
        Torque.Parent = v
        Torque.Torque = BH_TORQUE
    else
        pcall(function() v.AssemblyAngularVelocity = Vector3.new(0,60,0) end)
    end
end

local function initialScanAndForce()
    if not persistentBHEnabled then return end
    for _, v in ipairs(Workspace:GetDescendants()) do
        if v:IsA("BasePart") then
            if not v.Anchored and v.Name ~= "Handle"
                and not isPartPlayerCharacter(v)
                and not (localPlayer.Character and v:IsDescendantOf(localPlayer.Character))
                and not (v.Parent and v.Parent:FindFirstChildOfClass("Humanoid"))
            then
                if initiallyAnchoredParts[v] == nil then initiallyAnchoredParts[v] = v.Anchored end
                if initiallyMasslessParts[v] == nil then pcall(function() initiallyMasslessParts[v] = v.Massless end) end
                pcall(function() v.Massless = true end)
                ForcePartToBH(v)
            end
        end
    end
end

-- disabling persistent BH: restore previously processed parts and stop future processing
local function disablePersistentBH()
    persistentBHEnabled = false

    -- restore tracked parts
    for p, _ in pairs(processedParts) do
        if p and p.Parent then
            pcall(function() p.CanCollide = true end)
            pcall(function() if initiallyMasslessParts[p] ~= nil then p.Massless = initiallyMasslessParts[p] end end)
            pcall(function() if initiallyAnchoredParts[p] == false then p.Anchored = false end end)
            local ap = p:FindFirstChild("DevourBH_Align")
            if ap then pcall(function() ap:Destroy() end) end
            local att = p:FindFirstChild("DevourBH_Att_Part")
            if att then pcall(function() att:Destroy() end) end
            -- remove torque attachments created earlier
            for _, c in ipairs(p:GetChildren()) do
                if c:IsA("Torque") then pcall(function() c:Destroy() end) end
                -- remove any leftover TempBH_* or Sing_* attachments we created
                if c:IsA("Attachment") and (c.Name:match("^TempBH_") or c.Name:match("^Sing_") or c.Name:match("^Devour_")) then
                    pcall(function() c:Destroy() end)
                end
            end
        end
        processedParts[p] = nil
        initiallyMasslessParts[p] = nil
        initiallyAnchoredParts[p] = nil
    end

    -- additionally, release any parts that still have AlignPositions that point to BH_Attachment
    for _, ap in ipairs(Workspace:GetDescendants()) do
        if ap:IsA("AlignPosition") and ap.Attachment1 == BH_Attachment then
            local parentPart = ap.Parent
            pcall(function() ap:Destroy() end)
            if parentPart and parentPart:IsA("BasePart") then
                pcall(function() parentPart.CanCollide = true end)
                pcall(function() if initiallyMasslessParts[parentPart] ~= nil then parentPart.Massless = initiallyMasslessParts[parentPart] end end)
            end
        end
    end
end

local function enablePersistentBH()
    persistentBHEnabled = true
    initialScanAndForce()
end

Workspace.DescendantAdded:Connect(function(v)
    if not persistentBHEnabled then return end
    if v and v:IsA("BasePart") then
        if not v.Anchored and v.Name ~= "Handle"
            and not isPartPlayerCharacter(v)
            and not (localPlayer.Character and v:IsDescendantOf(localPlayer.Character))
            and not (v.Parent and v.Parent:FindFirstChildOfClass("Humanoid"))
        then
            if initiallyAnchoredParts[v] == nil then initiallyAnchoredParts[v] = v.Anchored end
            if initiallyMasslessParts[v] == nil then pcall(function() initiallyMasslessParts[v] = v.Massless end) end
            pcall(function() v.Massless = true end)
            ForcePartToBH(v)
        end
    end
end)

-- center part follow
spawn(function()
    while true do
        local char = localPlayer.Character
        if char and char:FindFirstChild("HumanoidRootPart") then
            local hrp = char.HumanoidRootPart
            local upOffset = Vector3.new(0,20,0)
            local behind = -10
            local desiredPos = hrp.Position + upOffset + hrp.CFrame.LookVector * behind
            pcall(function() centerPart.Position = desiredPos end)
            pcall(function() BH_Attachment.WorldPosition = centerPart.Position end)
        else
            pcall(function() centerPart.Position = Camera and Camera.CFrame.p or Vector3.new(0,50,0) end)
            pcall(function() BH_Attachment.WorldPosition = centerPart.Position end)
        end
        RunService.Heartbeat:Wait()
    end
end)

-- ======================
-- Devour tool (safe handle behavior per your example)
-- ======================
local function createDevourTool()
    local bp = localPlayer:FindFirstChildOfClass("Backpack")
    if not bp then return nil end
    local existing = bp:FindFirstChild(DEVOUR_NAME) or (localPlayer.Character and localPlayer.Character:FindFirstChild(DEVOUR_NAME))
    if existing and existing:IsA("Tool") then return existing end
    local tool = Instance.new("Tool")
    tool.Name = DEVOUR_NAME
    tool.RequiresHandle = false
    tool.CanBeDropped = false
    tool.Parent = bp
    return tool
end

local function findFallbackPartInModel(model)
    if not model then return nil end
    for _, v in ipairs(model:GetDescendants()) do
        if v:IsA("BasePart") and v.Name ~= "Handle" then return v end
    end
    return nil
end

local function explodeCharacterParts(model)
    if not model then return end
    local centerPart = model:FindFirstChild("HumanoidRootPart") or model:FindFirstChild("Torso") or model:FindFirstChild("UpperTorso")
    local centerPos = centerPart and centerPart.Position or (model:GetModelCFrame().p or Vector3.new())
    for _, v in ipairs(model:GetDescendants()) do
        if v:IsA("BasePart") then
            pcall(function()
                local dir = (v.Position - centerPos)
                if dir.Magnitude < 0.001 then dir = Vector3.new(math.random()-0.5, 0.5 + math.random()*0.5, math.random()-0.5) end
                dir = dir.Unit
                local vel = dir * EXPLOSION_VELOCITY + Vector3.new(0, EXPLOSION_VELOCITY * 0.25, 0)
                v.AssemblyLinearVelocity = vel
                v.AssemblyAngularVelocity = Vector3.new((math.random()-0.5)*60, (math.random()-0.5)*60, (math.random()-0.5)*60)
            end)
        end
    end
end

-- Devour handle tracking (we'll use handle owner system)
local latestTargetModel = nil
local latestDeathConn = nil

local function performDevourOn(humanoid, model, tool)
    if not humanoid or not model then return end
    if isPlayerCharacter(model) then return end
    if model:FindFirstChild("DevourSoul_Grabbed") then return end
    local tag = Instance.new("BoolValue"); tag.Name = "DevourSoul_Grabbed"; tag.Parent = model

    -- create handle owner for devour (ownerId "devour")
    if tool and tool.Parent then addHandleOwner(tool, "devour") end
    latestTargetModel = model

    local hrp = model:FindFirstChild("HumanoidRootPart") or model:FindFirstChild("LowerTorso") or model:FindFirstChild("Torso") or findFallbackPartInModel(model)
    if not hrp or not hrp:IsA("BasePart") then pcall(function() tag:Destroy() end); if tool then removeHandleOwner(tool,"devour") end; latestTargetModel = nil; return end

    local anchor = Instance.new("Part")
    anchor.Name = "DevourSoul_Anchor"; anchor.Size = ANCHOR_SIZE; anchor.Transparency = 1; anchor.Anchored = true; anchor.CanCollide = false; anchor.Massless = true
    anchor.Parent = Workspace; anchor.CFrame = hrp.CFrame

    local attAnchor = Instance.new("Attachment", anchor); attAnchor.Name = "Devour_Attach_Anchor"
    local attHRP = Instance.new("Attachment", hrp); attHRP.Name = "Devour_Attach_HRP"; attHRP.WorldCFrame = hrp.CFrame

    local alignPos = Instance.new("AlignPosition", hrp)
    alignPos.Name = "Devour_AlignPos"; alignPos.Attachment0 = attHRP; alignPos.Attachment1 = attAnchor
    alignPos.RigidityEnabled = true; alignPos.MaxForce = ALIGN_MAX_FORCE; alignPos.Responsiveness = ALIGN_RESP; alignPos.MaxVelocity = math.huge

    local alignOri = Instance.new("AlignOrientation", hrp)
    alignOri.Name = "Devour_AlignOri"; alignOri.Attachment0 = attHRP; alignOri.Attachment1 = attAnchor
    alignOri.MaxTorque = 9e9; alignOri.Responsiveness = ALIGN_ORI_RESP

    local maxH = humanoid and humanoid.MaxHealth > 0 and humanoid.MaxHealth or 1
    local currH = humanoid and humanoid.Health or maxH
    local dmgPerSec = (maxH * DRAIN_PCT) / math.max(DRAIN_INTERVAL, 1e-6)
    local timeToDie = (dmgPerSec > 0) and (currH / dmgPerSec) or 0.1
    if timeToDie <= 0.001 then timeToDie = 0.1 end
    local liftTime = timeToDie

    local startY = anchor.Position.Y
    local targetY = startY + LIFT_STUDS
    local elapsed = 0
    local finished = false

    local function doCleanupAndExplode()
        if finished then return end
        finished = true
        pcall(function()
            if alignPos and alignPos.Parent then alignPos:Destroy() end
            if alignOri and alignOri.Parent then alignOri:Destroy() end
            if attHRP and attHRP.Parent then attHRP:Destroy() end
            if attAnchor and attAnchor.Parent then attAnchor:Destroy() end
            if anchor and anchor.Parent then anchor:Destroy() end
        end)
        pcall(function() explodeCharacterParts(model) end)
        -- only remove devour owner if this model was the latestTargetModel
        if latestTargetModel == model then
            if tool then removeHandleOwner(tool, "devour") end
            latestTargetModel = nil
        end
        pcall(function() if tag and tag.Parent then tag:Destroy() end end)
    end

    local deathConnLocal
    deathConnLocal = humanoid.Died:Connect(function()
        doCleanupAndExplode()
        if deathConnLocal then deathConnLocal:Disconnect() end
    end)

    if latestDeathConn then pcall(function() latestDeathConn:Disconnect() end); latestDeathConn = nil end
    latestDeathConn = deathConnLocal

    local drainAccum = 0
    local conn
    conn = RunService.Heartbeat:Connect(function(dt)
        if finished then conn:Disconnect(); return end
        elapsed = elapsed + dt
        local t = clamp(elapsed / math.max(liftTime, 1e-6), 0, 1)
        local eased = t < 0.5 and 8 * t^4 or 1 - (-2 * t + 2)^4 / 2
        local newY = startY + (targetY - startY) * eased
        pcall(function()
            if hrp and hrp.Parent then
                local hrpRot = hrp.CFrame - hrp.CFrame.Position
                anchor.CFrame = CFrame.new(hrp.Position.X, newY, hrp.Position.Z) * hrpRot
            end
        end)
        pcall(function() if hrp and hrp:IsA("BasePart") then hrp.AssemblyLinearVelocity = Vector3.new(0,0,0); hrp.AssemblyAngularVelocity = Vector3.new(0,0,0) end end)

        drainAccum = drainAccum + dt
        while drainAccum >= DRAIN_INTERVAL do
            drainAccum = drainAccum - DRAIN_INTERVAL
            local dmg = maxH * DRAIN_PCT
            pcall(function()
                if humanoid and humanoid.Health > 0 then
                    humanoid.Health = clamp(humanoid.Health - dmg, 0, humanoid.MaxHealth)
                end
            end)
            if humanoid.Health <= 0 then break end
        end
        if t >= 1 then
            doCleanupAndExplode()
            conn:Disconnect()
            return
        end
    end)
end

local function wireDevourTool(tool)
    if not tool or not tool:IsA("Tool") then return end
    local mouseConn, touchBeganConn, touchChangedConn, touchEndedConn
    local touchState = {}

    tool.Equipped:Connect(function(mouse)
        if not mouse then mouse = localPlayer:GetMouse() end

        -- Desktop
        mouseConn = mouse.Button1Down:Connect(function()
            local target = mouse.Target
            local hit = mouse.Hit and mouse.Hit.p
            local hum, model = findHumanoidFromTargetOrPosition(target, hit, 8)
            if not hum or not model then return end
            if isPlayerCharacter(model) then return end
            pcall(function() performDevourOn(hum, model, tool) end)
        end)

        -- Touch: improved tap detection (prevents joystick interference)
        touchBeganConn = UserInputService.InputBegan:Connect(function(input, processed)
            if processed then return end
            if input.UserInputType == Enum.UserInputType.Touch then
                local vs = Camera and Camera.ViewportSize or Vector2.new(1920,1080)
                local joystickIgnoreSize = 220
                if input.Position.X <= joystickIgnoreSize and input.Position.Y >= (vs.Y - joystickIgnoreSize) then
                    touchState[input] = nil
                    return
                end
                touchState[input] = {pos = input.Position, time = tick(), lastPos = input.Position, moved = 0}
            end
        end)
        touchChangedConn = UserInputService.InputChanged:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.Touch and touchState[input] then
                touchState[input].lastPos = input.Position
                touchState[input].moved = (input.Position - touchState[input].pos).Magnitude
            end
        end)
        touchEndedConn = UserInputService.InputEnded:Connect(function(input, processed)
            if input.UserInputType == Enum.UserInputType.Touch and touchState[input] then
                local data = touchState[input]
                local duration = tick() - data.time
                local moved = data.moved or 0
                if duration < 0.35 and moved < 24 and not processed then
                    local worldPos, instance = screenPosToWorldPosition(input.Position)
                    local hum, model = findHumanoidFromTargetOrPosition(instance, worldPos, 8)
                    if hum and model and not isPlayerCharacter(model) then
                        pcall(function() performDevourOn(hum, model, tool) end)
                    end
                end
                touchState[input] = nil
            end
        end)
    end)

    tool.Unequipped:Connect(function()
        if mouseConn then mouseConn:Disconnect(); mouseConn = nil end
        if touchBeganConn then touchBeganConn:Disconnect(); touchBeganConn = nil end
        if touchChangedConn then touchChangedConn:Disconnect(); touchChangedConn = nil end
        if touchEndedConn then touchEndedConn:Disconnect(); touchEndedConn = nil end
        clearAllHandleOwners(tool)
    end)
end

-- findHumanoidFromTargetOrPosition (hit-through fallback)
function findHumanoidFromTargetOrPosition(targetPart, hitPos, snapRadius)
    snapRadius = snapRadius or 6
    if targetPart then
        local node = targetPart
        for i = 1, 10 do
            if not node then break end
            local hum = node:FindFirstChildOfClass("Humanoid")
            if hum then return hum, node end
            node = node.Parent
        end
    end
    if hitPos then
        local foundHum, foundModel, foundDist = nil, nil, math.huge
        for _, obj in ipairs(Workspace:GetDescendants()) do
            if obj:IsA("Model") then
                local hum = obj:FindFirstChildOfClass("Humanoid")
                if hum and hum.Health ~= nil and not Players:GetPlayerFromCharacter(obj) then
                    local hrp = obj:FindFirstChild("HumanoidRootPart") or obj:FindFirstChild("UpperTorso") or obj:FindFirstChild("Torso")
                    if hrp and hrp:IsA("BasePart") then
                        local d = (hrp.Position - hitPos).Magnitude
                        if d < snapRadius and d < foundDist then
                            foundHum, foundModel, foundDist = hum, obj, d
                        end
                    end
                end
            end
        end
        if foundHum then return foundHum, foundModel end
    end
    return nil, nil
end

-- ======================
-- Black Hole helpers
-- ======================
local function createTemporaryBH(pos)
    local folder = Workspace:FindFirstChild(BH_FOLDER_NAME) or Instance.new("Folder", Workspace)
    folder.Name = BH_FOLDER_NAME
    local part = Instance.new("Part", folder)
    part.Name = "TempBH_Center"
    part.Size = Vector3.new(1,1,1)
    part.Transparency = 1
    part.Anchored = true
    part.CanCollide = false
    part.Position = pos
    local att = Instance.new("Attachment", part)
    att.Name = "TempBH_Att"
    return { Part = part, Attachment = att, AssignedParts = {}, ToolRef = nil, OwnerId = nil }
end

-- Attach ALL baseparts of a model to a given BH attachment (used for click temp BH)
local function attachAllPartsToAttachment(model, bhAttachment, storage)
    if not model or not bhAttachment then return end
    storage = storage or { parts = {}, attachments = {}, aligns = {}, orients = {} }

    for _, v in ipairs(model:GetDescendants()) do
        if v:IsA("BasePart") and not isPartPlayerCharacter(v) then
            pcall(function() v.CanCollide = false end)
            pcall(function() v.Massless = true end)
            stripBodyForces(v)

            local attPart = Instance.new("Attachment")
            attPart.Name = "TempBH_Att_Part"
            attPart.Parent = v
            pcall(function() attPart.WorldCFrame = v.CFrame end)
            table.insert(storage.attachments, attPart)
            table.insert(storage.parts, v)

            local ap = Instance.new("AlignPosition")
            ap.Name = "TempBH_Align"
            ap.Attachment0 = attPart
            ap.Attachment1 = bhAttachment
            ap.MaxForce = BH_PULL_FORCE
            ap.MaxVelocity = math.huge
            ap.Responsiveness = 1500
            ap.Parent = v
            table.insert(storage.aligns, ap)

            local ao = Instance.new("AlignOrientation")
            ao.Name = "TempBH_AlignOri"
            ao.Attachment0 = attPart
            ao.Attachment1 = bhAttachment
            ao.MaxTorque = 9e9
            ao.Responsiveness = 1500
            ao.Parent = v
            table.insert(storage.orients, ao)

            local ok, Torque = pcall(function() return Instance.new("Torque") end)
            if ok and Torque then
                local tAtt = Instance.new("Attachment", v)
                tAtt.Name = "TempBH_Torque_Att"
                Torque.Attachment0 = tAtt
                Torque.Parent = v
                Torque.Torque = BH_TORQUE
            else
                pcall(function() v.AssemblyAngularVelocity = Vector3.new(0,40,0) end)
            end
        end
    end

    return storage
end

-- Cleanup storage: reassign aligns to persistent BH (Attachment1 -> BH_Attachment)
local function cleanupTempStorageToPersistentBH(storage)
    if not storage then return end
    for _, ap in ipairs(storage.aligns or {}) do
        pcall(function()
            if ap and ap.Parent then
                ap.Attachment1 = BH_Attachment
            end
        end)
    end
    for _, a in ipairs(storage.attachments or {}) do pcall(function() if a and a.Parent then a:Destroy() end end) end
    for _, ao in ipairs(storage.orients or {}) do pcall(function() if ao and ao.Parent then ao:Destroy() end end) end
end

local function startHPToggleLoop(humanoid, smallHP, interval, duration)
    if not humanoid then return end
    spawn(function()
        local elapsed = 0
        local state = true
        while elapsed < duration do
            pcall(function()
                if humanoid and humanoid.Parent then
                    if state then humanoid.Health = 0 else humanoid.Health = smallHP end
                end
            end)
            state = not state
            wait(interval)
            elapsed = elapsed + interval
        end
    end)
end

-- click-instant kill: attach NPC's parts to the tempBH's attachment
local function clickBHInstantKillAt(tempBH)
    if not tempBH or not tempBH.Part then return end
    local pos = tempBH.Part.Position
    local radius = 8
    -- robustly scan Workspace for humanoids (nested models)
    for _, obj in ipairs(Workspace:GetDescendants()) do
        if obj:IsA("Model") and obj:FindFirstChildOfClass("Humanoid") and not Players:GetPlayerFromCharacter(obj) then
            local m = obj
            local hum = m:FindFirstChildOfClass("Humanoid")
            local hrp = m:FindFirstChild("HumanoidRootPart") or m:FindFirstChild("UpperTorso") or m:FindFirstChild("Torso")
            if hum and hrp and (hrp.Position - pos).Magnitude <= radius then
                -- immediate kill
                pcall(function() hum.Health = 0 end)
                -- attach all parts of that NPC to the click-temp BH (so they go to click pos)
                local storage = attachAllPartsToAttachment(m, tempBH.Attachment, {})
                for _, part in ipairs(storage.parts or {}) do
                    table.insert(tempBH.AssignedParts, part)
                    -- track as processedParts so persistent BH bookkeeping knows they are taken
                    if not processedParts[part] then
                        processedParts[part] = true
                        if initiallyAnchoredParts[part] == nil then initiallyAnchoredParts[part] = part.Anchored end
                        if initiallyMasslessParts[part] == nil then pcall(function() initiallyMasslessParts[part] = part.Massless end) end
                    end
                end
                startHPToggleLoop(hum, 0.0001, CLICK_KILL_HP_TOGGLE_PERIOD, CLICK_KILL_TOGGLE_DURATION)
            end
        end
    end
end

-- return temp BH back to center and assign its parts to persistent BH (if desired)
local function returnTempBHToCenter(tempBH, returnDelay)
    spawn(function()
        wait(returnDelay or TEMP_BH_LIFETIME)
        if not tempBH or not tempBH.Part then return end
        local targetPos = centerPart.Position
        local t = 0
        local dur = 0.25
        local startPos = tempBH.Part.Position
        while t < dur do
            local alpha = t/dur
            tempBH.Part.Position = startPos:Lerp(targetPos, alpha)
            if tempBH.Attachment then tempBH.Attachment.WorldPosition = tempBH.Part.Position end
            RunService.Heartbeat:Wait()
            t = t + RunService.Heartbeat:Wait()
        end
        tempBH.Part.Position = targetPos
        if tempBH.Attachment then tempBH.Attachment.WorldPosition = targetPos end

        -- reassign assigned parts back to persistent BH Attachment
        for _, p in ipairs(tempBH.AssignedParts) do
            if p and p.Parent then
                local ap = p:FindFirstChildWhichIsA("AlignPosition")
                if ap then
                    pcall(function() ap.Attachment1 = BH_Attachment end) -- move to persistent BH
                    p.CanCollide = false
                end
            end
        end

        -- release the handle owner for this click event
        if tempBH.ToolRef and tempBH.OwnerId then
            pcall(function() removeHandleOwner(tempBH.ToolRef, tempBH.OwnerId) end)
        end

        wait(0.35)
        if tempBH and tempBH.Part and tempBH.Part.Parent then pcall(function() tempBH.Part:Destroy() end) end
    end)
end

-- ======================
-- Black Hole Tool wiring (clicks & singularity)
-- ======================
local function createBlackHoleTool()
    local bp = localPlayer:FindFirstChildOfClass("Backpack")
    if not bp then return nil end
    local existing = bp:FindFirstChild(BLACKHOLE_TOOL_NAME) or (localPlayer.Character and localPlayer.Character:FindFirstChild(BLACKHOLE_TOOL_NAME))
    if existing and existing:IsA("Tool") then return existing end
    local tool = Instance.new("Tool")
    tool.Name = BLACKHOLE_TOOL_NAME
    tool.RequiresHandle = false
    tool.CanBeDropped = false
    tool.Parent = bp
    return tool
end

-- Instant attach singularity: instantly grab every NPC model within radius and attach ALL parts to persistent BH
local function singularityInstantAttachAll(tool)
    local bhPos = centerPart.Position
    -- register singularity handle owner
    if tool then addHandleOwner(tool, "singularity") end
    -- auto-clear after lifetime to avoid dangling handle
    spawn(function() wait(SINGULARITY_HANDLE_LIFETIME); if tool then removeHandleOwner(tool, "singularity") end end)

    local processedModels = {}
    local pulledHumanoids = {}

    for _, hum in ipairs(Workspace:GetDescendants()) do
        if hum:IsA("Humanoid") then
            local model = hum.Parent
            if model and not Players:GetPlayerFromCharacter(model) and not processedModels[model] then
                processedModels[model] = true
                local hrp = model:FindFirstChild("HumanoidRootPart") or model:FindFirstChild("UpperTorso") or model:FindFirstChild("Torso")
                local centerPos = hrp and hrp.Position or (model:GetModelCFrame() and model:GetModelCFrame().p) or nil
                if centerPos and (centerPos - bhPos).Magnitude <= SINGULARITY_RADIUS then
                    -- mark death conn to cleanup
                    pulledHumanoids[hum] = hum.Died:Connect(function()
                        pulledHumanoids[hum]:Disconnect()
                        pulledHumanoids[hum] = nil
                        -- remove singularity owner if none left (we rely on owner lifetime cleanup too)
                        if tool then removeHandleOwner(tool, "singularity") end
                    end)

                    -- immediately attach ALL parts to persistent BH (they will visually be at persistent BH)
                    local storage = attachAllPartsToAttachment(model, BH_Attachment.Parent, {}) -- we want attachments on the persistent center, but attachAllPartsToAttachment expects an Attachment â€“ we'll attach to BH_Attachment directly
                    -- NOTE: we manually fix AlignAttachment1 below since we gave the anchor as the center part
                    -- But to keep function usage consistent, we'll instead create aligns directly to BH_Attachment:
                    for _, part in ipairs(storage.parts or {}) do
                        -- create attachment on part (we may already have att created by attachAllPartsToAttachment; ensure AlignPosition uses BH_Attachment)
                        local ap = part:FindFirstChildWhichIsA("AlignPosition")
                        if ap then
                            pcall(function() ap.Attachment1 = BH_Attachment end)
                        else
                            -- fallback: create ap linking part->BH_Attachment
                            local attPart = part:FindFirstChildWhichIsA("Attachment") or Instance.new("Attachment", part)
                            local ap2 = Instance.new("AlignPosition")
                            ap2.Attachment0 = attPart
                            ap2.Attachment1 = BH_Attachment
                            ap2.MaxForce = BH_PULL_FORCE
                            ap2.MaxVelocity = math.huge
                            ap2.Responsiveness = 1500
                            ap2.Parent = part
                        end
                        -- track part as processed by persistent BH
                        if not processedParts[part] then
                            processedParts[part] = true
                            if initiallyAnchoredParts[part] == nil then initiallyAnchoredParts[part] = part.Anchored end
                            if initiallyMasslessParts[part] == nil then pcall(function() initiallyMasslessParts[part] = part.Massless end) end
                        end
                    end

                    pcall(function() hum.Health = 0 end)
                    startHPToggleLoop(hum, 0.0001, SINGULARITY_HIT_TOGGLE_PERIOD, SINGULARITY_HIT_TOGGLE_DURATION)
                end
            end
        end
    end
end

-- wire black hole tool events (mouse + touch)
local function wireBlackHoleTool(tool)
    if not tool or not tool:IsA("Tool") then return end
    local equippedConns = {}

    tool.Equipped:Connect(function(mouse)
        if not mouse then mouse = localPlayer:GetMouse() end

        -- create singularity GUI (left side button)
        local playerGui = localPlayer:FindFirstChildOfClass("PlayerGui") or localPlayer:WaitForChild("PlayerGui")
        local existingGui = playerGui:FindFirstChild("BH_Singularity_GUI")
        local screenGui, singBtn
        if existingGui then screenGui = existingGui; singBtn = existingGui:FindFirstChild("SingularityBtn")
        else
            screenGui = Instance.new("ScreenGui"); screenGui.Name = "BH_Singularity_GUI"; screenGui.ResetOnSpawn = false; screenGui.Parent = playerGui
            singBtn = Instance.new("TextButton", screenGui)
            singBtn.Name = "SingularityBtn"
            if UserInputService.TouchEnabled then singBtn.Size = UDim2.new(0,110,0,34); singBtn.Position = UDim2.new(0,8,0,70); singBtn.TextSize = 18
            else singBtn.Size = UDim2.new(0,140,0,40); singBtn.Position = UDim2.new(0,8,0,100); singBtn.TextSize = 20 end
            singBtn.Text = "Singularity"; singBtn.Font = Enum.Font.SourceSansBold; singBtn.BackgroundColor3 = Color3.fromRGB(40,40,40)
            singBtn.TextColor3 = Color3.new(1,1,1); singBtn.BorderSizePixel = 0; singBtn.AutoButtonColor = true
        end

        -- singularity button fires instant pickup
        singBtn.MouseButton1Click:Connect(function()
            pcall(function() singularityInstantAttachAll(tool) end)
        end)

        -- click-placement: when local player clicks, create temp BH at that world position,
        -- attach only clicked NPCs (and assign nearby processedParts) to the temp BH, WITHOUT stomping other handles.
        local function handlePlacementAt(worldPos, clickedInstance)
            if not worldPos then return end
            local snapPL, plHRP = findPlayerNearPosition(worldPos, SNAP_RADIUS)
            local snapNPCModel, snapNPCHR = findNPCNearPosition(worldPos, SNAP_RADIUS)
            local placePos = worldPos
            if snapPL and plHRP then placePos = plHRP.Position
            elseif snapNPCModel and snapNPCHR then placePos = snapNPCHR.Position end

            local tempBH = createTemporaryBH(placePos)
            tempBH.ToolRef = tool
            tempBH.OwnerId = ("click_%f"):format(tick()) -- unique owner id
            -- register handle owner for this click: will not remove other owners
            addHandleOwner(tool, tempBH.OwnerId)

            -- instantly kill & attach nearby clicked NPCs to tempBH (they will move to click pos)
            spawn(function() clickBHInstantKillAt(tempBH) end)

            -- reassign any persistent-processed world parts in an area to tempBH for visuals (optional)
            spawn(function()
                local radius = 80
                for part, _ in pairs(processedParts) do
                    if part and part.Parent and (part.Position - placePos).Magnitude <= radius then
                        local ap = part:FindFirstChildWhichIsA("AlignPosition")
                        if ap and tempBH and tempBH.Attachment then
                            pcall(function() ap.Attachment1 = tempBH.Attachment end)
                            table.insert(tempBH.AssignedParts, part)
                        end
                    end
                end
            end)

            -- schedule return to center (and on return, release click owner and reassign assigned parts to persistent BH)
            returnTempBHToCenter(tempBH, TEMP_BH_LIFETIME)
        end

        -- mouse click
        local mouseConn = mouse.Button1Down:Connect(function()
            local hitPos = mouse.Hit and mouse.Hit.p
            if hitPos then handlePlacementAt(hitPos, mouse.Target) end
        end)

        -- improved touch detection (tap release, ignore joystick)
        local touchState = {}
        local touchBeganConn = UserInputService.InputBegan:Connect(function(input, processed)
            if processed then return end
            if input.UserInputType == Enum.UserInputType.Touch then
                local vs = Camera and Camera.ViewportSize or Vector2.new(1920,1080)
                local joystickIgnoreSize = 220
                if input.Position.X <= joystickIgnoreSize and input.Position.Y >= (vs.Y - joystickIgnoreSize) then
                    touchState[input] = nil
                    return
                end
                touchState[input] = { pos = input.Position, time = tick(), lastPos = input.Position, moved = 0 }
            end
        end)
        local touchChangedConn = UserInputService.InputChanged:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.Touch and touchState[input] then
                touchState[input].lastPos = input.Position
                touchState[input].moved = (input.Position - touchState[input].pos).Magnitude
            end
        end)
        local touchEndedConn = UserInputService.InputEnded:Connect(function(input, processed)
            if input.UserInputType == Enum.UserInputType.Touch and touchState[input] then
                local data = touchState[input]
                local duration = tick() - data.time
                local moved = data.moved or 0
                if duration < 0.35 and moved < 24 and not processed then
                    local worldPos, instance = screenPosToWorldPosition(input.Position)
                    handlePlacementAt(worldPos, instance)
                end
                touchState[input] = nil
            end
        end)

        equippedConns.mouseConn = mouseConn
        equippedConns.touchBeganConn = touchBeganConn
        equippedConns.touchChangedConn = touchChangedConn
        equippedConns.touchEndedConn = touchEndedConn

        -- on unequip: disconnect and clear handle owners created by click actions
        tool.Unequipped:Connect(function()
            if equippedConns.mouseConn then equippedConns.mouseConn:Disconnect(); equippedConns.mouseConn = nil end
            if equippedConns.touchBeganConn then equippedConns.touchBeganConn:Disconnect(); equippedConns.touchBeganConn = nil end
            if equippedConns.touchChangedConn then equippedConns.touchChangedConn:Disconnect(); equippedConns.touchChangedConn = nil end
            if equippedConns.touchEndedConn then equippedConns.touchEndedConn:Disconnect(); equippedConns.touchEndedConn = nil end
            -- remove any click owners (best-effort cleanup)
            local owners = toolHandleOwners[tool]
            if owners then
                for id,_ in pairs(owners) do
                    if tostring(id):match("^click_") then pcall(function() removeHandleOwner(tool, id) end) end
                end
            end
        end)
    end)

    tool.Unequipped:Connect(function()
        -- gui cleanup
        local playerGui = localPlayer:FindFirstChildOfClass("PlayerGui")
        if playerGui then
            local g = playerGui:FindFirstChild("BH_Singularity_GUI")
            if g then pcall(function() g:Destroy() end) end
        end
        -- clear all owners safely when tool fully unequipped/destroyed
        clearAllHandleOwners(tool)
    end)
end

-- ======================
-- Refresh / BH toggle GUI
-- ======================
local function setupRefreshAndBHToggleGUI()
    local playerGui = localPlayer:FindFirstChildOfClass("PlayerGui") or localPlayer:WaitForChild("PlayerGui")
    if playerGui:FindFirstChild("Toolpack_Refresh_GUI") then return end

    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "Toolpack_Refresh_GUI"
    screenGui.ResetOnSpawn = false
    screenGui.Parent = playerGui

    local refreshBtn = Instance.new("TextButton", screenGui)
    refreshBtn.Name = "RefreshToolpackBtn"
    if UserInputService.TouchEnabled then
        refreshBtn.Size = UDim2.new(0,150,0,34); refreshBtn.Position = UDim2.new(1, -160, 0, 70); refreshBtn.TextSize = 16
    else
        refreshBtn.Size = UDim2.new(0,200,0,40); refreshBtn.Position = UDim2.new(1, -210, 0, 100); refreshBtn.TextSize = 18
    end
    refreshBtn.Text = "refresh/receive toolpack"; refreshBtn.Font = Enum.Font.SourceSansBold
    refreshBtn.BackgroundColor3 = Color3.fromRGB(40,40,40); refreshBtn.TextColor3 = Color3.new(1,1,1); refreshBtn.BorderSizePixel = 0

    refreshBtn.MouseButton1Click:Connect(function()
        local bp = localPlayer:FindFirstChildOfClass("Backpack")
        local char = localPlayer.Character
        for _, container in ipairs({bp, char}) do
            if container then
                for _, name in ipairs({DEVOUR_NAME, BLACKHOLE_TOOL_NAME}) do
                    local t = container:FindFirstChild(name)
                    if t and t:IsA("Tool") then pcall(function() t:Destroy() end) end
                end
            end
        end
        wait(0.05)
        -- recreate/wire
        local bp2 = localPlayer:FindFirstChildOfClass("Backpack")
        if bp2 then
            local devTool = bp2:FindFirstChild(DEVOUR_NAME) or Instance.new("Tool", bp2); devTool.Name = DEVOUR_NAME; devTool.RequiresHandle = false; devTool.CanBeDropped = false
            wireDevourTool(devTool)
            local bhTool = bp2:FindFirstChild(BLACKHOLE_TOOL_NAME) or Instance.new("Tool", bp2); bhTool.Name = BLACKHOLE_TOOL_NAME; bhTool.RequiresHandle = false; bhTool.CanBeDropped = false
            wireBlackHoleTool(bhTool)
            spawn(function() wait(0.12); local char2 = localPlayer.Character; if char2 then local hum = char2:FindFirstChildOfClass("Humanoid"); if hum and bhTool.Parent == localPlayer:FindFirstChildOfClass("Backpack") then pcall(function() hum:EquipTool(bhTool) end) end end end)
        end
    end)

    local toggleBtn = Instance.new("TextButton", screenGui)
    toggleBtn.Name = "BHToggleBtn"
    if UserInputService.TouchEnabled then toggleBtn.Size = UDim2.new(0,100,0,34); toggleBtn.Position = UDim2.new(1, -160, 0, 110); toggleBtn.TextSize = 16
    else toggleBtn.Size = UDim2.new(0,120,0,34); toggleBtn.Position = UDim2.new(1, -210, 0, 150); toggleBtn.TextSize = 16 end
    toggleBtn.Text = persistentBHEnabled and "BH: On" or "BH: Off"
    toggleBtn.Font = Enum.Font.SourceSansBold; toggleBtn.BackgroundColor3 = Color3.fromRGB(50,50,50); toggleBtn.TextColor3 = Color3.new(1,1,1); toggleBtn.BorderSizePixel = 0

    toggleBtn.MouseButton1Click:Connect(function()
        if persistentBHEnabled then
            disablePersistentBH()
            toggleBtn.Text = "BH: Off"
        else
            enablePersistentBH()
            toggleBtn.Text = "BH: On"
        end
    end)
end

-- ======================
-- Tool creation + ensure on respawn
-- ======================
local function createAndWireTools()
    local bp = localPlayer:FindFirstChildOfClass("Backpack")
    if not bp then return end
    local devTool = bp:FindFirstChild(DEVOUR_NAME) or Instance.new("Tool", bp); devTool.Name = DEVOUR_NAME; devTool.RequiresHandle = false; devTool.CanBeDropped = false
    wireDevourTool(devTool)
    local bhTool = bp:FindFirstChild(BLACKHOLE_TOOL_NAME) or Instance.new("Tool", bp); bhTool.Name = BLACKHOLE_TOOL_NAME; bhTool.RequiresHandle = false; bhTool.CanBeDropped = false
    wireBlackHoleTool(bhTool)
    spawn(function() wait(0.12); local char = localPlayer.Character; if char then local hum = char:FindFirstChildOfClass("Humanoid"); if hum and bhTool.Parent == localPlayer:FindFirstChildOfClass("Backpack") then pcall(function() hum:EquipTool(bhTool) end) end end end)
end

local function ensureToolsOnRespawn()
    local function checkAndGive()
        local bp = localPlayer:FindFirstChildOfClass("Backpack")
        if not bp then return end
        if not bp:FindFirstChild(DEVOUR_NAME) then createAndWireTools() end
        if not bp:FindFirstChild(BLACKHOLE_TOOL_NAME) then createAndWireTools() end
    end
    checkAndGive()
    localPlayer.CharacterAdded:Connect(function() wait(0.1); checkAndGive() end)
end

-- ======================
-- Start
-- ======================
initialScanAndForce()
createAndWireTools()
setupRefreshAndBHToggleGUI()
ensureToolsOnRespawn()

print("Devour Soul + Black Hole (multi-handle safe, click-temp BH, BH toggle) loaded for", localPlayer.Name)
