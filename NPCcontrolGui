-- NPC Control GUI (Full) -- Place in StarterGui as a LocalScript

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")

local player = Players.LocalPlayer
local PlayerGui = player:WaitForChild("PlayerGui")

-- CONFIG
local VOID_Y = -500               -- change if your game's void is at another Y
local LOOP_DELAY = 0.6           -- delay between loop iterations (seconds)
local GUI_WIDTH = 260

-- Create ScreenGui
local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Name = "NPCControlGUI"
ScreenGui.ResetOnSpawn = false
ScreenGui.IgnoreGuiInset = true
ScreenGui.Parent = PlayerGui

-- Main container
local MainFrame = Instance.new("Frame")
MainFrame.Name = "MainFrame"
MainFrame.Size = UDim2.new(0, GUI_WIDTH, 0, 34)
MainFrame.Position = UDim2.new(1, -GUI_WIDTH - 10, 0, 60)
MainFrame.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
MainFrame.BorderSizePixel = 0
MainFrame.ClipsDescendants = true
MainFrame.Parent = ScreenGui

-- Top toggle button
local ToggleButton = Instance.new("TextButton")
ToggleButton.Size = UDim2.new(1, 0, 0, 34)
ToggleButton.BackgroundColor3 = Color3.fromRGB(44,44,44)
ToggleButton.BorderSizePixel = 0
ToggleButton.Font = Enum.Font.GothamBold
ToggleButton.TextSize = 15
ToggleButton.TextColor3 = Color3.new(1,1,1)
ToggleButton.Text = "â˜° NPC Controls"
ToggleButton.Parent = MainFrame

-- Options area
local Options = Instance.new("Frame")
Options.Size = UDim2.new(1, 0, 0, 360)
Options.Position = UDim2.new(0, 0, 0, 34)
Options.BackgroundColor3 = Color3.fromRGB(32,32,32)
Options.BorderSizePixel = 0
Options.Parent = MainFrame
Options.Visible = false

-- Simple layout helper
local function makeRow(y)
	local row = Instance.new("Frame")
	row.Size = UDim2.new(1, -12, 0, 34)
	row.Position = UDim2.new(0, 6, 0, y)
	row.BackgroundTransparency = 1
	row.Parent = Options
	return row
end

local function makeActionButton(parent, text)
	local btn = Instance.new("TextButton")
	btn.Size = UDim2.new(0.78, 0, 1, 0)
	btn.Position = UDim2.new(0, 0, 0, 0)
	btn.BackgroundColor3 = Color3.fromRGB(58,58,58)
	btn.BorderSizePixel = 0
	btn.Font = Enum.Font.Gotham
	btn.TextSize = 14
	btn.TextColor3 = Color3.new(1,1,1)
	btn.Text = text
	btn.Parent = parent
	return btn
end

local function makeSmallToggle(parent)
	local tog = Instance.new("TextButton")
	tog.Size = UDim2.new(0.18, 0, 1, 0)
	tog.Position = UDim2.new(0.82, 6, 0, 0)
	tog.BackgroundColor3 = Color3.fromRGB(40,40,40)
	tog.BorderSizePixel = 0
	tog.Font = Enum.Font.Gotham
	tog.TextSize = 12
	tog.TextColor3 = Color3.new(1,1,1)
	tog.Text = "Loop: Off"
	tog.Parent = parent
	return tog
end

local y = 6
-- Rows & controls
local killRow = makeRow(y); y = y + 40
local KillBtn = makeActionButton(killRow, "Kill NPCs")
local KillLoop = makeSmallToggle(killRow)

local infRow = makeRow(y); y = y + 40
local InfBtn = makeActionButton(infRow, "Give NPCs Infinite HP")
local InfLoop = makeSmallToggle(infRow)

local psRow = makeRow(y); y = y + 40
local PSBtn = makeActionButton(psRow, "Enable PlatformStand (all NPCs)")
local PSLoop = makeSmallToggle(psRow)

local sitRow = makeRow(y); y = y + 40
local SitBtn = makeActionButton(sitRow, "Make NPCs Sit")
local SitLoop = makeSmallToggle(sitRow)

local anchorRow = makeRow(y); y = y + 40
local AnchorBtn = makeActionButton(anchorRow, "Toggle Anchor (all parts)")
local AnchorLoop = makeSmallToggle(anchorRow)

local flingRow = makeRow(y); y = y + 40
local FlingBox = Instance.new("TextBox")
FlingBox.Size = UDim2.new(0.7, 0, 1, 0)
FlingBox.Position = UDim2.new(0, 0, 0, 0)
FlingBox.PlaceholderText = "Fling strength (e.g. 6000)"
FlingBox.BackgroundColor3 = Color3.fromRGB(50,50,50)
FlingBox.TextColor3 = Color3.new(1,1,1)
FlingBox.Text = ""
FlingBox.BorderSizePixel = 0
FlingBox.Font = Enum.Font.Gotham
FlingBox.TextSize = 14
FlingBox.Parent = flingRow

local FlingBtn = Instance.new("TextButton")
FlingBtn.Size = UDim2.new(0.3, -6, 1, 0)
FlingBtn.Position = UDim2.new(0.7, 6, 0, 0)
FlingBtn.BackgroundColor3 = Color3.fromRGB(100,50,50)
FlingBtn.Text = "Fling"
FlingBtn.Font = Enum.Font.Gotham
FlingBtn.TextSize = 14
FlingBtn.TextColor3 = Color3.new(1,1,1)
FlingBtn.BorderSizePixel = 0
FlingBtn.Parent = flingRow

local FlingLoopToggle = makeSmallToggle(flingRow)
FlingLoopToggle.Position = UDim2.new(0.7, 70, 0, 0) -- move so not overlap with fling btn

local voidRow = makeRow(y); y = y + 40
local VoidBtn = makeActionButton(voidRow, "Void NPCs (safe drop)")
local VoidLoop = makeSmallToggle(voidRow)

-- helpers for loop state
local loops = {
	kill = false,
	inf = false,
	ps = false,
	sit = false,
	anchor = false,
	fling = false,
	void = false,
}
local loopRunners = {} -- store coroutines

-- NPC detection: any model in workspace that is not a player character and has a Humanoid or at least one BasePart
local function getNPCs()
	local npcs = {}
	for _, obj in ipairs(workspace:GetDescendants()) do
		if obj:IsA("Model") then
			if Players:GetPlayerFromCharacter(obj) == nil then
				-- check for humanoid or baseparts / hrp
				local hasHum = obj:FindFirstChildOfClass("Humanoid") ~= nil
				local hasHRP = obj:FindFirstChild("HumanoidRootPart") ~= nil
				local hasAnyPart = false
				for _, d in ipairs(obj:GetDescendants()) do
					if d:IsA("BasePart") then
						hasAnyPart = true
						break
					end
				end
				if hasHum or hasHRP or hasAnyPart then
					table.insert(npcs, obj)
				end
			end
		end
	end
	return npcs
end

-- Utility: safely iterate npc baseparts
local function iterateBaseParts(npc, fn)
	for _, part in ipairs(npc:GetDescendants()) do
		if part:IsA("BasePart") then
			pcall(function() fn(part) end)
		end
	end
end

-- ACTIONS
local function killNPC(npc)
	local hum = npc:FindFirstChildOfClass("Humanoid")
	if hum then
		pcall(function() hum.Health = -math.huge end)
	else
		-- fallback: destroy baseparts to "kill" impossible NPCs
		iterateBaseParts(npc, function(p) p:Destroy() end)
	end
end

local function giveInfHP(npc)
	local hum = npc:FindFirstChildOfClass("Humanoid")
	if hum then
		pcall(function()
			hum.MaxHealth = math.huge
			hum.Health = math.huge
		end)
	end
end

local function enablePlatformStand(npc)
	local hum = npc:FindFirstChildOfClass("Humanoid")
	if hum then
		pcall(function() hum.PlatformStand = true end)
	end
end

local function makeSit(npc)
	local hum = npc:FindFirstChildOfClass("Humanoid")
	if hum then
		pcall(function() hum.Sit = true end)
	end
end

local function toggleAnchor(npc, anchorState)
	iterateBaseParts(npc, function(p)
		p.Anchored = anchorState
	end)
end

local function flingNPC(npc, strength)
	iterateBaseParts(npc, function(p)
		-- apply velocity; preserve existing velocities by adding
		if p and p:IsA("BasePart") then
			p.Velocity = Vector3.new(
				math.random(-1000,1000),
				math.random(0,800) + strength,
				math.random(-1000,1000)
			)
		end
	end)
end

-- SAFE VOID TELEPORT:
-- Computes the model's lowest bottom Y across all BaseParts (bottom = centerY - sizeY/2),
-- then shifts the whole model up so that the new lowest bottom is exactly (VOID_Y + 3).
-- This guarantees none of the parts get placed in the void on teleport.
local function safeVoidTeleport(npc, voidY)
	local parts = {}
	for _, p in ipairs(npc:GetDescendants()) do
		if p:IsA("BasePart") then table.insert(parts, p) end
	end
	if #parts == 0 then return end

	local minBottom = math.huge
	local maxTop = -math.huge
	for _, p in ipairs(parts) do
		local bottom = p.Position.Y - (p.Size.Y/2)
		local top = p.Position.Y + (p.Size.Y/2)
		if bottom < minBottom then minBottom = bottom end
		if top > maxTop then maxTop = top end
	end
	local height = maxTop - minBottom
	-- target bottom should be voidY + 3
	local targetBottom = voidY + 3
	local shift = targetBottom - minBottom

	-- move all parts by shift (preserve relative offsets)
	for _, p in ipairs(parts) do
		-- some parts may be welded/managed; we'll attempt to set CFrame in pcall
		pcall(function()
			p.CFrame = p.CFrame + Vector3.new(0, shift, 0)
		end)
	end
end

-- UI LOOP RUNNER helper
local function startLoop(key, actionFunc)
	if loopRunners[key] then return end -- already running
	loops[key] = true
	local co = coroutine.create(function()
		while loops[key] do
			pcall(function()
				for _, npc in ipairs(getNPCs()) do
					actionFunc(npc)
				end
			end)
			task.wait(LOOP_DELAY)
		end
		loopRunners[key] = nil
	end)
	loopRunners[key] = co
	coroutine.resume(co)
end

local function stopLoop(key)
	loops[key] = false
	-- runner will clean up itself
end

-- connect button actions (single press)
KillBtn.MouseButton1Click:Connect(function()
	for _, npc in ipairs(getNPCs()) do killNPC(npc) end
end)
InfBtn.MouseButton1Click:Connect(function()
	for _, npc in ipairs(getNPCs()) do giveInfHP(npc) end
end)
PSBtn.MouseButton1Click:Connect(function()
	for _, npc in ipairs(getNPCs()) do enablePlatformStand(npc) end
end)
SitBtn.MouseButton1Click:Connect(function()
	for _, npc in ipairs(getNPCs()) do makeSit(npc) end
end)
AnchorBtn.MouseButton1Click:Connect(function()
	-- toggle anchor state per NPC (if any part unanchored -> anchor all; else unanchor all)
	for _, npc in ipairs(getNPCs()) do
		local anyUnanchored = false
		for _, p in ipairs(npc:GetDescendants()) do
			if p:IsA("BasePart") and not p.Anchored then
				anyUnanchored = true
				break
			end
		end
		toggleAnchor(npc, anyUnanchored) -- anchor if any unanchored, otherwise unanchor
	end
end)
FlingBtn.MouseButton1Click:Connect(function()
	local strength = tonumber(FlingBox.Text) or 6000
	for _, npc in ipairs(getNPCs()) do flingNPC(npc, strength) end
end)
VoidBtn.MouseButton1Click:Connect(function()
	for _, npc in ipairs(getNPCs()) do safeVoidTeleport(npc, VOID_Y) end
end)

-- connect small loop toggles (toggle on/off)
local function linkLoopToggle(button, key, action)
	button.MouseButton1Click:Connect(function()
		loops[key] = not loops[key]
		button.Text = "Loop: " .. (loops[key] and "On" or "Off")
		if loops[key] then
			startLoop(key, action)
		else
			stopLoop(key)
		end
	end)
end

linkLoopToggle(KillLoop, "kill", function(n) killNPC(n) end)
linkLoopToggle(InfLoop, "inf", function(n) giveInfHP(n) end)
linkLoopToggle(PSLoop, "ps", function(n) enablePlatformStand(n) end)
linkLoopToggle(SitLoop, "sit", function(n) makeSit(n) end)
linkLoopToggle(AnchorLoop, "anchor", function(n)
	-- maintain anchor state = true while loop on
	toggleAnchor(n, true)
end)
linkLoopToggle(FlingLoopToggle, "fling", function(n)
	local strength = tonumber(FlingBox.Text) or 6000
	flingNPC(n, strength)
end)
linkLoopToggle(VoidLoop, "void", function(n) safeVoidTeleport(n, VOID_Y) end)

-- GUI toggle animation
local open = false
ToggleButton.MouseButton1Click:Connect(function()
	open = not open
	local targetSize = open and UDim2.new(0, GUI_WIDTH, 0, 420) or UDim2.new(0, GUI_WIDTH, 0, 34)
	TweenService:Create(MainFrame, TweenInfo.new(0.22, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {Size = targetSize}):Play()
	task.wait(0.08)
	Options.Visible = open
end)

-- Keep loops alive across respawns: (ResetOnSpawn = false already set on ScreenGui)
player.CharacterAdded:Connect(function()
	-- no action; GUI will persist
end)

-- Safety: stop loops when script disabled/destroyed
script.AncestryChanged:Connect(function()
	if not script:IsDescendantOf(game) then
		for k,_ in pairs(loops) do loops[k] = false end
	end
end)

-- Done
print("[NPCControlGUI] loaded. Use the toggle to open controls.")
