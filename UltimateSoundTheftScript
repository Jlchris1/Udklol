-- Full LocalScript (place in StarterPlayerScripts)
-- Behavior:
-- • Event-driven detection (no repeated scanning of the same sounds)
-- • TextBox shows only the most-recently-started Sound's id (switches, not stack)
-- • Anti-lag ("/e antilag") freezes the textbox display, BUT:
--     — the detector still detects newly played sounds
--     — newly detected sounds are STILL added to History
-- • History entries are unique, include name + id, Copy button, and Play/Pause (solo)
-- • Solo mode mutes non-target sounds and mutes new sounds that start/create while solo active
-- • Toggle button is always visible next to the GUI
-- • Uses processedSounds to avoid double-checking already-seen Sound instances

local Players = game:GetService("Players")
local UIS = game:GetService("UserInputService")
local StarterGui = game:GetService("StarterGui")
local SoundService = game:GetService("SoundService")
local RunService = game:GetService("RunService")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

-----------------------------------------------------------
-- Helpers
-----------------------------------------------------------
local function formatId(str)
	if not str then return "" end
	local id = tostring(str):match("%d+")
	return id and ("rbxassetid://" .. id) or tostring(str)
end

local function notify(titleText, bodyText)
	pcall(function()
		StarterGui:SetCore("SendNotification", {
			Title = titleText;
			Text = bodyText;
			Duration = 2;
		})
	end)
end

-----------------------------------------------------------
-- GUI CREATION
-----------------------------------------------------------
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "SoundDetectorGui"
screenGui.ResetOnSpawn = false
screenGui.Parent = playerGui

-- MAIN FRAME
local frame = Instance.new("Frame")
frame.Name = "MainFrame"
frame.Size = UDim2.new(0, 420, 0, 150)
frame.Position = UDim2.new(0, 20, 0, 60)
frame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
frame.BorderSizePixel = 0
frame.Parent = screenGui

-- Title + Info
local title = Instance.new("TextLabel")
title.Size = UDim2.new(1, -36, 0, 24)
title.Position = UDim2.new(0, 6, 0, 6)
title.BackgroundTransparency = 1
title.Font = Enum.Font.SourceSansSemibold
title.TextColor3 = Color3.fromRGB(230,230,230)
title.TextSize = 18
title.Text = "Sound Detector"
title.TextXAlignment = Enum.TextXAlignment.Left
title.Parent = frame

local info = Instance.new("TextLabel")
info.Size = UDim2.new(1, -12, 0, 16)
info.Position = UDim2.new(0, 6, 0, 30)
info.BackgroundTransparency = 1
info.Font = Enum.Font.SourceSans
info.TextSize = 12
info.TextColor3 = Color3.fromRGB(200,200,200)
info.Text = "Detects currently playing audios & lets you copy them. Use History for past audios."
info.TextXAlignment = Enum.TextXAlignment.Left
info.Parent = frame

-- CURRENT DETECTED TEXTBOX
local textbox = Instance.new("TextBox")
textbox.Size = UDim2.new(1, -12, 0, 36)
textbox.Position = UDim2.new(0, 6, 0, 50)
textbox.BackgroundColor3 = Color3.fromRGB(240,240,240)
textbox.Font = Enum.Font.SourceSans
textbox.TextSize = 14
textbox.TextColor3 = Color3.fromRGB(0,0,0)
textbox.ClearTextOnFocus = false
textbox.PlaceholderText = "No sound detected"
textbox.Parent = frame

local copyButton = Instance.new("TextButton")
copyButton.Size = UDim2.new(0, 120, 0, 28)
copyButton.Position = UDim2.new(1, -126, 0, 94)
copyButton.Text = "Copy"
copyButton.Font = Enum.Font.SourceSansBold
copyButton.TextColor3 = Color3.new(1,1,1)
copyButton.BackgroundColor3 = Color3.fromRGB(60,120,200)
copyButton.Parent = frame

local countLabel = Instance.new("TextLabel")
countLabel.Size = UDim2.new(0, 180, 0, 28)
countLabel.Position = UDim2.new(0, 6, 0, 94)
countLabel.BackgroundTransparency = 1
countLabel.Text = "Detected: 0"
countLabel.TextColor3 = Color3.fromRGB(200,200,200)
countLabel.Font = Enum.Font.SourceSans
countLabel.TextSize = 14
countLabel.Parent = frame

-- HISTORY BUTTON
local historyButton = Instance.new("TextButton")
historyButton.Size = UDim2.new(0, 110, 0, 28)
historyButton.Position = UDim2.new(0, 6, 0, 122)
historyButton.Text = "History"
historyButton.TextColor3 = Color3.new(1,1,1)
historyButton.Font = Enum.Font.SourceSansBold
historyButton.BackgroundColor3 = Color3.fromRGB(70,70,70)
historyButton.Parent = frame

-- HISTORY PANEL
local historyFrame = Instance.new("Frame")
historyFrame.Size = UDim2.new(0, 330, 0, 260)
historyFrame.Position = UDim2.new(0, 450, 0, 60)
historyFrame.BackgroundColor3 = Color3.fromRGB(20,20,20)
historyFrame.BorderSizePixel = 0
historyFrame.Visible = false
historyFrame.Parent = screenGui

local historyList = Instance.new("ScrollingFrame")
historyList.Size = UDim2.new(1, -10, 1, -10)
historyList.Position = UDim2.new(0, 5, 0, 5)
historyList.CanvasSize = UDim2.new(0,0,0,0)
historyList.ScrollBarThickness = 6
historyList.BackgroundTransparency = 1
historyList.Parent = historyFrame

local layout = Instance.new("UIListLayout")
layout.Parent = historyList
layout.Padding = UDim.new(0, 6)

local history = {} -- map[id] = true to avoid duplicates (history IDs)
local historyButtons = {}

historyButton.MouseButton1Click:Connect(function()
	historyFrame.Visible = not historyFrame.Visible
end)

-- TOGGLE (always visible next to the frame)
local toggle = Instance.new("TextButton")
toggle.Size = UDim2.new(0, 26, 0, 26)
toggle.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
toggle.Text = "-"
toggle.TextColor3 = Color3.new(1,1,1)
toggle.Font = Enum.Font.SourceSansBold
toggle.TextSize = 18
toggle.ZIndex = 10
toggle.Parent = screenGui
toggle.Position = UDim2.new(0, frame.AbsolutePosition.X + frame.AbsoluteSize.X + 8,
                            0, frame.AbsolutePosition.Y)

local frameVisible = true
local function updateTogglePosition()
	local posX = frame.AbsolutePosition.X + frame.AbsoluteSize.X + 8
	local posY = frame.AbsolutePosition.Y
	if frameVisible then
		toggle.Text = "-"
		toggle.Position = UDim2.new(0, posX, 0, posY)
	else
		toggle.Text = "+"
	end
end

toggle.MouseButton1Click:Connect(function()
	frameVisible = not frameVisible
	frame.Visible = frameVisible
	updateTogglePosition()
end)

RunService.Heartbeat:Connect(function()
	-- keep toggle near frame (only when visible)
	if frame and toggle and frame.Visible then
		updateTogglePosition()
	end
	-- update count label from playingCount (keeps UI reactive without scanning)
	if countLabel and playingCount ~= nil then
		countLabel.Text = "Detected: " .. tostring(playingCount)
	end
end)

-----------------------------------------------------------
-- Clipboard helper (uses textbox fallback if needed)
-----------------------------------------------------------
local function copyToClipboard(text)
	if not text or text == "" then
		notify("Copy failed", "Nothing to copy.")
		return false
	end

	-- try global setclipboard
	if type(setclipboard) == "function" then
		local ok = pcall(setclipboard, text)
		if ok then
			notify("Copied", "Copied to clipboard.")
			return true
		end
	end

	-- try UserInputService:SetClipboard
	if UIS and type(UIS.SetClipboard) == "function" then
		local ok = pcall(function() UIS:SetClipboard(text) end)
		if ok then
			notify("Copied", "Copied to clipboard.")
			return true
		end
	end

	-- fallback: put into textbox and focus so user can Ctrl/Cmd+C
	textbox.Text = text
	textbox:CaptureFocus()
	notify("Manual copy", "Automatic copy unavailable. Text placed in box — press Ctrl/Cmd+C to copy.")
	return false
end

copyButton.MouseButton1Click:Connect(function()
	copyToClipboard(textbox.Text)
end)

-----------------------------------------------------------
-- SOLO / PLAY CONTROL
-- (unchanged from previous behavior; occasional scans here are fine)
-----------------------------------------------------------
local soloState = {
	activeId = nil,
	playerSound = nil,
	prevVolumes = {},      -- map [soundInstance] = previousVolume
	descAddedConn = nil,
	playChangedConns = {}, -- map [soundInstance] = conn
	activeEntryButton = nil,
}

local function safeSetVolume(sound, vol)
	pcall(function() sound.Volume = vol end)
end

local function storeAndMuteSound(s)
	if not s or not s:IsA("Sound") then return end
	if soloState.playerSound and s == soloState.playerSound then return end
	if not soloState.prevVolumes[s] then
		local ok, vol = pcall(function() return s.Volume end)
		soloState.prevVolumes[s] = ok and vol or 1
	end
	safeSetVolume(s, 0)
end

local function restoreAllVolumes()
	for s, vol in pairs(soloState.prevVolumes) do
		if s and s.Parent then
			pcall(function() s.Volume = vol end)
		end
	end
	soloState.prevVolumes = {}
end

local function stopSolo()
	if soloState.playerSound then
		pcall(function()
			soloState.playerSound:Stop()
			soloState.playerSound:Destroy()
		end)
		soloState.playerSound = nil
	end

	if soloState.descAddedConn then
		pcall(function() soloState.descAddedConn:Disconnect() end)
		soloState.descAddedConn = nil
	end

	for s, conn in pairs(soloState.playChangedConns) do
		pcall(function() conn:Disconnect() end)
	end
	soloState.playChangedConns = {}

	restoreAllVolumes()

	if soloState.activeEntryButton then
		pcall(function() soloState.activeEntryButton.Text = "▶️" end)
		soloState.activeEntryButton = nil
	end
	soloState.activeId = nil
end

local function startSolo(rbxAssetId, entryButton)
	if soloState.activeId == rbxAssetId then
		stopSolo()
		return
	end

	if soloState.activeId then
		stopSolo()
	end

	soloState.activeId = rbxAssetId
	soloState.activeEntryButton = entryButton
	if entryButton then
		pcall(function() entryButton.Text = "⏸️" end)
	end

	local localSound = Instance.new("Sound")
	localSound.Name = "SoundDetectorPlayer"
	localSound.SoundId = rbxAssetId
	localSound.Looped = true
	localSound.Volume = 1
	localSound.Parent = SoundService
	soloState.playerSound = localSound

	-- mute non-target sounds and store their original volumes
	for _, s in ipairs(game:GetDescendants()) do
		if s:IsA("Sound") then
			local formatted = formatId(s.SoundId)
			if formatted ~= rbxAssetId then
				storeAndMuteSound(s)
			else
				if not soloState.prevVolumes[s] then
					local ok, vol = pcall(function() return s.Volume end)
					soloState.prevVolumes[s] = ok and vol or 1
				end
			end
		end
	end

	pcall(function() localSound:Play() end)

	-- mute newly added sounds unless they match active id
	soloState.descAddedConn = game.DescendantAdded:Connect(function(desc)
		if not desc or not desc:IsA("Sound") then return end
		task.delay(0.05, function()
			local formatted = formatId(desc.SoundId)
			if formatted ~= soloState.activeId then
				storeAndMuteSound(desc)
			else
				if not soloState.prevVolumes[desc] then
					local ok, vol = pcall(function() return desc.Volume end)
					soloState.prevVolumes[desc] = ok and vol or 1
				end
			end
		end)
	end)

	-- connect Playing changed for existing sounds to quickly mute new starts
	for _, s in ipairs(game:GetDescendants()) do
		if s:IsA("Sound") then
			local conn = s:GetPropertyChangedSignal("Playing"):Connect(function()
				if soloState.activeId and s.Playing then
					local formatted = formatId(s.SoundId)
					if formatted ~= soloState.activeId then
						storeAndMuteSound(s)
					end
				end
			end)
			soloState.playChangedConns[s] = conn
		end
	end
end

-----------------------------------------------------------
-- HISTORY ENTRY CREATION (unique ids only)
-----------------------------------------------------------
local function addHistoryEntry(id, name)
	id = formatId(id)
	if history[id] then return end
	history[id] = true

	local entry = Instance.new("Frame")
	entry.Size = UDim2.new(1, -6, 0, 32)
	entry.BackgroundColor3 = Color3.fromRGB(40,40,40)
	entry.Parent = historyList

	-- Play/Pause button
	local playBtn = Instance.new("TextButton")
	playBtn.Size = UDim2.new(0, 28, 1, -4)
	playBtn.Position = UDim2.new(0, 4, 0, 2)
	playBtn.Text = "▶️"
	playBtn.Font = Enum.Font.SourceSansBold
	playBtn.TextSize = 18
	playBtn.BackgroundColor3 = Color3.fromRGB(70,100,160)
	playBtn.TextColor3 = Color3.new(1,1,1)
	playBtn.Parent = entry

	-- clickable label (copies on click)
	local labelBtn = Instance.new("TextButton")
	labelBtn.Size = UDim2.new(1, -150, 1, 0)
	labelBtn.Position = UDim2.new(0, 40, 0, 0)
	labelBtn.BackgroundTransparency = 1
	labelBtn.Font = Enum.Font.SourceSans
	labelBtn.TextSize = 14
	labelBtn.TextColor3 = Color3.new(1,1,1)
	labelBtn.AutoButtonColor = false
	labelBtn.TextXAlignment = Enum.TextXAlignment.Left
	labelBtn.Text = (name or "Unknown") .. "   |   " .. id
	labelBtn.Parent = entry

	local copyBtn = Instance.new("TextButton")
	copyBtn.Size = UDim2.new(0, 64, 1, -4)
	copyBtn.Position = UDim2.new(1, -68, 0, 2)
	copyBtn.Text = "Copy"
	copyBtn.Font = Enum.Font.SourceSansBold
	copyBtn.TextColor3 = Color3.new(1,1,1)
	copyBtn.BackgroundColor3 = Color3.fromRGB(70,100,160)
	copyBtn.Parent = entry

	local function onCopy()
		copyToClipboard(id)
	end
	copyBtn.MouseButton1Click:Connect(onCopy)
	labelBtn.MouseButton1Click:Connect(onCopy)

	playBtn.MouseButton1Click:Connect(function()
		if soloState.activeId == id then
			stopSolo()
		else
			if soloState.activeEntryButton and soloState.activeEntryButton ~= playBtn then
				pcall(function() soloState.activeEntryButton.Text = "▶️" end)
			end
			startSolo(id, playBtn)
		end
	end)

	historyButtons[id] = {
		frame = entry;
		playBtn = playBtn;
		copyBtn = copyBtn;
		labelBtn = labelBtn;
	}

	-- update canvas size after layout updates
	task.defer(function()
		historyList.CanvasSize = UDim2.new(0,0,0,layout.AbsoluteContentSize.Y)
	end)
end

-----------------------------------------------------------
-- RELIABLE, EVENT-DRIVEN SOUND DETECTION (no double-checking)
-- • processedSounds prevents reconnecting / reprocessing the same Sound instance
-- • playingCount maintained incrementally to avoid scanning the whole game
-- • lastPlayedTime used to choose the most-recently-started Sound
-- • antiLag freezes textbox updates but detection + history continue
-----------------------------------------------------------

local processedSounds = {}      -- map[soundInstance] = true (prevents double-processing)
local soundConns = {}           -- map [sound] = connection for Playing
local soundAncestryConns = {}   -- map [sound] = ancestry connection
local lastPlayedTime = {}       -- map [sound] = tick() when it started playing
local playingCount = 0          -- current number of playing sounds tracked
local antiLag = false           -- toggled via chat "/e antilag" (freezes textbox display)

local function cleanupSoundConnections(s)
	if soundConns[s] then
		pcall(function() soundConns[s]:Disconnect() end)
		soundConns[s] = nil
	end
	if soundAncestryConns[s] then
		pcall(function() soundAncestryConns[s]:Disconnect() end)
		soundAncestryConns[s] = nil
	end
	lastPlayedTime[s] = nil
	processedSounds[s] = nil
end

local function refreshCurrentDisplayed()
	-- choose the most recently started playing sound from lastPlayedTime
	local bestSound = nil
	local bestTime = -math.huge

	for s, startedAt in pairs(lastPlayedTime) do
		if s and s.Parent and s.Playing then
			local t = startedAt or tick()
			if t > bestTime then
				bestTime = t
				bestSound = s
			end
		end
	end

	-- Update textbox only if antiLag is false
	if bestSound then
		local id = formatId(bestSound.SoundId)
		if not antiLag then
			textbox.Text = id
		end
		-- count label uses playingCount (kept updated elsewhere)
		countLabel.Text = "Detected: " .. tostring(playingCount)
	else
		if not antiLag then
			textbox.Text = ""
			textbox.PlaceholderText = "No sound detected"
		end
		countLabel.Text = "Detected: " .. tostring(playingCount)
	end
end

local function onSoundPlayingChanged(s)
	local wasPlaying = lastPlayedTime[s] ~= nil
	if s.Playing then
		-- If this sound was not previously considered "playing", increment playingCount
		if not wasPlaying then
			playingCount = playingCount + 1
		end

		lastPlayedTime[s] = tick()

		-- always add to history even when antiLag is on (but only once, history guards duplicates)
		local id = formatId(s.SoundId)
		if id ~= "" and not history[id] then
			addHistoryEntry(id, s.Name or (s.Parent and s.Parent.Name) or "Unknown")
		end

		-- update textbox immediately only if antiLag is false
		if not antiLag then
			textbox.Text = id
		end

		-- if solo active and not the target, mute it
		if soloState.activeId and formatId(s.SoundId) ~= soloState.activeId then
			storeAndMuteSound(s)
		end
	else
		-- sound stopped playing
		if wasPlaying then
			playingCount = math.max(0, playingCount - 1)
		end
		lastPlayedTime[s] = nil

		-- refresh display only if antiLag is false (if frozen, keep the frozen id)
		if not antiLag then
			refreshCurrentDisplayed()
		else
			-- still update the count label even when frozen
			countLabel.Text = "Detected: " .. tostring(playingCount)
		end
	end
end

local function connectToSound(s)
	-- only process each Sound instance once
	if not s or not s:IsA("Sound") or processedSounds[s] then return end
	processedSounds[s] = true

	-- Playing property changed connection
	local conn = s:GetPropertyChangedSignal("Playing"):Connect(function()
		pcall(function() onSoundPlayingChanged(s) end)
	end)
	soundConns[s] = conn

	-- cleanup when removed from the world
	local ancConn = s.AncestryChanged:Connect(function(_, parent)
		if not parent then
			cleanupSoundConnections(s)
		end
	end)
	soundAncestryConns[s] = ancConn

	-- if it's already playing when we connect, treat it as started now
	if s.Playing then
		-- ensure we count it once
		if not lastPlayedTime[s] then
			playingCount = playingCount + 1
		end
		lastPlayedTime[s] = tick()

		local id = formatId(s.SoundId)
		if id ~= "" and not history[id] then
			addHistoryEntry(id, s.Name or (s.Parent and s.Parent.Name) or "Unknown")
		end

		-- if solo active and not the target, mute it
		if soloState.activeId and formatId(s.SoundId) ~= soloState.activeId then
			storeAndMuteSound(s)
		end

		-- update textbox only if not frozen
		if not antiLag then
			textbox.Text = formatId(s.SoundId)
		end
	end
end

-- Connect all existing Sounds (one-time loop at start; not repeated)
for _, s in ipairs(game:GetDescendants()) do
	if s:IsA("Sound") then
		connectToSound(s)
	end
end

-- Listen for new Sounds (event-based; processedSounds prevents re-processing)
local descAddedConn = game.DescendantAdded:Connect(function(desc)
	if desc:IsA("Sound") then
		-- tiny delay to allow creator to set SoundId etc.
		task.delay(0.03, function()
			connectToSound(desc)
			-- if playing on creation, handle it now
			if desc.Playing then
				pcall(function() onSoundPlayingChanged(desc) end)
			end
		end)
	end
end)

-- Clean up removed Sounds (redundant but safe)
local descRemovingConn = game.DescendantRemoving:Connect(function(desc)
	if desc:IsA("Sound") then
		cleanupSoundConnections(desc)
	end
end)

-----------------------------------------------------------
-- Anti-lag toggle via chat "/e antilag" or "antilag"
-- Freezes textbox updates but detection & history still run.
-----------------------------------------------------------
player.Chatted:Connect(function(msg)
	if not msg then return end
	local cleaned = msg:lower():gsub("%s+", " ")
	if cleaned:find("antilag") then
		antiLag = not antiLag
		if antiLag then
			notify("Anti-lag ON", "Textbox updates frozen. Detection & history still active.")
		else
			notify("Anti-lag OFF", "Textbox updates resumed.")
			-- refresh displayed current to latest when toggled off
			task.defer(function()
				task.wait(0.05)
				pcall(refreshCurrentDisplayed)
			end)
		end
	end
end)

-----------------------------------------------------------
-- COPY CURRENT TEXTBOX
-----------------------------------------------------------
copyButton.MouseButton1Click:Connect(function()
	copyToClipboard(textbox.Text)
end)

-----------------------------------------------------------
-- CLEANUP on player leaving
-----------------------------------------------------------
local function cleanupEverything()
	for s, conn in pairs(soundConns) do pcall(function() conn:Disconnect() end) end
	for s, conn in pairs(soundAncestryConns) do pcall(function() conn:Disconnect() end) end
	pcall(function() descAddedConn:Disconnect() end)
	pcall(function() descRemovingConn:Disconnect() end)
	stopSolo()
	pcall(function() screenGui:Destroy() end)
end

player.AncestryChanged:Connect(function(_, parent)
	if not parent then cleanupEverything() end
end)

-- ensure script references for safe checks
if script and typeof(script) == "Instance" then
	-- no-op, just keeping script in scope for environments that check it
end

-- done
