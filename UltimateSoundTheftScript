-- Full LocalScript (place in StarterPlayerScripts)

local Players = game:GetService("Players")
local UIS = game:GetService("UserInputService")
local StarterGui = game:GetService("StarterGui")
local SoundService = game:GetService("SoundService")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

-----------------------------------------------------------
-- GUI CREATION
-----------------------------------------------------------

local screenGui = Instance.new("ScreenGui")
screenGui.Name = "SoundDetectorGui"
screenGui.ResetOnSpawn = false
screenGui.Parent = playerGui

-----------------------------------------------------------
-- MAIN FRAME
-----------------------------------------------------------

local frame = Instance.new("Frame")
frame.Name = "MainFrame"
frame.Size = UDim2.new(0, 420, 0, 150)
frame.Position = UDim2.new(0, 20, 0, 60)
frame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
frame.BorderSizePixel = 0
frame.Parent = screenGui

-----------------------------------------------------------
-- DRAGGING
-----------------------------------------------------------

local dragging, dragStart, startPos

frame.InputBegan:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1 then
		dragging = true
		dragStart = input.Position
		startPos = frame.Position
		input.Changed:Connect(function()
			if input.UserInputState == Enum.UserInputState.End then
				dragging = false
			end
		end)
	end
end)

UIS.InputChanged:Connect(function(input)
	if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
		local delta = input.Position - dragStart
		frame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X,
			startPos.Y.Scale, startPos.Y.Offset + delta.Y)
	end
end)

-----------------------------------------------------------
-- HIDE/SHOW TOGGLE (ALWAYS VISIBLE)
-----------------------------------------------------------

local toggle = Instance.new("TextButton")
toggle.Size = UDim2.new(0, 26, 0, 26)
toggle.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
toggle.Text = "-"
toggle.TextColor3 = Color3.new(1,1,1)
toggle.Font = Enum.Font.SourceSansBold
toggle.TextSize = 18
toggle.ZIndex = 10 -- always on top
toggle.Parent = screenGui

-- initial position next to the main frame (pixel offset)
toggle.Position = UDim2.new(0, frame.AbsolutePosition.X + frame.AbsoluteSize.X + 8,
                            0, frame.AbsolutePosition.Y)

local frameVisible = true

local function updateTogglePosition()
	-- Keep toggle next to frame so it never disappears with the frame
	if frameVisible then
		toggle.Text = "-"
		toggle.Position = UDim2.new(0, frame.AbsolutePosition.X + frame.AbsoluteSize.X + 8,
		                            0, frame.AbsolutePosition.Y)
	else
		toggle.Text = "+"
		-- Keep it where it currently is (so user can reopen)
		toggle.Position = UDim2.new(0, toggle.Position.X.Offset, 0, toggle.Position.Y.Offset)
	end
end

toggle.MouseButton1Click:Connect(function()
	frameVisible = not frameVisible
	frame.Visible = frameVisible
	updateTogglePosition()
end)

-- update toggle position when frame is dragged or resized
frame:GetPropertyChangedSignal("Position"):Connect(updateTogglePosition)
frame:GetPropertyChangedSignal("Size"):Connect(updateTogglePosition)

-----------------------------------------------------------
-- TITLE + INFO TEXT
-----------------------------------------------------------

local title = Instance.new("TextLabel")
title.Size = UDim2.new(1, -36, 0, 24)
title.Position = UDim2.new(0, 6, 0, 6)
title.BackgroundTransparency = 1
title.Font = Enum.Font.SourceSansSemibold
title.TextColor3 = Color3.fromRGB(230,230,230)
title.TextSize = 18
title.Text = "Sound Detector"
title.TextXAlignment = Enum.TextXAlignment.Left
title.Parent = frame

local info = Instance.new("TextLabel")
info.Size = UDim2.new(1, -12, 0, 16)
info.Position = UDim2.new(0, 6, 0, 30)
info.BackgroundTransparency = 1
info.Font = Enum.Font.SourceSans
info.TextSize = 12
info.TextColor3 = Color3.fromRGB(200,200,200)
info.Text = "Detects currently playing audios & lets you copy them. Use the History for past audios."
info.TextXAlignment = Enum.TextXAlignment.Left
info.Parent = frame

-----------------------------------------------------------
-- CURRENT DETECTED TEXTBOX
-----------------------------------------------------------

local textbox = Instance.new("TextBox")
textbox.Size = UDim2.new(1, -12, 0, 36)
textbox.Position = UDim2.new(0, 6, 0, 50)
textbox.BackgroundColor3 = Color3.fromRGB(240,240,240)
textbox.Font = Enum.Font.SourceSans
textbox.TextSize = 14
textbox.TextColor3 = Color3.fromRGB(0,0,0)
textbox.ClearTextOnFocus = false
textbox.PlaceholderText = "No sound detected"
textbox.Parent = frame

local copyButton = Instance.new("TextButton")
copyButton.Size = UDim2.new(0, 120, 0, 28)
copyButton.Position = UDim2.new(1, -126, 0, 94)
copyButton.Text = "Copy"
copyButton.Font = Enum.Font.SourceSansBold
copyButton.TextColor3 = Color3.new(1,1,1)
copyButton.BackgroundColor3 = Color3.fromRGB(60,120,200)
copyButton.Parent = frame

local countLabel = Instance.new("TextLabel")
countLabel.Size = UDim2.new(0, 180, 0, 28)
countLabel.Position = UDim2.new(0, 6, 0, 94)
countLabel.BackgroundTransparency = 1
countLabel.Text = "Detected: 0"
countLabel.TextColor3 = Color3.fromRGB(200,200,200)
countLabel.Font = Enum.Font.SourceSans
countLabel.TextSize = 14
countLabel.Parent = frame

-----------------------------------------------------------
-- HISTORY BUTTON
-----------------------------------------------------------

local historyButton = Instance.new("TextButton")
historyButton.Size = UDim2.new(0, 110, 0, 28)
historyButton.Position = UDim2.new(0, 6, 0, 122)
historyButton.Text = "History"
historyButton.TextColor3 = Color3.new(1,1,1)
historyButton.Font = Enum.Font.SourceSansBold
historyButton.BackgroundColor3 = Color3.fromRGB(70,70,70)
historyButton.Parent = frame

-----------------------------------------------------------
-- HISTORY PANEL
-----------------------------------------------------------

local historyFrame = Instance.new("Frame")
historyFrame.Size = UDim2.new(0, 330, 0, 260)
historyFrame.Position = UDim2.new(0, 450, 0, 60)
historyFrame.BackgroundColor3 = Color3.fromRGB(20,20,20)
historyFrame.BorderSizePixel = 0
historyFrame.Visible = false
historyFrame.Parent = screenGui

local historyList = Instance.new("ScrollingFrame")
historyList.Size = UDim2.new(1, -10, 1, -10)
historyList.Position = UDim2.new(0, 5, 0, 5)
historyList.CanvasSize = UDim2.new(0,0,0,0)
historyList.ScrollBarThickness = 6
historyList.BackgroundTransparency = 1
historyList.Parent = historyFrame

local layout = Instance.new("UIListLayout")
layout.Parent = historyList
layout.Padding = UDim.new(0, 6)

local history = {} -- stored ids to avoid duplicates
local historyButtons = {} -- store UI elements for toggling icons if needed

historyButton.MouseButton1Click:Connect(function()
	historyFrame.Visible = not historyFrame.Visible
end)

-----------------------------------------------------------
-- COPY HELPER (tries multiple APIs, falls back to instructing)
-----------------------------------------------------------

local function notify(titleText, bodyText)
	pcall(function()
		StarterGui:SetCore("SendNotification", {
			Title = titleText;
			Text = bodyText;
			Duration = 2;
		})
	end)
end

local function copyToClipboard(text)
	if not text or text == "" then
		notify("Copy failed", "Nothing to copy.")
		return false
	end

	-- try global setclipboard
	if type(setclipboard) == "function" then
		local ok = pcall(setclipboard, text)
		if ok then
			notify("Copied", "Copied to clipboard.")
			return true
		end
	end

	-- try UserInputService:SetClipboard
	if UIS and type(UIS.SetClipboard) == "function" then
		local ok = pcall(function() UIS:SetClipboard(text) end)
		if ok then
			notify("Copied", "Copied to clipboard.")
			return true
		end
	end

	-- fallback: place text into the main textbox and focus it so user can manually copy
	textbox.Text = text
	textbox:CaptureFocus()
	notify("Manual copy", "Automatic copy unavailable. Text placed in box — press Ctrl/Cmd+C to copy.")
	return false
end

-----------------------------------------------------------
-- FORMAT ID HELPER
-----------------------------------------------------------

local function formatId(str)
	local id = tostring(str):match("%d+")
	return id and ("rbxassetid://" .. id) or tostring(str)
end

-----------------------------------------------------------
-- SOLO / PLAY CONTROL
-- When an entry is played: mute every other Sound (set Volume=0) and play the selected asset locally (looped).
-- New sounds created/started while solo is active will be muted automatically.
-----------------------------------------------------------

local soloState = {
	activeId = nil,               -- the rbxassetid being soloed (string)
	playerSound = nil,            -- the local Sound instance used to play the soloed asset
	prevVolumes = {},             -- map [soundInstance] = previousVolume
	descAddedConn = nil,         -- connection for descendant added
	playChangedConns = {},       -- map [soundInstance] = connection for Playing property (to detect new starts)
	activeEntryButton = nil,     -- UI button reference to change icon back when stopped
}

local function safeSetVolume(sound, vol)
	pcall(function() sound.Volume = vol end)
end

local function storeAndMuteSound(s)
	if not s or not s:IsA("Sound") then return end
	-- don't touch the playerSound we create for solo
	if soloState.playerSound and s == soloState.playerSound then return end
	-- if we haven't stored this sound's original volume, store it
	if not soloState.prevVolumes[s] then
		local ok, vol = pcall(function() return s.Volume end)
		if ok then
			soloState.prevVolumes[s] = vol
		else
			soloState.prevVolumes[s] = 1
		end
	end
	-- mute it
	safeSetVolume(s, 0)
end

local function restoreAllVolumes()
	for s, vol in pairs(soloState.prevVolumes) do
		if s and s.Parent then
			pcall(function() s.Volume = vol end)
		end
	end
	soloState.prevVolumes = {}
end

local function stopSolo()
	-- stop and remove our local player sound
	if soloState.playerSound then
		pcall(function()
			soloState.playerSound:Stop()
			soloState.playerSound:Destroy()
		end)
		soloState.playerSound = nil
	end

	-- disconnect descendant added
	if soloState.descAddedConn then
		pcall(function() soloState.descAddedConn:Disconnect() end)
		soloState.descAddedConn = nil
	end

	-- disconnect all per-sound play changed connections
	for s, conn in pairs(soloState.playChangedConns) do
		pcall(function() conn:Disconnect() end)
	end
	soloState.playChangedConns = {}

	-- restore volumes
	restoreAllVolumes()

	-- reset activeId and update UI icon if needed
	if soloState.activeEntryButton then
		pcall(function() soloState.activeEntryButton.Text = "▶️" end)
		soloState.activeEntryButton = nil
	end
	soloState.activeId = nil
end

local function startSolo(rbxAssetId, entryButton)
	-- if the same id is already active, toggle off
	if soloState.activeId == rbxAssetId then
		stopSolo()
		return
	end

	-- if another solo is active, stop it first
	if soloState.activeId then
		stopSolo()
	end

	-- set active id and UI
	soloState.activeId = rbxAssetId
	soloState.activeEntryButton = entryButton
	if entryButton then
		pcall(function() entryButton.Text = "⏸️" end)
	end

	-- Create a local looping Sound to play the requested asset
	local localSound = Instance.new("Sound")
	localSound.Name = "SoundDetectorPlayer"
	localSound.SoundId = rbxAssetId
	localSound.Looped = true
	localSound.Volume = 1
	localSound.Parent = SoundService -- play globally for the client
	soloState.playerSound = localSound

	-- Mute all existing sounds that are not the target
	for _, s in ipairs(game:GetDescendants()) do
		if s:IsA("Sound") then
			local formatted = formatId(s.SoundId)
			if formatted ~= rbxAssetId then
				storeAndMuteSound(s)
			else
				-- For the target sound(s) in the world, ensure they are audible
				-- Also store their volume so we can restore later
				if not soloState.prevVolumes[s] then
					local ok, vol = pcall(function() return s.Volume end)
					soloState.prevVolumes[s] = ok and vol or 1
				end
				-- keep target volumes as they were (do not mute)
			end
		end
	end

	-- Play our local sound (safe pcall)
	pcall(function() localSound:Play() end)

	-- If new Sounds are added while solo is active, mute them unless they match the active id
	soloState.descAddedConn = game.DescendantAdded:Connect(function(desc)
		if not desc or not desc:IsA("Sound") then return end
		-- small delay to allow Sound properties to be set on creation
		task.delay(0.05, function()
			local formatted = formatId(desc.SoundId)
			if formatted ~= soloState.activeId then
				storeAndMuteSound(desc)
			else
				-- if it matches active id, ensure it uses audible volume and store original volume
				if not soloState.prevVolumes[desc] then
					local ok, vol = pcall(function() return desc.Volume end)
					soloState.prevVolumes[desc] = ok and vol or 1
				end
			end
		end)
	end)

	-- Also watch existing and future sounds for "Playing" toggles and mute quickly when they start
	-- For existing sounds: connect to their Playing property so when they start we immediately mute if needed
	for _, s in ipairs(game:GetDescendants()) do
		if s:IsA("Sound") then
			local conn = s:GetPropertyChangedSignal("Playing"):Connect(function()
				-- if someone starts playing a non-target sound while solo is active, mute it
				if soloState.activeId and s.Playing then
					local formatted = formatId(s.SoundId)
					if formatted ~= soloState.activeId then
						storeAndMuteSound(s)
					end
				end
			end)
			soloState.playChangedConns[s] = conn
		end
	end

	-- When new descendants are added that are Sound, attach Playing changed listener too
	-- (we attach in DescendantAdded handler above to mute; attach connection now as well)
	-- Note: connections for newly added sounds are created inside the DescendantAdded handler to avoid missing them.
end

-----------------------------------------------------------
-- CREATE HISTORY ENTRY (clicking label OR pressing the copy button copies the id)
-- plus a Play/Pause button ▶️ / ⏸️ which solo-plays that asset
-----------------------------------------------------------

local function addHistoryEntry(id, name)
	if history[id] then return end
	history[id] = true

	local entry = Instance.new("Frame")
	entry.Size = UDim2.new(1, -6, 0, 32)
	entry.BackgroundColor3 = Color3.fromRGB(40,40,40)
	entry.Parent = historyList

	-- Play/Pause small button
	local playBtn = Instance.new("TextButton")
	playBtn.Size = UDim2.new(0, 28, 1, -4)
	playBtn.Position = UDim2.new(0, 4, 0, 2)
	playBtn.Text = "▶️"
	playBtn.Font = Enum.Font.SourceSansBold
	playBtn.TextSize = 18
	playBtn.BackgroundColor3 = Color3.fromRGB(70,100,160)
	playBtn.TextColor3 = Color3.new(1,1,1)
	playBtn.Parent = entry

	-- clickable label: looks like label but is a button so clicking copies
	local labelBtn = Instance.new("TextButton")
	labelBtn.Size = UDim2.new(1, -150, 1, 0)
	labelBtn.Position = UDim2.new(0, 40, 0, 0)
	labelBtn.BackgroundTransparency = 1
	labelBtn.Font = Enum.Font.SourceSans
	labelBtn.TextSize = 14
	labelBtn.TextColor3 = Color3.new(1,1,1)
	labelBtn.AutoButtonColor = false
	labelBtn.TextXAlignment = Enum.TextXAlignment.Left
	labelBtn.Text = (name or "Unknown") .. "   |   " .. id
	labelBtn.Parent = entry

	local copyBtn = Instance.new("TextButton")
	copyBtn.Size = UDim2.new(0, 64, 1, -4)
	copyBtn.Position = UDim2.new(1, -68, 0, 2)
	copyBtn.Text = "Copy"
	copyBtn.Font = Enum.Font.SourceSansBold
	copyBtn.TextColor3 = Color3.new(1,1,1)
	copyBtn.BackgroundColor3 = Color3.fromRGB(70,100,160)
	copyBtn.Parent = entry

	-- clicking either the label or the copy button copies the id to clipboard
	local function onCopy()
		copyToClipboard(id)
	end

	copyBtn.MouseButton1Click:Connect(onCopy)
	labelBtn.MouseButton1Click:Connect(onCopy)

	-- play/pause behavior
	playBtn.MouseButton1Click:Connect(function()
		-- toggle: if this id is already active, stop solo; otherwise start solo for this id
		if soloState.activeId == id then
			-- stop solo
			stopSolo()
		else
			-- start solo with this button so icon can be updated
			-- update any previous active button icon
			if soloState.activeEntryButton and soloState.activeEntryButton ~= playBtn then
				pcall(function() soloState.activeEntryButton.Text = "▶️" end)
			end
			startSolo(id, playBtn)
		end
	end)

	-- Keep reference so we can change icons later if needed
	historyButtons[id] = {
		frame = entry;
		playBtn = playBtn;
		copyBtn = copyBtn;
		labelBtn = labelBtn;
	}

	-- update canvas size
	historyList.CanvasSize = UDim2.new(0,0,0,layout.AbsoluteContentSize.Y)
end

-----------------------------------------------------------
-- LIVE AUDIO DETECTION
-----------------------------------------------------------

task.spawn(function()
	while true do
		local playing = {}

		for _, s in ipairs(game:GetDescendants()) do
			if s:IsA("Sound") and s.Playing then
				local formatted = formatId(s.SoundId)
				if formatted and formatted ~= "" then
					-- store last known name for the asset (if multiple different Sound instances use same ID, name of last encountered will be used)
					playing[formatted] = s.Name or "Unknown"
					addHistoryEntry(formatted, s.Name)
				end
			end
		end

		local list = {}
		for id,_ in pairs(playing) do table.insert(list,id) end
		table.sort(list)

		textbox.Text = table.concat(list, ", ")
		countLabel.Text = "Detected: " .. tostring(#list)

		-- If solo is active, continuously ensure new/quickly-started sounds are muted:
		if soloState.activeId then
			for _, s in ipairs(game:GetDescendants()) do
				if s:IsA("Sound") then
					local formatted = formatId(s.SoundId)
					if formatted ~= soloState.activeId then
						-- store and mute any sound that slipped through
						storeAndMuteSound(s)
					end
				end
			end
		end

		task.wait(0.3)
	end
end)

-----------------------------------------------------------
-- COPY CURRENT TEXTBOX
-----------------------------------------------------------

copyButton.MouseButton1Click:Connect(function()
	copyToClipboard(textbox.Text)
end)

-----------------------------------------------------------
-- Clean up on script stop / player leaving (best-effort)
-----------------------------------------------------------

local function cleanup()
	stopSolo()
	pcall(function() screenGui:Destroy() end)
end

-- Try to clean up when player leaves or script is disabled
player.AncestryChanged:Connect(function(_, parent)
	if not parent then cleanup() end
end)

return
