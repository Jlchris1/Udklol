-- Unified NPC GUI v5 (single LocalScript)
-- StarterGui LocalScript
-- Changes:
--  * Per-type pages are cached (no Destroy/ClearAllChildren) so UI state persists when hiding/opening GUI.
--  * Selecting a different type stops all loops belonging to the previous selection (avoids interference).
--  * Hiding the GUI uses Visible = false only (no destruction), so toggle states persist.

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local Workspace = game:GetService("Workspace")
local player = Players.LocalPlayer
local PlayerGui = player:WaitForChild("PlayerGui")

-- CONFIG
local SCAN_INTERVAL = 0.45
local LOOP_DELAY = 0.12
local GUI_WIDTH = 300
local GUI_HEIGHT = 360
local SMALL_TOGGLE_W = 30
local SMALL_TOGGLE_H = 15
local CENTER_TOP_Y = 8

-- STATE
local NPCs = {}               -- [model] = true
local trackedNPCs = {}        -- [model] = { gui=..., label=..., highlight=..., adornee=... }
local trackedTypes = {}       -- [typeName] = true (auto-track types)
local loops = {}              -- named loops (boolean)
local loopRunners = {}        -- coroutine refs
local excluded = {}           -- excluded[typeName] = { effectName = true }
local selectedType = nil
local prevSelectedType = nil
local cancelChaseEnabled = false
local trackerScanRunning = false

local EFFECTS = {
    "Kill","Fling","PlatformStand","Sit","Anchor","CancelChase","GetRid","Erase","Void","Spasm",
    "Jump","Void3","Speed","JumpPower","HipHeight","Heal","HPNaN","Tracker"
}

-- caching per-type pages so we don't destroy UI and lose state
local typeFeaturePages = {}     -- [typeName] = Frame (parented to featScroll)
local typeLeftPages = {}        -- [typeName] = Frame (parented to leftPanel)
local typeExclPages = {}        -- [typeName] = Frame (parented to exclScroll)

-- UTILS
local function isNPC(model)
    if not model or not model:IsA("Model") then return false end
    if Players:GetPlayerFromCharacter(model) then return false end
    local hum = model:FindFirstChildOfClass("Humanoid")
    if not hum then return false end
    local anyPart = model:FindFirstChild("HumanoidRootPart") or model.PrimaryPart or model:FindFirstChildWhichIsA("BasePart", true)
    return anyPart ~= nil
end

local function scanAddNPCs()
    for _,desc in ipairs(Workspace:GetDescendants()) do
        if desc:IsA("Humanoid") and desc.Parent and desc.Parent:IsA("Model") then
            local model = desc.Parent
            if isNPC(model) then NPCs[model] = true end
        end
    end
end

local function cleanNPCs()
    for model,_ in pairs(NPCs) do
        if not model or not model.Parent or not isNPC(model) then NPCs[model] = nil end
    end
end

Workspace.DescendantAdded:Connect(function(obj)
    if obj:IsA("Humanoid") and obj.Parent and obj.Parent:IsA("Model") then
        local model = obj.Parent
        if isNPC(model) then NPCs[model] = true end
    end
end)
Workspace.DescendantRemoving:Connect(function(obj)
    if obj:IsA("Humanoid") and obj.Parent and obj.Parent:IsA("Model") then
        local model = obj.Parent
        NPCs[model] = nil
    end
end)

local function iterateParts(npc, fn)
    if not npc then return end
    for _,p in ipairs(npc:GetDescendants()) do
        if p:IsA("BasePart") then pcall(function() fn(p) end) end
    end
end

local function getNPCsArray()
    local arr = {}
    for model,_ in pairs(NPCs) do
        if model and model.Parent and isNPC(model) then table.insert(arr, model) end
    end
    return arr
end

local function getNPCsByName(name)
    local arr = {}
    for model,_ in pairs(NPCs) do
        if model and model.Parent and model.Name == name and isNPC(model) then table.insert(arr, model) end
    end
    return arr
end

local function getBestPartForModel(model)
    if not model then return nil end
    return model:FindFirstChild("HumanoidRootPart") or model.PrimaryPart or model:FindFirstChildWhichIsA("BasePart", true)
end

local function isAllowed(model, effectName)
    if not model or not effectName then return true end
    local t = model.Name
    return not (excluded[t] and excluded[t][effectName])
end

-- ACTIONS (same as before)
local function killAllSimultaneousForList(models)
    local humanoids = {}
    for _,model in ipairs(models) do
        if isAllowed(model, "Kill") then
            local hum = model:FindFirstChildOfClass("Humanoid")
            if hum then table.insert(humanoids, hum) end
        end
    end
    if #humanoids == 0 then return end
    for _,hum in ipairs(humanoids) do pcall(function() hum.Health = 100 end) end
    task.wait(0.04)
    for _,hum in ipairs(humanoids) do
        pcall(function()
            local ok = pcall(function() hum:TakeDamage(math.huge) end)
            if not ok then pcall(function() hum.Health = -math.huge end) else pcall(function() hum.Health = 0 end) end
        end)
    end
end

local function flingModel(model, power)
    if not isAllowed(model, "Fling") then return end
    power = tonumber(power) or 200
    local localHRP = player.Character and (player.Character:FindFirstChild("HumanoidRootPart") or player.Character.PrimaryPart)
    if not localHRP then return end
    local targetPos
    local hrp = model:FindFirstChild("HumanoidRootPart")
    if hrp and hrp:IsA("BasePart") then targetPos = hrp.Position end
    if not targetPos and model.PrimaryPart and model.PrimaryPart:IsA("BasePart") then targetPos = model.PrimaryPart.Position end
    if not targetPos then
        local anyPart = model:FindFirstChildWhichIsA("BasePart", true)
        if anyPart then targetPos = anyPart.Position end
    end
    if not targetPos then return end
    local dir = targetPos - localHRP.Position
    local dirUnit = (dir.Magnitude <= 0.001) and Vector3.new(0,1,0) or dir.Unit
    local velocity = dirUnit * power + Vector3.new(0, power * 0.45, 0)
    iterateParts(model, function(p)
        if p and not p.Anchored then
            pcall(function()
                if p.AssemblyLinearVelocity ~= nil then p.AssemblyLinearVelocity = velocity else p.Velocity = velocity end
            end)
        end
    end)
end

local anchored = {}
local function toggleAnchor(model)
    if not isAllowed(model, "Anchor") then return end
    if not model then return end
    if anchored[model] then
        iterateParts(model, function(p) p.Anchored = false end)
        anchored[model] = nil
    else
        iterateParts(model, function(p) p.Anchored = true end)
        anchored[model] = true
    end
end

local function platformStand(model)
    if not isAllowed(model, "PlatformStand") then return end
    local hum = model and model:FindFirstChildOfClass("Humanoid")
    if hum then pcall(function() hum.PlatformStand = true end) end
end
local function makeSit(model)
    if not isAllowed(model, "Sit") then return end
    local hum = model and model:FindFirstChildOfClass("Humanoid")
    if hum then pcall(function() hum.Sit = true end) end
end

local function voidAway(model)
    if not isAllowed(model, "Void") then return end
    local p = getBestPartForModel(model)
    if p then pcall(function() p.CFrame = CFrame.new(1e6,0,1e6) end) end
end

local function eraseModel(model)
    if not isAllowed(model, "Erase") then return end
    local hum = model:FindFirstChildOfClass("Humanoid")
    if hum then pcall(function() hum.Health = 0 end) end
    pcall(function() model:Destroy() end)
end

local function spasmModel(model)
    if not isAllowed(model, "Spasm") then return end
    local hum = model:FindFirstChildOfClass("Humanoid")
    if hum then pcall(function() hum.PlatformStand = true end) end
    iterateParts(model, function(p)
        pcall(function()
            local rx,ry,rz = math.rad(math.random(-180,180)), math.rad(math.random(-180,180)), math.rad(math.random(-180,180))
            p.CFrame = p.CFrame * CFrame.Angles(rx,ry,rz)
        end)
    end)
end

local function jumpModel(model)
    if not isAllowed(model, "Jump") then return end
    local hum = model:FindFirstChildOfClass("Humanoid")
    if hum then pcall(function() hum.Jump = true end) end
end

local function setHipHeight(model, value)
    if not isAllowed(model, "HipHeight") then return end
    local hum = model:FindFirstChildOfClass("Humanoid")
    if hum then pcall(function() hum.HipHeight = value end) end
end

local function healTickModel(model, amt)
    if not isAllowed(model, "Heal") then return end
    local hum = model:FindFirstChildOfClass("Humanoid")
    if hum then pcall(function() hum.Health = math.min(hum.MaxHealth or hum.Health, hum.Health + amt) end) end
end

local function setSpeed(model,val)
    if not isAllowed(model, "Speed") then return end
    local hum = model:FindFirstChildOfClass("Humanoid")
    if hum then pcall(function() hum.WalkSpeed = val end) end
end

local function setJumpPower(model,val)
    if not isAllowed(model, "JumpPower") then return end
    local hum = model:FindFirstChildOfClass("Humanoid")
    if hum then pcall(function() if hum.JumpPower ~= nil then hum.JumpPower = val else hum.JumpHeight = val end end) end
end

local function setHPNaN(model)
    if not isAllowed(model, "HPNaN") then return end
    local hum = model:FindFirstChildOfClass("Humanoid")
    if hum then pcall(function() hum.Health = 0/0 end) end
end

local function cancelChaseForModel(model)
    if not isAllowed(model, "CancelChase") then return end
    local hum = model and model:FindFirstChildOfClass("Humanoid")
    if not hum then return end
    local hrp = getBestPartForModel(model)
    if not hrp then return end
    local pos = hrp.Position
    pcall(function()
        if typeof(hum.MoveTo) == "function" then hum:MoveTo(pos) else pcall(function() hum:MoveTo(pos) end) end
    end)
end

-- TRACKER & HIGHLIGHT
local function addTrackerToModel(model)
    if not model then return end
    if not isAllowed(model, "Tracker") then return end
    if trackedNPCs[model] then return end

    local part = getBestPartForModel(model)
    if not part then return end

    local gui = Instance.new("BillboardGui")
    gui.Name = "NPCTracker"
    gui.Size = UDim2.new(0,180,0,36)
    gui.StudsOffset = Vector3.new(0,2,0)
    gui.AlwaysOnTop = true
    gui.Adornee = part
    gui.Parent = PlayerGui

    local label = Instance.new("TextLabel")
    label.Size = UDim2.new(1,-4,1,-4)
    label.Position = UDim2.new(0,2,0,2)
    label.BackgroundTransparency = 1
    label.TextColor3 = Color3.new(1,1,1)
    label.Font = Enum.Font.Code
    label.TextScaled = true
    label.Parent = gui

    local highlight = Instance.new("Highlight")
    highlight.Name = "NPCHighlight"
    highlight.Adornee = model
    highlight.Parent = PlayerGui
    highlight.FillTransparency = 1
    highlight.OutlineColor = Color3.fromRGB(80,200,120)
    highlight.OutlineTransparency = 0

    trackedNPCs[model] = { gui = gui, label = label, highlight = highlight, adornee = part }
end

local function removeTrackerFromModel(model)
    local data = trackedNPCs[model]
    if data then
        if data.gui then pcall(function() data.gui:Destroy() end) end
        if data.highlight then pcall(function() data.highlight:Destroy() end) end
    end
    trackedNPCs[model] = nil
end

local function updateAllTrackers()
    local playerPos = player.Character and player.Character.PrimaryPart and player.Character.PrimaryPart.Position
    for model,data in pairs(trackedNPCs) do
        local part = getBestPartForModel(model)
        if not model.Parent or not part then removeTrackerFromModel(model) end
        if data and data.label and model.Parent then
            local hum = model:FindFirstChildOfClass("Humanoid")
            local hrp = part
            local dist = 0
            if playerPos and hrp then dist = (hrp.Position - playerPos).Magnitude end
            if hum then
                local jp = hum.JumpPower or hum.JumpHeight or 0
                data.label.Text = string.format("%s | HP: %.1f | Speed: %.1f | JP: %.1f | Dist: %.1f",
                    model.Name, hum.Health or 0, hum.WalkSpeed or 0, jp, dist)
            end
        end
    end
end

-- LOOP helpers
local function startLoop(key, fn)
    if loopRunners[key] then return end
    loops[key] = true
    local co = coroutine.create(function()
        while loops[key] do
            pcall(fn)
            task.wait(LOOP_DELAY)
        end
        loopRunners[key] = nil
    end)
    loopRunners[key] = co
    coroutine.resume(co)
end
local function stopLoop(key) loops[key] = false end

-- stop all loops associated to a type (called on deselect)
local function stopAllTypeLoops(typeName)
    if not typeName then return end
    -- for each effect build key and stop
    for _,eff in ipairs(EFFECTS) do
        local key = eff .. "_" .. typeName
        stopLoop(key)
    end
    -- also stop named per-type speed/jp prefixes if used
    stopLoop("speed_"..typeName)
    stopLoop("jp_"..typeName)
    stopLoop("hip_"..typeName)
end

-- UI BASE
local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Name = "UnifiedNPCGUI"
ScreenGui.ResetOnSpawn = false
ScreenGui.IgnoreGuiInset = true
ScreenGui.Parent = PlayerGui

local SmallToggle = Instance.new("TextButton")
SmallToggle.Name = "SmallToggle"
SmallToggle.Size = UDim2.new(0, SMALL_TOGGLE_W, 0, SMALL_TOGGLE_H)
SmallToggle.AnchorPoint = Vector2.new(0.5, 0)
SmallToggle.Position = UDim2.new(0.5, 0, 0, CENTER_TOP_Y)
SmallToggle.BackgroundColor3 = Color3.fromRGB(44,44,44)
SmallToggle.BorderSizePixel = 0
SmallToggle.Font = Enum.Font.GothamBold
SmallToggle.TextSize = 11
SmallToggle.TextColor3 = Color3.new(1,1,1)
SmallToggle.Text = "NPC"
SmallToggle.Parent = ScreenGui
SmallToggle.ZIndex = 10

-- Main frame (hidden by Visible only)
local MainFrame = Instance.new("Frame")
MainFrame.Name = "MainFrame"
MainFrame.AnchorPoint = Vector2.new(0.5, 0.5)
MainFrame.Position = UDim2.new(0.5, 0, 0.5, 0)
MainFrame.Size = UDim2.new(0, 120, 0, 24)
MainFrame.BackgroundColor3 = Color3.fromRGB(25,25,25)
MainFrame.BorderSizePixel = 0
MainFrame.ClipsDescendants = true
MainFrame.Visible = false
MainFrame.Parent = ScreenGui

local TopBar = Instance.new("Frame"); TopBar.Size = UDim2.new(1,0,0,34); TopBar.BackgroundColor3 = Color3.fromRGB(44,44,44); TopBar.Parent = MainFrame
local Title = Instance.new("TextLabel"); Title.Size = UDim2.new(0.6,0,1,0); Title.BackgroundTransparency = 1; Title.TextColor3 = Color3.new(1,1,1); Title.Font = Enum.Font.GothamBold; Title.TextSize = 16; Title.Text = "Unified NPC Control"; Title.Position = UDim2.new(0.04,0,0,0); Title.Parent = TopBar

-- Tabs
local TabsBar = Instance.new("Frame"); TabsBar.Size = UDim2.new(1,0,0,30); TabsBar.Position = UDim2.new(0,0,0,34); TabsBar.BackgroundTransparency = 1; TabsBar.Parent = MainFrame
local function tabButton(x, text)
    local b = Instance.new("TextButton")
    b.Size = UDim2.new(0.25, -6, 1, 0)
    b.Position = UDim2.new(x, 4, 0, 0)
    b.BackgroundColor3 = Color3.fromRGB(58,58,58)
    b.BorderSizePixel = 0
    b.Font = Enum.Font.Gotham
    b.TextSize = 13
    b.TextColor3 = Color3.new(1,1,1)
    b.Text = text
    b.Parent = TabsBar
    return b
end
local tabControlsBtn = tabButton(0, "Controls")
local tabUtilitiesBtn = tabButton(0.25, "Utilities")
local tabAdvancedBtn = tabButton(0.5, "Advanced")
local tabWhitelistBtn = tabButton(0.75, "Whitelist")

local Content = Instance.new("Frame")
Content.Size = UDim2.new(1,0,1, - (34 + 30))
Content.Position = UDim2.new(0,0,0, 34 + 30)
Content.BackgroundColor3 = Color3.fromRGB(32,32,32)
Content.Parent = MainFrame
Content.Visible = false

local CounterLabel = Instance.new("TextLabel")
CounterLabel.Size = UDim2.new(1, -8, 0, 24)
CounterLabel.Position = UDim2.new(0,4,0,6)
CounterLabel.BackgroundTransparency = 0.6
CounterLabel.BackgroundColor3 = Color3.fromRGB(26,26,26)
CounterLabel.BorderSizePixel = 0
CounterLabel.Font = Enum.Font.Gotham
CounterLabel.TextSize = 13
CounterLabel.TextColor3 = Color3.new(1,1,1)
CounterLabel.Text = "NPCs detected: 0"
CounterLabel.Parent = Content

local function makeScroll(parent, yOffset, h)
    local s = Instance.new("ScrollingFrame")
    s.Size = UDim2.new(1, -12, 0, h or 220)
    s.Position = UDim2.new(0, 6, 0, yOffset)
    s.BackgroundTransparency = 1
    s.ScrollBarThickness = 8
    s.Parent = parent
    local layout = Instance.new("UIListLayout")
    layout.Parent = s
    layout.SortOrder = Enum.SortOrder.LayoutOrder
    layout.Padding = UDim.new(0,6)
    layout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
        s.CanvasSize = UDim2.new(0, 0, 0, layout.AbsoluteContentSize.Y + 8)
    end)
    return s, layout
end

-- Tab frames
local controlsFrame = Instance.new("Frame"); controlsFrame.Size = UDim2.new(1,0,1,0); controlsFrame.BackgroundTransparency = 1; controlsFrame.Parent = Content
local utilitiesFrame = Instance.new("Frame"); utilitiesFrame.Size = UDim2.new(1,0,1,0); utilitiesFrame.BackgroundTransparency = 1; utilitiesFrame.Parent = Content; utilitiesFrame.Visible = false
local advancedFrame = Instance.new("Frame"); advancedFrame.Size = UDim2.new(1,0,1,0); advancedFrame.BackgroundTransparency = 1; advancedFrame.Parent = Content; advancedFrame.Visible = false
local whitelistFrame = Instance.new("Frame"); whitelistFrame.Size = UDim2.new(1,0,1,0); whitelistFrame.BackgroundTransparency = 1; whitelistFrame.Parent = Content; whitelistFrame.Visible = false

local ctrlScroll,_ = makeScroll(controlsFrame, 36)
local utilScroll,_ = makeScroll(utilitiesFrame, 36)
local advScroll,_ = makeScroll(advancedFrame, 36)

-- Whitelist tab: left panel
local groupScroll = Instance.new("ScrollingFrame")
groupScroll.Size = UDim2.new(1, - (150 + 24), 1, - 72)
groupScroll.Position = UDim2.new(0, 156, 0, 36)
groupScroll.BackgroundTransparency = 1
groupScroll.ScrollBarThickness = 8
groupScroll.Parent = whitelistFrame
local groupList = Instance.new("UIListLayout"); groupList.Parent = groupScroll; groupList.SortOrder = Enum.SortOrder.LayoutOrder; groupList.Padding = UDim.new(0,6)
groupList:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function() groupScroll.CanvasSize = UDim2.new(0,0,0, groupList.AbsoluteContentSize.Y + 8) end)

local leftPanel = Instance.new("ScrollingFrame")
leftPanel.Size = UDim2.new(0,150,1,-12)
leftPanel.Position = UDim2.new(0,6,0,36)
leftPanel.BackgroundColor3 = Color3.fromRGB(28,28,28)
leftPanel.BorderSizePixel = 0
leftPanel.ScrollBarThickness = 8
leftPanel.Parent = whitelistFrame
leftPanel.Visible = false
local leftLayout = Instance.new("UIListLayout"); leftLayout.Parent = leftPanel; leftLayout.SortOrder = Enum.SortOrder.LayoutOrder; leftLayout.Padding = UDim.new(0,6)

local leftTitle = Instance.new("TextLabel")
leftTitle.Size = UDim2.new(1, -8, 0, 24)
leftTitle.Position = UDim2.new(0, 4, 0, 6)
leftTitle.BackgroundTransparency = 1
leftTitle.Font = Enum.Font.GothamBold
leftTitle.TextSize = 13
leftTitle.TextColor3 = Color3.new(1,1,1)
leftTitle.Text = "Type: (none)"
leftTitle.Parent = leftPanel

local function makeLeftBtnText(text)
    local b = Instance.new("TextButton")
    b.Size = UDim2.new(1, -8, 0, 28)
    b.BackgroundColor3 = Color3.fromRGB(58,58,58)
    b.BorderSizePixel = 0
    b.Font = Enum.Font.Gotham
    b.TextSize = 13
    b.TextColor3 = Color3.new(1,1,1)
    b.Text = text
    b.Parent = leftPanel
    return b
end

-- Exclusion panel (rightmost) - we'll create per-type content frames inside exclScroll
local ExclusionPanel = Instance.new("Frame")
ExclusionPanel.Name = "ExclusionPanel"
ExclusionPanel.Size = UDim2.new(0, 220, 0, GUI_HEIGHT)
ExclusionPanel.AnchorPoint = Vector2.new(0, 0.5)
ExclusionPanel.Position = UDim2.new(0.5, GUI_WIDTH/2 + 12 + 260 + 12, 0.5, 0)
ExclusionPanel.BackgroundColor3 = Color3.fromRGB(30,30,30)
ExclusionPanel.BorderSizePixel = 0
ExclusionPanel.Visible = false
ExclusionPanel.Parent = ScreenGui

local exclTitle = Instance.new("TextLabel")
exclTitle.Size = UDim2.new(1, -8, 0, 24)
exclTitle.Position = UDim2.new(0,4,0,6)
exclTitle.BackgroundTransparency = 1
exclTitle.Font = Enum.Font.GothamBold
exclTitle.TextSize = 14
exclTitle.TextColor3 = Color3.new(1,1,1)
exclTitle.Text = "Exclusions (select a type)"
exclTitle.Parent = ExclusionPanel

local exclScroll = Instance.new("ScrollingFrame")
exclScroll.Size = UDim2.new(1, -12, 1, - 40)
exclScroll.Position = UDim2.new(0,6,0,36)
exclScroll.BackgroundTransparency = 1
exclScroll.ScrollBarThickness = 8
exclScroll.Parent = ExclusionPanel
local exclList = Instance.new("UIListLayout"); exclList.Parent = exclScroll; exclList.SortOrder = Enum.SortOrder.LayoutOrder; exclList.Padding = UDim.new(0,6)
exclList:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
    exclScroll.CanvasSize = UDim2.new(0,0,0, exclList.AbsoluteContentSize.Y + 8)
end)

-- Features panel (right of main)
local FeaturesPanel = Instance.new("Frame")
FeaturesPanel.Name = "FeaturesPanel"
FeaturesPanel.Size = UDim2.new(0, 260, 0, GUI_HEIGHT)
FeaturesPanel.AnchorPoint = Vector2.new(0, 0.5)
FeaturesPanel.Position = UDim2.new(0.5, GUI_WIDTH/2 + 12, 0.5, 0)
FeaturesPanel.BackgroundColor3 = Color3.fromRGB(30,30,30)
FeaturesPanel.BorderSizePixel = 0
FeaturesPanel.Visible = false
FeaturesPanel.Parent = ScreenGui

local featTitle = Instance.new("TextLabel")
featTitle.Size = UDim2.new(1, -8, 0, 24)
featTitle.Position = UDim2.new(0,4,0,6)
featTitle.BackgroundTransparency = 1
featTitle.Font = Enum.Font.GothamBold
featTitle.TextSize = 14
featTitle.TextColor3 = Color3.new(1,1,1)
featTitle.Text = "Type Features"
featTitle.Parent = FeaturesPanel

local featScroll = Instance.new("ScrollingFrame")
featScroll.Size = UDim2.new(1, -12, 1, - 120)
featScroll.Position = UDim2.new(0,6,0,36)
featScroll.BackgroundTransparency = 1
featScroll.ScrollBarThickness = 8
featScroll.Parent = FeaturesPanel
local featList = Instance.new("UIListLayout"); featList.Parent = featScroll; featList.SortOrder = Enum.SortOrder.LayoutOrder; featList.Padding = UDim.new(0,6)
featList:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
    featScroll.CanvasSize = UDim2.new(0,0,0, featList.AbsoluteContentSize.Y + 8)
end)

-- small-per-type controls under FeaturesPanel (kept global area, not per-type)
local function makeSmallLabel(parent, text, posY)
    local lbl = Instance.new("TextLabel")
    lbl.Size = UDim2.new(0.5, -6, 0, 20)
    lbl.Position = UDim2.new(0,4,1,posY)
    lbl.BackgroundTransparency = 1
    lbl.Font = Enum.Font.Gotham
    lbl.TextSize = 12
    lbl.TextColor3 = Color3.new(1,1,1)
    lbl.Text = text
    lbl.Parent = parent
    return lbl
end
local function makeSmallInput(parent, default, posY)
    local box = Instance.new("TextBox")
    box.Size = UDim2.new(0.33,0,0,24)
    box.Position = UDim2.new(0.5,4,1,posY-4)
    box.Text = default
    box.PlaceholderText = default
    box.BackgroundColor3 = Color3.fromRGB(50,50,50)
    box.TextColor3 = Color3.new(1,1,1)
    box.Font = Enum.Font.Gotham
    box.TextSize = 13
    box.Parent = parent
    return box
end
local function makeSmallLoopBtn(parent, posY)
    local btn = Instance.new("TextButton")
    btn.Size = UDim2.new(0.16,0,0,24)
    btn.Position = UDim2.new(0.83,4,1,posY-4)
    btn.BackgroundColor3 = Color3.fromRGB(40,40,40)
    btn.Text = "Loop: Off"
    btn.Font = Enum.Font.Gotham
    btn.TextSize = 12
    btn.TextColor3 = Color3.new(1,1,1)
    btn.Parent = parent
    return btn
end

local speedLabel_feat = makeSmallLabel(FeaturesPanel, "Speed (type)", -76)
local speedInput_feat = makeSmallInput(FeaturesPanel, "16", -76)
local speedLoop_feat = makeSmallLoopBtn(FeaturesPanel, -76)

local jpLabel_feat = makeSmallLabel(FeaturesPanel, "JumpPower (type)", -48)
local jpInput_feat = makeSmallInput(FeaturesPanel, "50", -48)
local jpLoop_feat = makeSmallLoopBtn(FeaturesPanel, -48)

local hipLabel_feat = makeSmallLabel(FeaturesPanel, "HipHeight (type)", -20)
local hipInput_feat = makeSmallInput(FeaturesPanel, "2", -20)
local hipLoop_feat = makeSmallLoopBtn(FeaturesPanel, -20)

local healLabel_feat = makeSmallLabel(FeaturesPanel, "Heal/tick (type)", -108)
local healInput_feat = makeSmallInput(FeaturesPanel, "5", -108)
local healLoop_feat = makeSmallLoopBtn(FeaturesPanel, -108)

local flingLabel_feat = makeSmallLabel(FeaturesPanel, "Fling Power (type)", -140)
local flingInput_feat = makeSmallInput(FeaturesPanel, "200", -140)
local flingLoop_feat = makeSmallLoopBtn(FeaturesPanel, -140)

-- simple helper to create control rows
local function makeRow(parent, text)
    local frame = Instance.new("Frame")
    frame.Size = UDim2.new(1, 0, 0, 36)
    frame.BackgroundTransparency = 1
    frame.Parent = parent
    local btn = Instance.new("TextButton")
    btn.Size = UDim2.new(0.66, 0, 1, 0)
    btn.Position = UDim2.new(0, 0, 0, 0)
    btn.BackgroundColor3 = Color3.fromRGB(58,58,58)
    btn.BorderSizePixel = 0
    btn.Font = Enum.Font.Gotham
    btn.TextSize = 14
    btn.TextColor3 = Color3.new(1,1,1)
    btn.Text = text
    btn.Parent = frame
    local small = Instance.new("TextButton")
    small.Size = UDim2.new(0.32, 0, 1, 0)
    small.Position = UDim2.new(0.68, 6, 0, 0)
    small.BackgroundColor3 = Color3.fromRGB(40,40,40)
    small.BorderSizePixel = 0
    small.Font = Enum.Font.Gotham
    small.TextSize = 12
    small.TextColor3 = Color3.new(1,1,1)
    small.Text = "Loop: Off"
    small.Parent = frame
    return btn, small
end

-- Controls & Utilities rows (same as before)
local killBtn, killLoopBtn = makeRow(ctrlScroll, "Kill All (Simultaneous)")
local flingBoxRow = Instance.new("Frame"); flingBoxRow.Size = UDim2.new(1,0,0,36); flingBoxRow.BackgroundTransparency = 1; flingBoxRow.Parent = ctrlScroll
local flingBox = Instance.new("TextBox"); flingBox.Size = UDim2.new(0.56,0,1,0); flingBox.Position = UDim2.new(0,0,0,0); flingBox.PlaceholderText = "Fling Power"; flingBox.Text = "200"; flingBox.BackgroundColor3 = Color3.fromRGB(50,50,50); flingBox.TextColor3 = Color3.new(1,1,1); flingBox.BorderSizePixel = 0; flingBox.Font = Enum.Font.Gotham; flingBox.TextSize = 14; flingBox.Parent = flingBoxRow
local flingBtn = Instance.new("TextButton"); flingBtn.Size = UDim2.new(0.42, -6, 1, 0); flingBtn.Position = UDim2.new(0.56, 6, 0, 0); flingBtn.BackgroundColor3 = Color3.fromRGB(100,50,50); flingBtn.BorderSizePixel = 0; flingBtn.Font = Enum.Font.Gotham; flingBtn.TextSize = 14; flingBtn.TextColor3 = Color3.new(1,1,1); flingBtn.Text = "Fling All"; flingBtn.Parent = flingBoxRow
local flingLoopBtn = Instance.new("TextButton"); flingLoopBtn.Size = UDim2.new(0.32,0,1,0); flingLoopBtn.Position = UDim2.new(0.68, 6, 0, 0); flingLoopBtn.BackgroundColor3 = Color3.fromRGB(40,40,40); flingLoopBtn.BorderSizePixel = 0; flingLoopBtn.Font = Enum.Font.Gotham; flingLoopBtn.TextSize = 12; flingLoopBtn.TextColor3 = Color3.new(1,1,1); flingLoopBtn.Text = "Loop: Off"; flingLoopBtn.Parent = flingBoxRow

local psBtn, psLoopBtn = makeRow(ctrlScroll, "PlatformStand All")
local sitBtn, sitLoopBtn = makeRow(ctrlScroll, "Sit All")
local anchorBtn, anchorLoopBtn = makeRow(ctrlScroll, "Toggle Anchor All")
local cancelChaseBtn, cancelChaseLoopBtn = makeRow(ctrlScroll, "Toggle Cancel-Chase (MoveTo)")

local getRidBtn, getRidLoop = makeRow(utilScroll, "Get Rid (Teleport Closest)")
local eraseBtn, eraseLoopBtn = makeRow(utilScroll, "Erase / Destroy All")
local voidBtn, voidLoopBtn = makeRow(utilScroll, "Void All (instant)")
local spasmBtn, spasmLoopBtn = makeRow(utilScroll, "Spasm All")
local jumpBtn, jumpLoopBtn = makeRow(utilScroll, "Jump All")
local void3Btn, void3LoopBtn = makeRow(utilScroll, "Void v3 (Velocity Spam)")

-- Advanced: global speed & jump + hipheight + tracker toggle (no per-type heal here per request)
local speedGlobalFrame = Instance.new("Frame"); speedGlobalFrame.Size = UDim2.new(1,0,0,36); speedGlobalFrame.BackgroundTransparency = 1; speedGlobalFrame.Parent = advScroll
local speedGlobalBox = Instance.new("TextBox"); speedGlobalBox.Size = UDim2.new(0.62,0,1,0); speedGlobalBox.Position = UDim2.new(0,0,0,0); speedGlobalBox.Text = "16"; speedGlobalBox.PlaceholderText = "Global Speed"; speedGlobalBox.BackgroundColor3 = Color3.fromRGB(50,50,50); speedGlobalBox.TextColor3 = Color3.new(1,1,1); speedGlobalBox.BorderSizePixel = 0; speedGlobalBox.Font = Enum.Font.Gotham; speedGlobalBox.TextSize = 14; speedGlobalBox.Parent = speedGlobalFrame
local speedGlobalLoop = Instance.new("TextButton"); speedGlobalLoop.Size = UDim2.new(0.34,0,1,0); speedGlobalLoop.Position = UDim2.new(0.63,6,0,0); speedGlobalLoop.BackgroundColor3 = Color3.fromRGB(40,40,40); speedGlobalLoop.BorderSizePixel = 0; speedGlobalLoop.Font = Enum.Font.Gotham; speedGlobalLoop.TextSize = 12; speedGlobalLoop.TextColor3 = Color3.new(1,1,1); speedGlobalLoop.Text = "Loop: Off"; speedGlobalLoop.Parent = speedGlobalFrame

local jumpGlobalFrame = Instance.new("Frame"); jumpGlobalFrame.Size = UDim2.new(1,0,0,36); jumpGlobalFrame.BackgroundTransparency = 1; jumpGlobalFrame.Parent = advScroll
local jumpGlobalBox = Instance.new("TextBox"); jumpGlobalBox.Size = UDim2.new(0.62,0,1,0); jumpGlobalBox.Position = UDim2.new(0,0,0,0); jumpGlobalBox.Text = "50"; jumpGlobalBox.PlaceholderText = "Global JumpPower"; jumpGlobalBox.BackgroundColor3 = Color3.fromRGB(50,50,50); jumpGlobalBox.TextColor3 = Color3.new(1,1,1); jumpGlobalBox.BorderSizePixel = 0; jumpGlobalBox.Font = Enum.Font.Gotham; jumpGlobalBox.TextSize = 14; jumpGlobalBox.Parent = jumpGlobalFrame
local jumpGlobalLoop = Instance.new("TextButton"); jumpGlobalLoop.Size = UDim2.new(0.34,0,1,0); jumpGlobalLoop.Position = UDim2.new(0.63,6,0,0); jumpGlobalLoop.BackgroundColor3 = Color3.fromRGB(40,40,40); jumpGlobalLoop.BorderSizePixel = 0; jumpGlobalLoop.Font = Enum.Font.Gotham; jumpGlobalLoop.TextSize = 12; jumpGlobalLoop.TextColor3 = Color3.new(1,1,1); jumpGlobalLoop.Text = "Loop: Off"; jumpGlobalLoop.Parent = jumpGlobalFrame

local hipFrame = Instance.new("Frame"); hipFrame.Size = UDim2.new(1,0,0,36); hipFrame.BackgroundTransparency = 1; hipFrame.Parent = advScroll
local hipBox = Instance.new("TextBox"); hipBox.Size = UDim2.new(0.62,0,1,0); hipBox.Position = UDim2.new(0,0,0,0); hipBox.Text = "2"; hipBox.PlaceholderText = "HipHeight"; hipBox.BackgroundColor3 = Color3.fromRGB(50,50,50); hipBox.TextColor3 = Color3.new(1,1,1); hipBox.BorderSizePixel = 0; hipBox.Font = Enum.Font.Gotham; hipBox.TextSize = 14; hipBox.Parent = hipFrame
local hipLoop = Instance.new("TextButton"); hipLoop.Size = UDim2.new(0.34,0,1,0); hipLoop.Position = UDim2.new(0.63,6,0,0); hipLoop.BackgroundColor3 = Color3.fromRGB(40,40,40); hipLoop.BorderSizePixel = 0; hipLoop.Font = Enum.Font.Gotham; hipLoop.TextSize = 12; hipLoop.TextColor3 = Color3.new(1,1,1); hipLoop.Text = "Loop: Off"; hipLoop.Parent = hipFrame

local trackerFrame = Instance.new("Frame"); trackerFrame.Size = UDim2.new(1,0,0,36); trackerFrame.BackgroundTransparency = 1; trackerFrame.Parent = advScroll
local trackerToggleBtn = Instance.new("TextButton")
trackerToggleBtn.Size = UDim2.new(1,0,1,0)
trackerToggleBtn.BackgroundColor3 = Color3.fromRGB(58,58,58)
trackerToggleBtn.BorderSizePixel = 0
trackerToggleBtn.Font = Enum.Font.Gotham
trackerToggleBtn.TextSize = 14
trackerToggleBtn.TextColor3 = Color3.new(1,1,1)
trackerToggleBtn.Text = "Toggle NPC Tracker"
trackerToggleBtn.Parent = trackerFrame

-- tracker scan
local function startTrackerScan()
    if trackerScanRunning then return end
    trackerScanRunning = true
    startLoop("trackerScan", function()
        for _,m in ipairs(getNPCsArray()) do
            if not trackedNPCs[m] and (not excluded[m.Name] or not excluded[m.Name]["Tracker"]) then
                addTrackerToModel(m)
            end
        end
    end)
end
local function stopTrackerScan()
    if not trackerScanRunning then return end
    trackerScanRunning = false
    stopLoop("trackerScan")
end

trackerToggleBtn.MouseButton1Click:Connect(function()
    local any = next(trackedNPCs) ~= nil
    if any then
        stopTrackerScan()
        for m,_ in pairs(trackedNPCs) do removeTrackerFromModel(m) end
        trackerToggleBtn.Text = "Toggle NPC Tracker"
    else
        startTrackerScan()
        trackerToggleBtn.Text = "Untrack All"
    end
end)

-- Helpers to create per-type pages (cached) so we don't destroy UI or loose state
local function ensureTypeLeftPage(typeName)
    if typeLeftPages[typeName] then return typeLeftPages[typeName] end
    -- create a container frame (invisible by default)
    local page = Instance.new("Frame")
    page.Size = UDim2.new(1,0,0,200)
    page.BackgroundTransparency = 1
    page.Visible = false
    page.Parent = leftPanel
    local layout = Instance.new("UIListLayout"); layout.Parent = page; layout.SortOrder = Enum.SortOrder.LayoutOrder; layout.Padding = UDim.new(0,6)

    -- title clone (kept outside) so page starts after top
    local pad = Instance.new("Frame"); pad.Size = UDim2.new(1,0,0,6); pad.BackgroundTransparency = 1; pad.Parent = page

    -- create the left-panel buttons but parent them to page (so they are per-type and persistent)
    local btnTrack = Instance.new("TextButton"); btnTrack.Size = UDim2.new(1,-8,0,28); btnTrack.BackgroundColor3 = Color3.fromRGB(58,58,58); btnTrack.BorderSizePixel = 0; btnTrack.Font = Enum.Font.Gotham; btnTrack.TextSize = 13; btnTrack.TextColor3 = Color3.new(1,1,1); btnTrack.Text = "Track/Untrack This Type"; btnTrack.Parent = page
    local btnKill  = Instance.new("TextButton"); btnKill.Size = UDim2.new(1,-8,0,28); btnKill.BackgroundColor3 = Color3.fromRGB(58,58,58); btnKill.BorderSizePixel = 0; btnKill.Font = Enum.Font.Gotham; btnKill.TextSize = 13; btnKill.TextColor3 = Color3.new(1,1,1); btnKill.Text = "Kill This Type"; btnKill.Parent = page
    local btnFling = Instance.new("TextButton"); btnFling.Size = UDim2.new(1,-8,0,28); btnFling.BackgroundColor3 = Color3.fromRGB(58,58,58); btnFling.BorderSizePixel = 0; btnFling.Font = Enum.Font.Gotham; btnFling.TextSize = 13; btnFling.TextColor3 = Color3.new(1,1,1); btnFling.Text = "Fling This Type"; btnFling.Parent = page
    local btnErase = Instance.new("TextButton"); btnErase.Size = UDim2.new(1,-8,0,28); btnErase.BackgroundColor3 = Color3.fromRGB(58,58,58); btnErase.BorderSizePixel = 0; btnErase.Font = Enum.Font.Gotham; btnErase.TextSize = 13; btnErase.TextColor3 = Color3.new(1,1,1); btnErase.Text = "Erase This Type"; btnErase.Parent = page
    local btnVoid  = Instance.new("TextButton"); btnVoid.Size = UDim2.new(1,-8,0,28); btnVoid.BackgroundColor3 = Color3.fromRGB(58,58,58); btnVoid.BorderSizePixel = 0; btnVoid.Font = Enum.Font.Gotham; btnVoid.TextSize = 13; btnVoid.TextColor3 = Color3.new(1,1,1); btnVoid.Text = "Void This Type"; btnVoid.Parent = page
    local btnAnchor= Instance.new("TextButton"); btnAnchor.Size = UDim2.new(1,-8,0,28); btnAnchor.BackgroundColor3 = Color3.fromRGB(58,58,58); btnAnchor.BorderSizePixel = 0; btnAnchor.Font = Enum.Font.Gotham; btnAnchor.TextSize = 13; btnAnchor.TextColor3 = Color3.new(1,1,1); btnAnchor.Text = "Toggle Anchor This Type"; btnAnchor.Parent = page
    local btnWhitelist = Instance.new("TextButton"); btnWhitelist.Size = UDim2.new(1,-8,0,28); btnWhitelist.BackgroundColor3 = Color3.fromRGB(58,58,58); btnWhitelist.BorderSizePixel = 0; btnWhitelist.Font = Enum.Font.Gotham; btnWhitelist.TextSize = 13; btnWhitelist.TextColor3 = Color3.new(1,1,1); btnWhitelist.Text = "Whitelist (exclusions)"; btnWhitelist.Parent = page

    -- connect behaviors (they reference selectedType dynamically inside showTypeUI so safe)
    btnTrack.MouseButton1Click:Connect(function()
        if not selectedType then return end
        trackedTypes[selectedType] = not trackedTypes[selectedType]
        btnTrack.Text = trackedTypes[selectedType] and "Untrack This Type" or "Track/Untrack This Type"
        if trackedTypes[selectedType] then
            for _,m in ipairs(getNPCsByName(selectedType)) do
                if not trackedNPCs[m] and (not excluded[selectedType] or not excluded[selectedType]["Tracker"]) then addTrackerToModel(m) end
            end
        else
            for _,m in ipairs(getNPCsByName(selectedType)) do removeTrackerFromModel(m) end
        end
    end)

    btnKill.MouseButton1Click:Connect(function()
        if not selectedType then return end
        if excluded[selectedType] and excluded[selectedType]["Kill"] then return end
        killAllSimultaneousForList(getNPCsByName(selectedType))
    end)
    btnFling.MouseButton1Click:Connect(function()
        if not selectedType then return end
        if excluded[selectedType] and excluded[selectedType]["Fling"] then return end
        local p = tonumber(flingBox.Text) or 200
        for _,m in ipairs(getNPCsByName(selectedType)) do pcall(function() flingModel(m,p) end) end
    end)
    btnErase.MouseButton1Click:Connect(function()
        if not selectedType then return end
        if excluded[selectedType] and excluded[selectedType]["Erase"] then return end
        for _,m in ipairs(getNPCsByName(selectedType)) do pcall(function() eraseModel(m) end) end
    end)
    btnVoid.MouseButton1Click:Connect(function()
        if not selectedType then return end
        if excluded[selectedType] and excluded[selectedType]["Void"] then return end
        for _,m in ipairs(getNPCsByName(selectedType)) do pcall(function() voidAway(m) end) end
    end)
    btnAnchor.MouseButton1Click:Connect(function()
        if not selectedType then return end
        if excluded[selectedType] and excluded[selectedType]["Anchor"] then return end
        for _,m in ipairs(getNPCsByName(selectedType)) do pcall(function() toggleAnchor(m) end) end
    end)

    btnWhitelist.MouseButton1Click:Connect(function()
        if not selectedType then return end
        -- show per-type exclusion page (create if needed)
        exclTitle.Text = "Exclusions for: " .. selectedType
        if not excluded[selectedType] then excluded[selectedType] = {} end
        -- ensure the page exists and show it
        local pageEx = typeExclPages[selectedType]
        if pageEx then
            -- hide all other pages then show this one
            for _,p in pairs(typeExclPages) do p.Visible = false end
            pageEx.Visible = true
            ExclusionPanel.Visible = true
        else
            -- create exclusion page for this type (populate EFFECTS)
            local exPage = Instance.new("Frame")
            exPage.Size = UDim2.new(1,0,0, #EFFECTS * 40)
            exPage.BackgroundTransparency = 1
            exPage.Visible = true
            exPage.Parent = exclScroll
            local exLayout = Instance.new("UIListLayout"); exLayout.Parent = exPage; exLayout.SortOrder = Enum.SortOrder.LayoutOrder; exLayout.Padding = UDim.new(0,6)
            for _,eff in ipairs(EFFECTS) do
                local row = Instance.new("Frame"); row.Size = UDim2.new(1,0,0,34); row.BackgroundTransparency = 1; row.Parent = exPage
                local btn = Instance.new("TextButton"); btn.Size = UDim2.new(1,0,1,0); btn.Position = UDim2.new(0,0,0,0);
                btn.BackgroundColor3 = (excluded[selectedType][eff] and Color3.fromRGB(60,180,75) or Color3.fromRGB(58,58,58))
                btn.BorderSizePixel = 0; btn.Font = Enum.Font.Gotham; btn.TextSize = 14; btn.TextColor3 = Color3.new(1,1,1); btn.Text = eff .. (excluded[selectedType][eff] and " (excluded)" or ""); btn.Parent = row
                btn.MouseButton1Click:Connect(function()
                    excluded[selectedType][eff] = not excluded[selectedType][eff]
                    btn.BackgroundColor3 = (excluded[selectedType][eff] and Color3.fromRGB(60,180,75) or Color3.fromRGB(58,58,58))
                    btn.Text = eff .. (excluded[selectedType][eff] and " (excluded)" or "")
                    if eff == "Tracker" and excluded[selectedType][eff] then
                        for _,m in ipairs(getNPCsByName(selectedType)) do removeTrackerFromModel(m) end
                        trackedTypes[selectedType] = nil
                    end
                    if eff == "Speed" and excluded[selectedType][eff] then stopLoop("speed_"..selectedType) end
                    if eff == "JumpPower" and excluded[selectedType][eff] then stopLoop("jp_"..selectedType) end
                end)
            end
            -- hide other exclusion pages and show this one
            for _,p in pairs(typeExclPages) do p.Visible = false end
            typeExclPages[selectedType] = exPage
            ExclusionPanel.Visible = true
            -- ensure layout updates
            exPage:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
                exclScroll.CanvasSize = UDim2.new(0,0,0, exPage.AbsoluteSize.Y + 8)
            end)
        end
    end)

    typeLeftPages[typeName] = page
    return page
end

local function ensureTypeFeaturePage(typeName)
    if typeFeaturePages[typeName] then return typeFeaturePages[typeName] end
    local page = Instance.new("Frame")
    page.Size = UDim2.new(1,0,0, 40 + (#EFFECTS * 40))
    page.BackgroundTransparency = 1
    page.Visible = false
    page.Parent = featScroll
    local layout = Instance.new("UIListLayout"); layout.Parent = page; layout.SortOrder = Enum.SortOrder.LayoutOrder; layout.Padding = UDim.new(0,6)

    -- create a row for each effect (with loop toggle except Tracker)
    for _,eff in ipairs(EFFECTS) do
        local row = Instance.new("Frame"); row.Size = UDim2.new(1,0,0,36); row.BackgroundTransparency = 1; row.Parent = page
        local btn = Instance.new("TextButton"); btn.Size = UDim2.new(0.5,0,1,0); btn.Position = UDim2.new(0,0,0,0); btn.BackgroundColor3 = Color3.fromRGB(58,58,58); btn.BorderSizePixel = 0; btn.Font = Enum.Font.Gotham; btn.TextSize = 14; btn.TextColor3 = Color3.new(1,1,1); btn.Text = eff; btn.Parent = row
        local small
        local input = nil
        local hasTextbox = (eff == "Speed" or eff == "JumpPower" or eff == "HipHeight" or eff == "Heal" or eff == "Fling")
        if eff ~= "Tracker" then
            small = Instance.new("TextButton"); small.Size = UDim2.new(0.48,0,1,0); small.Position = UDim2.new(0.52,6,0,0); small.BackgroundColor3 = Color3.fromRGB(40,40,40); small.BorderSizePixel = 0; small.Font = Enum.Font.Gotham; small.TextSize = 12; small.TextColor3 = Color3.new(1,1,1); small.Text = "Loop: Off"; small.Parent = row
        else
            small = Instance.new("TextLabel"); small.Size = UDim2.new(0.48,0,1,0); small.Position = UDim2.new(0.52,6,0,0); small.BackgroundTransparency = 1; small.Font = Enum.Font.Gotham; small.TextSize = 12; small.TextColor3 = Color3.new(1,1,1); small.Text = "(uses tracker scan)"; small.Parent = row
        end

        if hasTextbox then
            input = Instance.new("TextBox"); input.Size = UDim2.new(0.28,0,1,0); input.Position = UDim2.new(0.52,6,0,0); input.BackgroundColor3 = Color3.fromRGB(50,50,50); input.TextColor3 = Color3.new(1,1,1); input.Font = Enum.Font.Gotham; input.TextSize = 12; input.ClearTextOnFocus = false
            if eff == "Speed" then input.Text = "16"
            elseif eff == "JumpPower" then input.Text = "50"
            elseif eff == "HipHeight" then input.Text = "2"
            elseif eff == "Heal" then input.Text = "5"
            elseif eff == "Fling" then input.Text = tostring(flingBox.Text or "200")
            else input.Text = "" end
            input.Parent = row
            if small and small:IsA("TextButton") then small.Position = UDim2.new(0.8,6,0,0) end
        end

        -- single press
        btn.MouseButton1Click:Connect(function()
            if not selectedType then return end
            local list = getNPCsByName(selectedType)
            if eff == "Kill" then killAllSimultaneousForList(list)
            elseif eff == "Fling" then local p = tonumber((input and input.Text) or flingBox.Text) or 200 for _,m in ipairs(list) do pcall(function() flingModel(m,p) end) end
            elseif eff == "PlatformStand" then for _,m in ipairs(list) do platformStand(m) end
            elseif eff == "Sit" then for _,m in ipairs(list) do makeSit(m) end
            elseif eff == "Anchor" then for _,m in ipairs(list) do toggleAnchor(m) end
            elseif eff == "CancelChase" then for _,m in ipairs(list) do cancelChaseForModel(m) end
            elseif eff == "GetRid" then for _,m in ipairs(list) do local p = getBestPartForModel(m) if p then p.CFrame = CFrame.new(9e37,9e37,9e37) end end
            elseif eff == "Erase" then for _,m in ipairs(list) do eraseModel(m) end
            elseif eff == "Void" then for _,m in ipairs(list) do voidAway(m) end
            elseif eff == "Spasm" then for _,m in ipairs(list) do spasmModel(m) end
            elseif eff == "Jump" then for _,m in ipairs(list) do jumpModel(m) end
            elseif eff == "Void3" then for _,m in ipairs(list) do coroutine.wrap(function() local hrp = getBestPartForModel(m) if hrp then for i=1,20 do pcall(function() hrp.Velocity = Vector3.new(0,-1e7,0) end) task.wait(0.02) end end end)() end
            elseif eff == "Speed" then local v = tonumber(input and input.Text) or 16 for _,m in ipairs(list) do setSpeed(m, v) end
            elseif eff == "JumpPower" then local v = tonumber(input and input.Text) or 50 for _,m in ipairs(list) do setJumpPower(m, v) end
            elseif eff == "HipHeight" then local v = tonumber(input and input.Text) or 2 for _,m in ipairs(list) do setHipHeight(m, v) end
            elseif eff == "Heal" then local v = tonumber(input and input.Text) or 0 for _,m in ipairs(list) do healTickModel(m, v) end
            elseif eff == "HPNaN" then for _,m in ipairs(list) do setHPNaN(m) end
            elseif eff == "Tracker" then
                if excluded[selectedType] and excluded[selectedType]["Tracker"] then return end
                for _,m in ipairs(list) do
                    if trackedNPCs[m] then removeTrackerFromModel(m) else addTrackerToModel(m) end
                end
            end
        end)

        -- loop toggle (not for Tracker)
        if small and small:IsA("TextButton") then
            small.MouseButton1Click:Connect(function()
                if not selectedType then return end
                local key = string.format("%s_%s", eff, selectedType)
                loops[key] = not loops[key]
                small.Text = "Loop: " .. (loops[key] and "On" or "Off")
                if loops[key] then
                    startLoop(key, function()
                        if excluded[selectedType] and excluded[selectedType][eff] then return end
                        local list = getNPCsByName(selectedType)
                        if eff == "Kill" then killAllSimultaneousForList(list)
                        elseif eff == "Fling" then local p = tonumber((input and input.Text) or flingBox.Text) or 200 for _,m in ipairs(list) do pcall(function() flingModel(m,p) end) end
                        elseif eff == "PlatformStand" then for _,m in ipairs(list) do platformStand(m) end
                        elseif eff == "Sit" then for _,m in ipairs(list) do makeSit(m) end
                        elseif eff == "Anchor" then for _,m in ipairs(list) do toggleAnchor(m) end
                        elseif eff == "CancelChase" then for _,m in ipairs(list) do cancelChaseForModel(m) end
                        elseif eff == "GetRid" then for _,m in ipairs(list) do local p = getBestPartForModel(m) if p then p.CFrame = CFrame.new(9e37,9e37,9e37) end end
                        elseif eff == "Erase" then for _,m in ipairs(list) do eraseModel(m) end
                        elseif eff == "Void" then for _,m in ipairs(list) do voidAway(m) end
                        elseif eff == "Spasm" then for _,m in ipairs(list) do spasmModel(m) end
                        elseif eff == "Jump" then for _,m in ipairs(list) do jumpModel(m) end
                        elseif eff == "Void3" then for _,m in ipairs(list) do coroutine.wrap(function() local hrp = getBestPartForModel(m) if hrp then pcall(function() hrp.Velocity = Vector3.new(0,-1e7,0) end) end end)() end
                        elseif eff == "Speed" then local v = tonumber(input and input.Text) or 16 for _,m in ipairs(list) do setSpeed(m, v) end
                        elseif eff == "JumpPower" then local v = tonumber(input and input.Text) or 50 for _,m in ipairs(list) do setJumpPower(m, v) end
                        elseif eff == "HipHeight" then local v = tonumber(input and input.Text) or 2 for _,m in ipairs(list) do setHipHeight(m, v) end
                        elseif eff == "Heal" then local v = tonumber(input and input.Text) or 0 for _,m in ipairs(list) do healTickModel(m, v) end
                        elseif eff == "HPNaN" then for _,m in ipairs(list) do setHPNaN(m) end
                        end
                    end)
                else
                    stopLoop(key)
                end
            end)
        end

        -- focuslost on input applies once
        if input then
            input.FocusLost:Connect(function()
                if not selectedType then return end
                local list = getNPCsByName(selectedType)
                if eff == "Speed" then local v = tonumber(input.Text) if v and not (excluded[selectedType] and excluded[selectedType]["Speed"]) then for _,m in ipairs(list) do setSpeed(m, v) end end
                elseif eff == "JumpPower" then local v = tonumber(input.Text) if v and not (excluded[selectedType] and excluded[selectedType]["JumpPower"]) then for _,m in ipairs(list) do setJumpPower(m, v) end end
                elseif eff == "HipHeight" then local v = tonumber(input.Text) if v and not (excluded[selectedType] and excluded[selectedType]["HipHeight"]) then for _,m in ipairs(list) do setHipHeight(m, v) end end
                elseif eff == "Heal" then local v = tonumber(input.Text) if v and not (excluded[selectedType] and excluded[selectedType]["Heal"]) then for _,m in ipairs(list) do healTickModel(m, v) end end
                elseif eff == "Fling" then local p = tonumber(input.Text) or tonumber(flingBox.Text) or 200 for _,m in ipairs(list) do pcall(function() flingModel(m, p) end) end
                end
            end)
        end
    end

    -- when the page absolute size changes, update the container canvas size
    page:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
        featScroll.CanvasSize = UDim2.new(0,0,0, page.AbsoluteSize.Y + 8)
    end)

    typeFeaturePages[typeName] = page
    return page
end

-- show a type: hides previous pages, stops previous type loops, shows cached pages (no creation-destruction)
local function showTypeUI(typeName, count)
    if prevSelectedType and prevSelectedType ~= typeName then
        stopAllTypeLoops(prevSelectedType)
    end
    prevSelectedType = typeName
    selectedType = typeName

    -- hide all left pages, show the one for this type
    for _,p in pairs(typeLeftPages) do p.Visible = false end
    leftPanel.Visible = true
    leftTitle.Text = "Type: " .. typeName .. " [" .. tostring(count) .. "]"
    local leftP = ensureTypeLeftPage(typeName)
    leftP.Visible = true

    -- hide all feature pages, show this type's feature page
    for _,p in pairs(typeFeaturePages) do p.Visible = false end
    local featP = ensureTypeFeaturePage(typeName)
    featP.Visible = true
    featTitle.Text = "Features: " .. typeName
    FeaturesPanel.Visible = true

    -- ensure exclusion panel page exists/hides others
    for _,p in pairs(typeExclPages) do p.Visible = false end
    if typeExclPages[typeName] then
        typeExclPages[typeName].Visible = false -- default hidden until user opens whitelist for that type
    end
    ExclusionPanel.Visible = false
end

-- REBUILD grouped list (selecting type shows cached pages; pages created once)
local function rebuildGroupedList()
    for _, child in ipairs(groupScroll:GetChildren()) do if child:IsA("Frame") then child:Destroy() end end
    local counts = {}
    for model,_ in pairs(NPCs) do
        if model and model.Parent and isNPC(model) then
            counts[model.Name] = (counts[model.Name] or 0) + 1
        end
    end
    for name, count in pairs(counts) do
        local frame = Instance.new("Frame")
        frame.Size = UDim2.new(1,0,0,34)
        frame.BackgroundTransparency = 1
        frame.Parent = groupScroll
        local btn = Instance.new("TextButton")
        btn.Size = UDim2.new(0.6,0,1,0)
        btn.Position = UDim2.new(0,0,0,0)
        btn.BackgroundColor3 = Color3.fromRGB(58,58,58)
        btn.BorderSizePixel = 0
        btn.Font = Enum.Font.Gotham
        btn.TextSize = 14
        btn.TextColor3 = Color3.new(1,1,1)
        btn.Text = string.format("%s(s) [%d]", name, count)
        btn.Parent = frame
        local info = Instance.new("TextLabel")
        info.Size = UDim2.new(0.38, 0, 1, 0)
        info.Position = UDim2.new(0.62, 6, 0, 0)
        info.BackgroundTransparency = 1
        info.Font = Enum.Font.Gotham
        info.TextSize = 12
        info.TextColor3 = Color3.new(1,1,1)
        info.Text = "Select"
        info.Parent = frame

        btn.MouseButton1Click:Connect(function()
            showTypeUI(name, count)
        end)
    end
end

-- UI bindings for main controls (unchanged behavior) - loops, etc.
killBtn.MouseButton1Click:Connect(function()
    killAllSimultaneousForList(getNPCsArray())
end)
killLoopBtn.MouseButton1Click:Connect(function()
    loops.killAll = not loops.killAll
    killLoopBtn.Text = "Loop: " .. (loops.killAll and "On" or "Off")
    if loops.killAll then startLoop("killAll", function() killAllSimultaneousForList(getNPCsArray()) end) else stopLoop("killAll") end
end)

flingBtn.MouseButton1Click:Connect(function()
    local p = tonumber(flingBox.Text) or 200
    for _,m in ipairs(getNPCsArray()) do pcall(function() flingModel(m,p) end) end
end)
flingLoopBtn.MouseButton1Click:Connect(function()
    loops.flingAll = not loops.flingAll
    flingLoopBtn.Text = "Loop: " .. (loops.flingAll and "On" or "Off")
    if loops.flingAll then startLoop("flingAll", function() local p = tonumber(flingBox.Text) or 200 for _,m in ipairs(getNPCsArray()) do pcall(function() flingModel(m,p) end) end end) else stopLoop("flingAll") end
end)

psBtn.MouseButton1Click:Connect(function() for _,m in ipairs(getNPCsArray()) do platformStand(m) end end)
psLoopBtn.MouseButton1Click:Connect(function()
    loops.ps = not loops.ps
    psLoopBtn.Text = "Loop: " .. (loops.ps and "On" or "Off")
    if loops.ps then startLoop("ps", function() for _,m in ipairs(getNPCsArray()) do platformStand(m) end end) else stopLoop("ps") end
end)

sitBtn.MouseButton1Click:Connect(function() for _,m in ipairs(getNPCsArray()) do makeSit(m) end end)
sitLoopBtn.MouseButton1Click:Connect(function()
    loops.sit = not loops.sit
    sitLoopBtn.Text = "Loop: " .. (loops.sit and "On" or "Off")
    if loops.sit then startLoop("sit", function() for _,m in ipairs(getNPCsArray()) do makeSit(m) end end) else stopLoop("sit") end
end)

anchorBtn.MouseButton1Click:Connect(function() for _,m in ipairs(getNPCsArray()) do toggleAnchor(m) end end)
anchorLoopBtn.MouseButton1Click:Connect(function()
    loops.anchor = not loops.anchor
    anchorLoopBtn.Text = "Loop: " .. (loops.anchor and "On" or "Off")
    if loops.anchor then startLoop("anchor", function() for _,m in ipairs(getNPCsArray()) do toggleAnchor(m) end end) else stopLoop("anchor") end
end)

cancelChaseBtn.MouseButton1Click:Connect(function()
    cancelChaseEnabled = not cancelChaseEnabled
    cancelChaseBtn.Text = "Toggle Cancel-Chase (Enabled: "..tostring(cancelChaseEnabled)..")"
end)

getRidBtn.MouseButton1Click:Connect(function()
    for _,m in ipairs(getNPCsArray()) do
        if isAllowed(m, "GetRid") then
            local hrp = getBestPartForModel(m)
            if hrp and player.Character and player.Character.PrimaryPart then
                local playerPos = player.Character.PrimaryPart.Position
                local dist = (hrp.Position - playerPos).Magnitude
                local closer = true
                for _,plr in ipairs(Players:GetPlayers()) do
                    if plr ~= player and plr.Character and plr.Character.PrimaryPart then
                        local d = (hrp.Position - plr.Character.PrimaryPart.Position).Magnitude
                        if d < dist then closer = false break end
                    end
                end
                if closer then pcall(function() hrp.CFrame = CFrame.new(9e37,9e37,9e37) end) end
            end
        end
    end
end)
getRidLoop.MouseButton1Click:Connect(function()
    loops.getRid = not loops.getRid
    getRidLoop.Text = "Loop: "..(loops.getRid and "On" or "Off")
    if loops.getRid then startLoop("getRid", function() for _,m in ipairs(getNPCsArray()) do pcall(function() if isAllowed(m,"GetRid") then local hrp = getBestPartForModel(m) if hrp then hrp.CFrame = CFrame.new(9e37,9e37,9e37) end end end) end end) else stopLoop("getRid") end
end)

eraseBtn.MouseButton1Click:Connect(function() for _,m in ipairs(getNPCsArray()) do eraseModel(m) end end)
eraseLoopBtn.MouseButton1Click:Connect(function() loops.erase = not loops.erase; eraseLoopBtn.Text = "Loop: "..(loops.erase and "On" or "Off"); if loops.erase then startLoop("erase", function() for _,m in ipairs(getNPCsArray()) do eraseModel(m) end end) else stopLoop("erase") end end)

voidBtn.MouseButton1Click:Connect(function() for _,m in ipairs(getNPCsArray()) do voidAway(m) end end)
voidLoopBtn.MouseButton1Click:Connect(function() loops.void = not loops.void; voidLoopBtn.Text = "Loop: "..(loops.void and "On" or "Off"); if loops.void then startLoop("void", function() for _,m in ipairs(getNPCsArray()) do voidAway(m) end end) else stopLoop("void") end end)

spasmBtn.MouseButton1Click:Connect(function() for _,m in ipairs(getNPCsArray()) do spasmModel(m) end end)
spasmLoopBtn.MouseButton1Click:Connect(function() loops.spasm = not loops.spasm; spasmLoopBtn.Text = "Loop: "..(loops.spasm and "On" or "Off"); if loops.spasm then startLoop("spasm", function() for _,m in ipairs(getNPCsArray()) do spasmModel(m) end end) else stopLoop("spasm") end end)

jumpBtn.MouseButton1Click:Connect(function() for _,m in ipairs(getNPCsArray()) do jumpModel(m) end end)
jumpLoopBtn.MouseButton1Click:Connect(function() loops.jump = not loops.jump; jumpLoopBtn.Text = "Loop: "..(loops.jump and "On" or "Off"); if loops.jump then startLoop("jump", function() for _,m in ipairs(getNPCsArray()) do jumpModel(m) end end) else stopLoop("jump") end end)

void3Btn.MouseButton1Click:Connect(function()
    for _,m in ipairs(getNPCsArray()) do
        if isAllowed(m,"Void3") then
            coroutine.wrap(function()
                local hrp = getBestPartForModel(m)
                if hrp then
                    for i=1,20 do pcall(function() hrp.Velocity = Vector3.new(0,-1e7,0) end) task.wait(0.02) end
                end
            end)()
        end
    end
end)
void3LoopBtn.MouseButton1Click:Connect(function() loops.void3 = not loops.void3; void3LoopBtn.Text = "Loop: "..(loops.void3 and "On" or "Off"); if loops.void3 then startLoop("void3", function() for _,m in ipairs(getNPCsArray()) do if isAllowed(m,"Void3") then coroutine.wrap(function() local hrp = getBestPartForModel(m) if hrp then pcall(function() hrp.Velocity = Vector3.new(0,-1e7,0) end) end end)() end end end) else stopLoop("void3") end end)

hipLoop.MouseButton1Click:Connect(function() loops.hip = not loops.hip; hipLoop.Text = "Loop: "..(loops.hip and "On" or "Off"); if loops.hip then startLoop("hip", function() local v = tonumber(hipBox.Text) or 2 for _,m in ipairs(getNPCsArray()) do setHipHeight(m, v) end end) else stopLoop("hip") end end)

-- Advanced: global speed & jump wiring
speedGlobalLoop.MouseButton1Click:Connect(function()
    loops["speed_global"] = not loops["speed_global"]
    speedGlobalLoop.Text = "Loop: "..(loops["speed_global"] and "On" or "Off")
    if loops["speed_global"] then
        startLoop("speed_global", function()
            local v = tonumber(speedGlobalBox.Text) or 16
            for _,m in ipairs(getNPCsArray()) do setSpeed(m, v) end
        end)
    else
        stopLoop("speed_global")
    end
end)
speedGlobalBox.FocusLost:Connect(function()
    local v = tonumber(speedGlobalBox.Text)
    if v then for _,m in ipairs(getNPCsArray()) do setSpeed(m, v) end end
end)

jumpGlobalLoop.MouseButton1Click:Connect(function()
    loops["jump_global"] = not loops["jump_global"]
    jumpGlobalLoop.Text = "Loop: "..(loops["jump_global"] and "On" or "Off")
    if loops["jump_global"] then
        startLoop("jump_global", function()
            local v = tonumber(jumpGlobalBox.Text) or 50
            for _,m in ipairs(getNPCsArray()) do setJumpPower(m, v) end
        end)
    else
        stopLoop("jump_global")
    end
end)
jumpGlobalBox.FocusLost:Connect(function()
    local v = tonumber(jumpGlobalBox.Text)
    if v then for _,m in ipairs(getNPCsArray()) do setJumpPower(m, v) end end
end)

-- HEARTBEAT: scanning, cancel-chase, tracker updates
do
    local acc = 0
    RunService.Heartbeat:Connect(function(dt)
        acc = acc + dt
        if acc >= SCAN_INTERVAL then
            acc = 0
            scanAddNPCs()
            cleanNPCs()
            CounterLabel.Text = "NPCs detected: " .. tostring(#getNPCsArray())
            rebuildGroupedList()
            -- auto-add trackers for trackedTypes
            for t,_ in pairs(trackedTypes) do
                for _,m in ipairs(getNPCsByName(t)) do
                    if not trackedNPCs[m] and (not excluded[t] or not excluded[t]["Tracker"]) then addTrackerToModel(m) end
                end
            end
        end
        if cancelChaseEnabled then
            for model,_ in pairs(NPCs) do
                if model and model.Parent and isNPC(model) then pcall(function() cancelChaseForModel(model) end) end
            end
        end
        updateAllTrackers()
    end)
end

-- Tabs show/hide
local function showTab(name)
    controlsFrame.Visible = false
    utilitiesFrame.Visible = false
    advancedFrame.Visible = false
    whitelistFrame.Visible = false
    leftPanel.Visible = false
    FeaturesPanel.Visible = false
    ExclusionPanel.Visible = false
    if name == "Controls" then controlsFrame.Visible = true
    elseif name == "Utilities" then utilitiesFrame.Visible = true
    elseif name == "Advanced" then advancedFrame.Visible = true
    elseif name == "Whitelist" then whitelistFrame.Visible = true; rebuildGroupedList() end
end
tabControlsBtn.MouseButton1Click:Connect(function() showTab("Controls") end)
tabUtilitiesBtn.MouseButton1Click:Connect(function() showTab("Utilities") end)
tabAdvancedBtn.MouseButton1Click:Connect(function() showTab("Advanced") end)
tabWhitelistBtn.MouseButton1Click:Connect(function() showTab("Whitelist") end)

-- SMALL TOGGLE open/close (only toggles Visible; does not destroy anything)
local isOpen = false
SmallToggle.MouseButton1Click:Connect(function()
    isOpen = not isOpen
    if isOpen then
        SmallToggle.Text = "X"
        MainFrame.Visible = true
        Content.Visible = true
        local targetSize = UDim2.new(0, GUI_WIDTH, 0, GUI_HEIGHT)
        TweenService:Create(MainFrame, TweenInfo.new(0.22, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), { Size = targetSize }):Play()
        showTab("Controls")
    else
        SmallToggle.Text = "NPC"
        -- hide only, preserve UI & pages (no Destroy)
        MainFrame.Visible = false
        Content.Visible = false
        ExclusionPanel.Visible = false
        FeaturesPanel.Visible = false
        leftPanel.Visible = false
    end
end)

print("[UnifiedNPCGUI v5] Loaded. Per-type UI cached and persistent; deselection stops per-type loops; hide uses Visible=false only.")
