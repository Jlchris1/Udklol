-- Gui to Lua
-- Version: 3.2

-- Instances:

local maingui = Instance.new("ScreenGui")
local mainframe = Instance.new("ScrollingFrame")
local coolpicktool = Instance.new("TextButton")
local dmgsoundspammer = Instance.new("TextButton")
local floatpt2 = Instance.new("TextButton")
local chrisgui = Instance.new("TextButton")
local instantkillv3 = Instance.new("TextButton")
local turnoffspamsound = Instance.new("TextButton")
local v1 = Instance.new("TextButton")
local v3loop = Instance.new("TextButton")
local instakillv3 = Instance.new("TextButton")
local hyperloop1 = Instance.new("TextButton")
local severeanti = Instance.new("TextButton")
local armanlegui = Instance.new("TextButton")
local anvilkillall = Instance.new("TextButton")
local dmgsfxspamall = Instance.new("TextButton")
local stopspamsfxall = Instance.new("TextButton")
local toggle = Instance.new("TextButton")

--Properties:

maingui.Name = "main gui"
maingui.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")
maingui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
maingui.ResetOnSpawn = false

mainframe.Name = "mainframe"
mainframe.Parent = maingui
mainframe.Active = true
mainframe.BackgroundColor3 = Color3.fromRGB(0, 85, 255)
mainframe.BorderColor3 = Color3.fromRGB(0, 0, 0)
mainframe.BorderSizePixel = 0
mainframe.Position = UDim2.new(0.647574127, 0, 0.276063085, 0)
mainframe.Size = UDim2.new(0, 255, 0, 218)
mainframe.CanvasPosition = Vector2.new(0, 600)
mainframe.CanvasSize = UDim2.new(0, 0, 4, 0)

coolpicktool.Name = "cool pick tool"
coolpicktool.Parent = mainframe
coolpicktool.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
coolpicktool.BorderColor3 = Color3.fromRGB(0, 0, 0)
coolpicktool.BorderSizePixel = 0
coolpicktool.Size = UDim2.new(0, 200, 0, 50)
coolpicktool.Font = Enum.Font.SourceSansBold
coolpicktool.Text = "get cool auopick tool (inf range)"
coolpicktool.TextColor3 = Color3.fromRGB(0, 0, 0)
coolpicktool.TextSize = 16.000

dmgsoundspammer.Name = "dmg sound spammer"
dmgsoundspammer.Parent = mainframe
dmgsoundspammer.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
dmgsoundspammer.BorderColor3 = Color3.fromRGB(0, 0, 0)
dmgsoundspammer.BorderSizePixel = 0
dmgsoundspammer.Position = UDim2.new(0, 0, 0.25, 0)
dmgsoundspammer.Size = UDim2.new(0, 200, 0, 50)
dmgsoundspammer.Font = Enum.Font.SourceSansBold
dmgsoundspammer.Text = "spam dmg sounds"
dmgsoundspammer.TextColor3 = Color3.fromRGB(0, 0, 0)
dmgsoundspammer.TextSize = 30.000

floatpt2.Name = "float pt 2"
floatpt2.Parent = mainframe
floatpt2.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
floatpt2.BorderColor3 = Color3.fromRGB(0, 0, 0)
floatpt2.BorderSizePixel = 0
floatpt2.Position = UDim2.new(0, 0, 0.349999994, 0)
floatpt2.Size = UDim2.new(0, 200, 0, 50)
floatpt2.Font = Enum.Font.SourceSansBold
floatpt2.Text = "v1 pt 2"
floatpt2.TextColor3 = Color3.fromRGB(0, 0, 0)
floatpt2.TextSize = 20.000

chrisgui.Name = "chris gui"
chrisgui.Parent = mainframe
chrisgui.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
chrisgui.BorderColor3 = Color3.fromRGB(0, 0, 0)
chrisgui.BorderSizePixel = 0
chrisgui.Position = UDim2.new(0, 0, 0.150000006, 0)
chrisgui.Size = UDim2.new(0, 200, 0, 50)
chrisgui.Font = Enum.Font.SourceSansBold
chrisgui.Text = "chris gui"
chrisgui.TextColor3 = Color3.fromRGB(0, 0, 0)
chrisgui.TextSize = 40.000

instantkillv3.Name = "instant kill v3"
instantkillv3.Parent = mainframe
instantkillv3.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
instantkillv3.BorderColor3 = Color3.fromRGB(0, 0, 0)
instantkillv3.BorderSizePixel = 0
instantkillv3.Position = UDim2.new(0, 0, 0.649999976, 0)
instantkillv3.Size = UDim2.new(0, 200, 0, 49)
instantkillv3.Font = Enum.Font.SourceSansBold
instantkillv3.Text = "v3 pt2"
instantkillv3.TextColor3 = Color3.fromRGB(0, 0, 0)
instantkillv3.TextSize = 25.000

turnoffspamsound.Name = "turn off spam sound"
turnoffspamsound.Parent = mainframe
turnoffspamsound.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
turnoffspamsound.BorderColor3 = Color3.fromRGB(0, 0, 0)
turnoffspamsound.BorderSizePixel = 0
turnoffspamsound.Position = UDim2.new(0, 0, 0.300000012, 0)
turnoffspamsound.Size = UDim2.new(0, 200, 0, 50)
turnoffspamsound.Font = Enum.Font.SourceSansBold
turnoffspamsound.Text = "turn off spam sounds"
turnoffspamsound.TextColor3 = Color3.fromRGB(0, 0, 0)
turnoffspamsound.TextSize = 20.000

v1.Name = "v1"
v1.Parent = mainframe
v1.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
v1.BorderColor3 = Color3.fromRGB(0, 0, 0)
v1.BorderSizePixel = 0
v1.Position = UDim2.new(0, 0, 0.400000006, 0)
v1.Size = UDim2.new(0, 200, 0, 50)
v1.Font = Enum.Font.SourceSansBold
v1.Text = "v1 loop"
v1.TextColor3 = Color3.fromRGB(0, 0, 0)
v1.TextSize = 27.000

v3loop.Name = "v3 loop"
v3loop.Parent = mainframe
v3loop.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
v3loop.BorderColor3 = Color3.fromRGB(0, 0, 0)
v3loop.BorderSizePixel = 0
v3loop.Position = UDim2.new(-0, 0, 0.449999988, 0)
v3loop.Size = UDim2.new(0, 200, 0, 50)
v3loop.Font = Enum.Font.SourceSansBold
v3loop.Text = "v3"
v3loop.TextColor3 = Color3.fromRGB(0, 0, 0)
v3loop.TextSize = 25.000

instakillv3.Name = "insta kill v3"
instakillv3.Parent = mainframe
instakillv3.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
instakillv3.BorderColor3 = Color3.fromRGB(0, 0, 0)
instakillv3.BorderSizePixel = 0
instakillv3.Position = UDim2.new(0, 0, 0.200000003, 0)
instakillv3.Size = UDim2.new(0, 200, 0, 50)
instakillv3.Font = Enum.Font.SourceSansBold
instakillv3.Text = "insta kill v3"
instakillv3.TextColor3 = Color3.fromRGB(0, 0, 0)
instakillv3.TextSize = 23.000

hyperloop1.Name = "hyperloop1"
hyperloop1.Parent = mainframe
hyperloop1.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
hyperloop1.BorderColor3 = Color3.fromRGB(0, 0, 0)
hyperloop1.BorderSizePixel = 0
hyperloop1.Position = UDim2.new(0, 0, 0.5, 0)
hyperloop1.Size = UDim2.new(0, 200, 0, 50)
hyperloop1.Font = Enum.Font.SourceSansBold
hyperloop1.Text = "hyper loop buttons"
hyperloop1.TextColor3 = Color3.fromRGB(0, 0, 0)
hyperloop1.TextSize = 20.000

severeanti.Name = "severe anti"
severeanti.Parent = mainframe
severeanti.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
severeanti.BorderColor3 = Color3.fromRGB(0, 0, 0)
severeanti.BorderSizePixel = 0
severeanti.Position = UDim2.new(0, 0, 0.0500000007, 0)
severeanti.Size = UDim2.new(0, 200, 0, 50)
severeanti.Font = Enum.Font.SourceSansBold
severeanti.Text = "Launch anti gui"
severeanti.TextColor3 = Color3.fromRGB(255, 255, 0)
severeanti.TextSize = 25.000

armanlegui.Name = "arm anle gui"
armanlegui.Parent = mainframe
armanlegui.BackgroundColor3 = Color3.fromRGB(255, 85, 255)
armanlegui.BorderColor3 = Color3.fromRGB(0, 0, 0)
armanlegui.BorderSizePixel = 0
armanlegui.Position = UDim2.new(0, 0, 0.100000001, 0)
armanlegui.Size = UDim2.new(0, 200, 0, 50)
armanlegui.Font = Enum.Font.SourceSansBold
armanlegui.Text = "arm angle positions gui"
armanlegui.TextColor3 = Color3.fromRGB(0, 0, 0)
armanlegui.TextSize = 23.000

anvilkillall.Name = "anvil kill all"
anvilkillall.Parent = mainframe
anvilkillall.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
anvilkillall.BorderColor3 = Color3.fromRGB(0, 0, 0)
anvilkillall.BorderSizePixel = 0
anvilkillall.Position = UDim2.new(0, 0, 0.699999988, 0)
anvilkillall.Size = UDim2.new(0, 200, 0, 50)
anvilkillall.Font = Enum.Font.SourceSansBold
anvilkillall.Text = "unfinished anvil script"
anvilkillall.TextColor3 = Color3.fromRGB(0, 0, 0)
anvilkillall.TextSize = 26.000

dmgsfxspamall.Name = "dmg sfx spam all"
dmgsfxspamall.Parent = mainframe
dmgsfxspamall.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
dmgsfxspamall.BorderColor3 = Color3.fromRGB(0, 0, 0)
dmgsfxspamall.BorderSizePixel = 0
dmgsfxspamall.Position = UDim2.new(0, 0, 0.75, 0)
dmgsfxspamall.Size = UDim2.new(0, 200, 0, 50)
dmgsfxspamall.Font = Enum.Font.SourceSansBold
dmgsfxspamall.Text = "dmg spam sound all"
dmgsfxspamall.TextColor3 = Color3.fromRGB(0, 0, 0)
dmgsfxspamall.TextSize = 24.000

stopspamsfxall.Name = "stop spam sfx all"
stopspamsfxall.Parent = mainframe
stopspamsfxall.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
stopspamsfxall.BorderColor3 = Color3.fromRGB(0, 0, 0)
stopspamsfxall.BorderSizePixel = 0
stopspamsfxall.Position = UDim2.new(0, 0, 0.800000012, 0)
stopspamsfxall.Size = UDim2.new(0, 200, 0, 50)
stopspamsfxall.Font = Enum.Font.SourceSansBold
stopspamsfxall.Text = "stop sfx spam all"
stopspamsfxall.TextColor3 = Color3.fromRGB(0, 0, 0)
stopspamsfxall.TextSize = 26.000

toggle.Name = "toggle"
toggle.Parent = maingui
toggle.BackgroundColor3 = Color3.fromRGB(0, 0, 255)
toggle.BorderColor3 = Color3.fromRGB(0, 0, 0)
toggle.BorderSizePixel = 0
toggle.Position = UDim2.new(0.493935317, 0, 0.037722908, 0)
toggle.Size = UDim2.new(0, 53, 0, 50)
toggle.Font = Enum.Font.SourceSansBold
toggle.Text = "X"
toggle.TextColor3 = Color3.fromRGB(0, 0, 0)
toggle.TextSize = 30.000

-- Scripts:

local function NQKXH_fake_script() -- coolpicktool.Script 
	local script = Instance.new('Script', coolpicktool)

	function Click(mouse)
	
		local LocalPlayer = game.Players.LocalPlayer
		local rp = LocalPlayer.Character.HumanoidRootPart
		local tool = Instance.new("Tool", LocalPlayer.Backpack)
		local mouse = LocalPlayer:GetMouse()
		local userInputService = game:GetService("UserInputService")
	
		tool.Name = "AutoPick"
		tool.RequiresHandle = false
	
		local function onQPressed()
			pcall(function()
				if not LocalPlayer.Character.Picked.Value then
					LocalPlayer.Character.Picking:FireServer(mouse.Target, mouse.Hit.p)
				else
					LocalPlayer.Character.PuttingDown:FireServer()
				end
			end)
		end
	
		tool.Activated:Connect(function()
			onQPressed()
		end)
	
		userInputService.InputBegan:Connect(function(input, gameProcessedEvent)
			if input.KeyCode == Enum.KeyCode.Q and not gameProcessedEvent then
				onQPressed()
			end
		end)
	
	end
	
	
	script.Parent.MouseButton1Down:connect(Click)
end
coroutine.wrap(NQKXH_fake_script)()
local function FFNXRSP_fake_script() -- dmgsoundspammer.Script 
	local script = Instance.new('Script', dmgsoundspammer)

	function Click(mouse)
	_G.toggle = true
	
	while _G.toggle do
	wait()
		game:GetService("Players").LocalPlayer.Character.Damage:FireServer()
		game:GetService("Players").LocalPlayer.Character.Damage:FireServer()
		game:GetService("Players").LocalPlayer.Character.Damage:FireServer()
	end
	end
	
	
	script.Parent.MouseButton1Down:connect(Click)
end
coroutine.wrap(FFNXRSP_fake_script)()
local function LPEOIKF_fake_script() -- floatpt2.Script 
	local script = Instance.new('Script', floatpt2)

	function Click(mouse)
	
		local prefix = '-'
	
		repeat wait() until game:IsLoaded()
		local plrs = game:GetService("Players")
		local plr = plrs.LocalPlayer
		local loopAll = false
		local whitelist = {}
		local loopKill = {}
	
		local function findPlayer(Target)
			if game:GetService("Players"):FindFirstChild(Target) then
				return game:GetService("Players"):FindFirstChild(Target)
			else
				if Target ~= nil and Target ~= "" and Target ~= " " and Target then
					local name = Target
					local found = false
					for _, v in pairs(game:GetService("Players"):GetPlayers()) do
						if not found and (v.Name:lower():sub(1, #name) == name:lower() or v.DisplayName:lower():sub(1, #name) == name:lower()) then
							name = v
							found = true
						end
					end
					if name ~= nil and name ~= Target then
						return name
					end
				end
			end
		end
	
		plr.Chatted:Connect(function(msg)
			msg = msg:lower():split(" ")
			if msg[1] == "/e" then
				for i, v in next, msg do
					msg[i] = msg[i + 1]
				end
			end
			if msg[1] == prefix .. "lol" or (msg[1] == prefix .. "loopill" and msg[2] == "all") then
				loopAll = true
				for _, v in ipairs(plrs:GetPlayers()) do
					if v ~= plr and not table.find(whitelist, v.Name) then
						local rightArm = v.Character:FindFirstChild("Right Arm")
						if rightArm then
							rightArm:Destroy()
							local arm = Instance.new("Part")
							arm.Size = Vector3.new(1, 3, 1) -- Adjust size if needed
							arm.Position = v.Character.Torso.Position + Vector3.new(2, 0, 0) -- Adjust position if needed
							arm.Anchored = false
							arm.CanCollide = false
							arm.Color = Color3.new(1, 0, 0) -- Adjust color if needed
							arm.Parent = game.Workspace -- Make sure the arm is visible
						end
					end
				end
			elseif msg[1] == prefix .. "kill" and findPlayer(msg[2]) then
				table.insert(loopKill, findPlayer(msg[2]).Name)
				local targetPlayer = findPlayer(msg[2])
				local rightArm = targetPlayer.Character:FindFirstChild("Right Arm")
				if rightArm then
					rightArm:Destroy()
					local arm = Instance.new("Part")
					arm.Size = Vector3.new(1, 3, 1) -- Adjust size if needed
					arm.Position = targetPlayer.Character.Torso.Position + Vector3.new(2, 0, 0) -- Adjust position if needed
					arm.Anchored = false
					arm.CanCollide = false
					arm.Color = Color3.new(1, 0, 0) -- Adjust color if needed
					arm.Parent = game.Workspace -- Make sure the arm is visible
				end
			elseif msg[1] == prefix .. "wl" and findPlayer(msg[2]) and not table.find(whitelist, findPlayer(msg[2]).Name) then
				table.insert(whitelist, findPlayer(msg[2]).Name)
			elseif msg[1] == prefix .. "bl" and findPlayer(msg[2]) and table.find(whitelist, findPlayer(msg[2]).Name) then
				table.remove(whitelist, findPlayer(msg[2]).Name)
			elseif msg[1] == prefix .. "rc" then
				table.clear(loopKill)
				loopAll = false
				pcall(function()
					plr.Character.PuttingDown:FireServer()
				end)
			end
		end)
	
		while true do
			wait(0.1)
			if loopAll then
				for _, v in next, plrs:GetPlayers() do
					if v ~= plr and not table.find(whitelist, v.Name) then
						pcall(function()
							-- Launch player randomly
							local respawnPosition
							local rand = math.random(1, 4)
							if rand == 1 then
								-- Void
								respawnPosition = Vector3.new(math.random(-50, 50), 1000, math.random(-50, 50)) -- Adjust Y position to make them float
							elseif rand == 2 then
								-- Sideways
								respawnPosition = Vector3.new(math.random(-50, 50), 200, math.random(-50, 50))
							elseif rand == 3 then
								-- Sky
								respawnPosition = Vector3.new(math.random(-50, 50), 500, math.random(-50, 50))
							else
								-- Space
								respawnPosition = Vector3.new(math.random(-50, 50), 1000, math.random(-50, 50)) -- Adjust Y position to make them float
							end
							v.Character:SetPrimaryPartCFrame(CFrame.new(respawnPosition))
							wait(0.0) -- Adjust the wait time if necessary
							plr.Character.Picking:FireServer(v.Character.RightArm, Vector3.new(9e37, -9e37, 9e37)) -- Adjust the force to a lower value
							wait(0.05) -- Adjust the wait time between picking and putting down
							plr.Character.PuttingDown:FireServer()
						end)
					end
				end
			end
			if #loopKill > 0 then
				for _, v in next, plrs:GetPlayers() do
					if table.find(loopKill, v.Name) then
						pcall(function()
							local accs = v.Character:FindFirstChildOfClass("Accessory")
							if accs then
								if accs:FindFirstChild("Handle") then
									plr.Character.Picking:FireServer(accs.Handle, Vector3.new(9e37, -9e37, 9e37)) -- Adjust the force to a lower value
								elseif accs:IsA("BasePart") then
									plr.Character.Picking:FireServer(accs, Vector3.new(9e37, -9e37, 9e37)) -- Adjust the force to a lower value
								end
							else
								plr.Character.Picking:FireServer(v.Character.RightArm, Vector3.new(9e37, -9e37, 9e37)) -- Adjust the force to a lower value
								wait(0.4) -- Adjust the wait time between picking and putting down
								plr.Character.PuttingDown:FireServer()
							end
						end)
					end
				end
			end
		end
	
		plr.CharacterAdded:Connect(function(character)
			-- Fling player randomly upon respawn
			local respawnPosition
			local rand = math.random(1, 4)
			if rand == 1 then
				-- Void
				respawnPosition = Vector3.new(math.random(-50, 50), 1000, math.random(-50, 50)) -- Adjust Y position to make them float
			elseif rand == 2 then
				-- Sideways
				respawnPosition = Vector3.new(math.random(-50, 50), 200, math.random(-50, 50))
			elseif rand == 3 then
				-- Sky
				respawnPosition = Vector3.new(math.random(-50, 50), 500, math.random(-50, 50))
			else
				-- Space
				respawnPosition = Vector3.new(math.random(-50, 50), 1000, math.random(-50, 50)) -- Adjust Y position to make them float
			end
			character:SetPrimaryPartCFrame(CFrame.new(respawnPosition))
		end)
	
	end
	
	
	script.Parent.MouseButton1Down:connect(Click)
end
coroutine.wrap(LPEOIKF_fake_script)()
local function SGBZAAH_fake_script() -- chrisgui.Script 
	local script = Instance.new('Script', chrisgui)

	function Click(mouse)
	
		loadstring(game:HttpGet(('https://raw.githubusercontent.com/Jlchris1/hftdfjfhdghjfhd/main/chris%20gui'),true))()
	
	end
	
	
	script.Parent.MouseButton1Down:connect(Click)
end
coroutine.wrap(SGBZAAH_fake_script)()
local function UUGWFW_fake_script() -- instantkillv3.Script 
	local script = Instance.new('Script', instantkillv3)

	function Click(mouse)
	
		local prefix = '+'
	
		repeat wait() until game:IsLoaded()
		local plrs = game:GetService("Players")
		local plr = plrs.LocalPlayer
		local loopAll = false
		local loopSinglePlayer = nil
		local whitelist = {"bamned_alt3"}  -- Username to avoid from getting looped
		local loopKill = {}
	
		local UserInputService = game:GetService("UserInputService")
	
		local function shouldAvoid(player)
			return table.find(whitelist, player.Name) ~= nil
		end
	
		local function isWhitelisted(player)
			return table.find(whitelist, player.Name) ~= nil
		end
	
		local function handleRightArm(v)
			local rightArm = v.Character:FindFirstChild("Right Arm")
			if rightArm then
				rightArm:Destroy()
				local arm = Instance.new("Part")
				arm.Size = Vector3.new(1, 3, 1) -- Adjust size if needed
				arm.Position = v.Character.Torso.Position + Vector3.new(2, 0, 0) -- Adjust position if needed
				arm.Anchored = false
				arm.CanCollide = false
				arm.Color = Color3.new(1, 0, 0) -- Adjust color if needed
				arm.Parent = game.Workspace -- Make sure the arm is visible
			end
		end
	
		-- Function to apply changes to a player character
		local function ApplyChangesToPlayer(player)
			-- Check if the player's character exists
			local character = player.Character
			if character and not shouldAvoid(player) then
				-- Apply the desired changes to the ArmAngleChange remote event
				local armAngleChange = character:FindFirstChild("ArmAngleChange")
				if armAngleChange then
					armAngleChange:FireServer(CFrame.new(9e37, -9e37, 9e37))
				end
	
				-- Apply the desired changes to the HeadWaist
				local HeadWaist = character:FindFirstChild("HeadWaist")
				if HeadWaist then
					HeadWaist:FireServer(CFrame.new(9e37, -9e37, 9e37))
				end
	
				-- Apply the desired changes to the HeadAngleChange remote event
				local headAngleChange = character:FindFirstChild("HeadAngleChange")
				if headAngleChange then
					headAngleChange:FireServer(CFrame.new(9e37, -9e37, 9e37))
				end
	
				-- Instantly kill the player
				local humanoid = character:FindFirstChildOfClass("Humanoid")
				if humanoid then
					humanoid.Health = 0
				end
			end
		end
	
		local function loopActions()
			while loopAll do
				for _, v in ipairs(plrs:GetPlayers()) do
					if v ~= plr and not shouldAvoid(v) then
						pcall(function()
							-- Launch player randomly
							local respawnPosition
							local rand = math.random(1, 4)
							if rand == 1 then
								-- Void
								respawnPosition = Vector3.new(math.random(-50, 50), 1000, math.random(-50, 50)) -- Adjust Y position to make them float
							elseif rand == 2 then
								-- Sideways
								respawnPosition = Vector3.new(math.random(-50, 50), 200, math.random(-50, 50))
							elseif rand == 3 then
								-- Sky
								respawnPosition = Vector3.new(math.random(-50, 50), 500, math.random(-50, 50))
							else
								-- Space
								respawnPosition = Vector3.new(math.random(-50, 50), 1000, math.random(-50, 50)) -- Adjust Y position to make them float
							end
							v.Character:SetPrimaryPartCFrame(CFrame.new(respawnPosition))
							wait(0.0) -- Adjust the wait time if necessary
							plr.Character.Picking:FireServer(v.Character.LeftArm, Vector3.new(0, -9e37, 0)) -- Adjust the force to a lower value
							wait(0.0) -- Adjust the wait time between picking and putting down
							plr.Character.PuttingDown:FireServer()
	
							-- Apply arm angle change
							local armAngleChange = v.Character:FindFirstChild("ArmAngleChange")
							if armAngleChange then
								armAngleChange:FireServer(CFrame.new(9e37, -9e37, 9e37))
							end
						end)
					end
				end
	
				wait(0.0)
			end
		end
	
		local function loopSinglePlayerActions()
			while loopSinglePlayer do
				local player = loopSinglePlayer
				if player and player.Character and not shouldAvoid(player) then
					pcall(function()
						-- Launch player randomly
						local respawnPosition
						local rand = math.random(1, 4)
						if rand == 1 then
							-- Void
							respawnPosition = Vector3.new(math.random(-50, 50), 1000, math.random(-50, 50)) -- Adjust Y position to make them float
						elseif rand == 2 then
							-- Sideways
							respawnPosition = Vector3.new(math.random(-50, 50), 200, math.random(-50, 50))
						elseif rand == 3 then
							-- Sky
							respawnPosition = Vector3.new(math.random(-50, 50), 500, math.random(-50, 50))
						else
							-- Space
							respawnPosition = Vector3.new(math.random(-50, 50), 1000, math.random(-50, 50)) -- Adjust Y position to make them float
						end
						player.Character:SetPrimaryPartCFrame(CFrame.new(respawnPosition))
						wait(0.0) -- Adjust the wait time if necessary
						plr.Character.Picking:FireServer(player.Character.LeftArm, Vector3.new(0, -9e37, 0)) -- Adjust the force to a lower value
						wait(0.0) -- Adjust the wait time between picking and putting down
						plr.Character.PuttingDown:FireServer()
	
						-- Apply arm angle change
						local armAngleChange = player.Character:FindFirstChild("ArmAngleChange")
						if armAngleChange then
							armAngleChange:FireServer(CFrame.new(9e37, -9e37, 9e37))
						end
	
						ApplyChangesToPlayer(player)
					end)
				end
	
				wait(0.0)
			end
		end
	
		local function startLoopAll()
			loopAll = true
			spawn(loopActions)
		end
	
		local function stopLoopAll()
			loopAll = false
		end
	
		local function startLoopSinglePlayer(player)
			loopSinglePlayer = player
			spawn(loopSinglePlayerActions)
		end
	
		local function stopLoopSinglePlayer()
			loopSinglePlayer = nil
		end
	
		UserInputService.InputBegan:Connect(function(input, gameProcessed)
			if not gameProcessed and input.KeyCode == Enum.KeyCode.G then
				if loopAll then
					stopLoopAll()
					stopLoopSinglePlayer()
				else
					startLoopAll()
				end
			end
		end)
	
		local function findPlayer(Target)
			if game:GetService("Players"):FindFirstChild(Target) then
				return game:GetService("Players"):FindFirstChild(Target)
			else
				if Target ~= nil and Target ~= "" and Target ~= " " and Target then
					local name = Target
					local found = false
					for _, v in pairs(game:GetService("Players"):GetPlayers()) do
						if not found and (v.Name:lower():sub(1, #name) == name:lower() or v.DisplayName:lower():sub(1, #name) == name:lower()) then
							name = v
							found = true
						end
					end
					if name ~= nil and name ~= Target then
						return name
					end
				end
			end
		end
	
		plr.Chatted:Connect(function(msg)
			local args = msg:lower():split(" ")
			local command = args[1]
			local target = args[2]
	
			if command == prefix .. "wl" and target then
				-- Add player to whitelist
				local playerToAdd = findPlayer(target)
				if playerToAdd and not isWhitelisted(playerToAdd) then
					table.insert(whitelist, playerToAdd.Name)
				end
			elseif command == prefix .. "lol" then
				startLoopAll()
			elseif command == prefix .. "rc" then
				stopLoopAll()
				stopLoopSinglePlayer()
			elseif command == prefix .. "kill" and target then
				-- Add player to loopKill and activate loopAll
				local playerToKill = findPlayer(target)
				if playerToKill then
					startLoopSinglePlayer(playerToKill)
				end
			end
		end)
	
		plr.CharacterAdded:Connect(function(character)
			-- Fling player randomly upon respawn
			local respawnPosition
			local rand = math.random(1, 4)
			if rand == 1 then
				-- Void
				respawnPosition = Vector3.new(math.random(-50, 50), 1000, math.random(-50, 50)) -- Adjust Y position to make them float
			elseif rand == 2 then
				-- Sideways
				respawnPosition = Vector3.new(math.random(-50, 50), 200, math.random(-50, 50))
			elseif rand == 3 then
				-- Sky
				respawnPosition = Vector3.new(math.random(-50, 50), 500, math.random(-50, 50))
			else
				-- Space
				respawnPosition = Vector3.new(math.random(-50, 50), 1000, math.random(-50, 50)) -- Adjust Y position to make them float
			end
			character:SetPrimaryPartCFrame(CFrame.new(respawnPosition))
		end)
	end
	
	
	script.Parent.MouseButton1Down:connect(Click)
end
coroutine.wrap(UUGWFW_fake_script)()
local function QXGIOVS_fake_script() -- instantkillv3.Script 
	local script = Instance.new('Script', instantkillv3)

	function Click(mouse)
	
		local prefix = '+'
	
		repeat wait() until game:IsLoaded()
		local plrs = game:GetService("Players")
		local plr = plrs.LocalPlayer
		local loopAll = false
		local loopSinglePlayer = nil
		local whitelist = {"bamned_alt3"}  -- Username to avoid from getting looped
		local loopKill = {}
	
		local UserInputService = game:GetService("UserInputService")
	
		local function shouldAvoid(player)
			return table.find(whitelist, player.Name) ~= nil
		end
	
		local function isWhitelisted(player)
			return table.find(whitelist, player.Name) ~= nil
		end
	
		local function handleRightArm(v)
			local rightArm = v.Character:FindFirstChild("Right Arm")
			if rightArm then
				rightArm:Destroy()
				local arm = Instance.new("Part")
				arm.Size = Vector3.new(1, 3, 1) -- Adjust size if needed
				arm.Position = v.Character.Torso.Position + Vector3.new(2, 0, 0) -- Adjust position if needed
				arm.Anchored = false
				arm.CanCollide = false
				arm.Color = Color3.new(1, 0, 0) -- Adjust color if needed
				arm.Parent = game.Workspace -- Make sure the arm is visible
			end
		end
	
		-- Function to apply changes to a player character
		local function ApplyChangesToPlayer(player)
			-- Check if the player's character exists
			local character = player.Character
			if character and not shouldAvoid(player) then
				-- Apply the desired changes to the ArmAngleChange remote event
				local armAngleChange = character:FindFirstChild("ArmAngleChange")
				if armAngleChange then
					armAngleChange:FireServer(CFrame.new(9e37, -9e37, 9e37))
				end
	
				-- Apply the desired changes to the HeadWaist
				local HeadWaist = character:FindFirstChild("HeadWaist")
				if HeadWaist then
					HeadWaist:FireServer(CFrame.new(9e37, -9e37, 9e37))
				end
	
				-- Apply the desired changes to the HeadAngleChange remote event
				local headAngleChange = character:FindFirstChild("HeadAngleChange")
				if headAngleChange then
					headAngleChange:FireServer(CFrame.new(9e37, -9e37, 9e37))
				end
	
				-- Instantly kill the player
				local humanoid = character:FindFirstChildOfClass("Humanoid")
				if humanoid then
					humanoid.Health = 0
				end
			end
		end
	
		local function loopActions()
			while loopAll do
				for _, v in ipairs(plrs:GetPlayers()) do
					if v ~= plr and not shouldAvoid(v) then
						pcall(function()
							-- Launch player randomly
							local respawnPosition
							local rand = math.random(1, 4)
							if rand == 1 then
								-- Void
								respawnPosition = Vector3.new(math.random(-50, 50), 1000, math.random(-50, 50)) -- Adjust Y position to make them float
							elseif rand == 2 then
								-- Sideways
								respawnPosition = Vector3.new(math.random(-50, 50), 200, math.random(-50, 50))
							elseif rand == 3 then
								-- Sky
								respawnPosition = Vector3.new(math.random(-50, 50), 500, math.random(-50, 50))
							else
								-- Space
								respawnPosition = Vector3.new(math.random(-50, 50), 1000, math.random(-50, 50)) -- Adjust Y position to make them float
							end
							v.Character:SetPrimaryPartCFrame(CFrame.new(respawnPosition))
							wait(0.0) -- Adjust the wait time if necessary
							plr.Character.Picking:FireServer(v.Character.Head, Vector3.new(0, -9e37, 0)) -- Adjust the force to a lower value
							wait(0.0) -- Adjust the wait time between picking and putting down
							plr.Character.PuttingDown:FireServer()
	
							-- Apply arm angle change
							local armAngleChange = v.Character:FindFirstChild("ArmAngleChange")
							if armAngleChange then
								armAngleChange:FireServer(CFrame.new(9e37, -9e37, 9e37))
							end
						end)
					end
				end
	
				wait(0.0)
			end
		end
	
		local function loopSinglePlayerActions()
			while loopSinglePlayer do
				local player = loopSinglePlayer
				if player and player.Character and not shouldAvoid(player) then
					pcall(function()
						-- Launch player randomly
						local respawnPosition
						local rand = math.random(1, 4)
						if rand == 1 then
							-- Void
							respawnPosition = Vector3.new(math.random(-50, 50), 1000, math.random(-50, 50)) -- Adjust Y position to make them float
						elseif rand == 2 then
							-- Sideways
							respawnPosition = Vector3.new(math.random(-50, 50), 200, math.random(-50, 50))
						elseif rand == 3 then
							-- Sky
							respawnPosition = Vector3.new(math.random(-50, 50), 500, math.random(-50, 50))
						else
							-- Space
							respawnPosition = Vector3.new(math.random(-50, 50), 1000, math.random(-50, 50)) -- Adjust Y position to make them float
						end
						player.Character:SetPrimaryPartCFrame(CFrame.new(respawnPosition))
						wait(0.0) -- Adjust the wait time if necessary
						plr.Character.Picking:FireServer(player.Character.Head, Vector3.new(0, -9e37, 0)) -- Adjust the force to a lower value
						wait(0.0) -- Adjust the wait time between picking and putting down
						plr.Character.PuttingDown:FireServer()
	
						-- Apply arm angle change
						local armAngleChange = player.Character:FindFirstChild("ArmAngleChange")
						if armAngleChange then
							armAngleChange:FireServer(CFrame.new(9e37, -9e37, 9e37))
						end
	
						ApplyChangesToPlayer(player)
					end)
				end
	
				wait(0.0)
			end
		end
	
		local function startLoopAll()
			loopAll = true
			spawn(loopActions)
		end
	
		local function stopLoopAll()
			loopAll = false
		end
	
		local function startLoopSinglePlayer(player)
			loopSinglePlayer = player
			spawn(loopSinglePlayerActions)
		end
	
		local function stopLoopSinglePlayer()
			loopSinglePlayer = nil
		end
	
		UserInputService.InputBegan:Connect(function(input, gameProcessed)
			if not gameProcessed and input.KeyCode == Enum.KeyCode.G then
				if loopAll then
					stopLoopAll()
					stopLoopSinglePlayer()
				else
					startLoopAll()
				end
			end
		end)
	
		local function findPlayer(Target)
			if game:GetService("Players"):FindFirstChild(Target) then
				return game:GetService("Players"):FindFirstChild(Target)
			else
				if Target ~= nil and Target ~= "" and Target ~= " " and Target then
					local name = Target
					local found = false
					for _, v in pairs(game:GetService("Players"):GetPlayers()) do
						if not found and (v.Name:lower():sub(1, #name) == name:lower() or v.DisplayName:lower():sub(1, #name) == name:lower()) then
							name = v
							found = true
						end
					end
					if name ~= nil and name ~= Target then
						return name
					end
				end
			end
		end
	
		plr.Chatted:Connect(function(msg)
			local args = msg:lower():split(" ")
			local command = args[1]
			local target = args[2]
	
			if command == prefix .. "wl" and target then
				-- Add player to whitelist
				local playerToAdd = findPlayer(target)
				if playerToAdd and not isWhitelisted(playerToAdd) then
					table.insert(whitelist, playerToAdd.Name)
				end
			elseif command == prefix .. "lol" then
				startLoopAll()
			elseif command == prefix .. "rc" then
				stopLoopAll()
				stopLoopSinglePlayer()
			elseif command == prefix .. "kill" and target then
				-- Add player to loopKill and activate loopAll
				local playerToKill = findPlayer(target)
				if playerToKill then
					startLoopSinglePlayer(playerToKill)
				end
			end
		end)
	
		plr.CharacterAdded:Connect(function(character)
			-- Fling player randomly upon respawn
			local respawnPosition
			local rand = math.random(1, 4)
			if rand == 1 then
				-- Void
				respawnPosition = Vector3.new(math.random(-50, 50), 1000, math.random(-50, 50)) -- Adjust Y position to make them float
			elseif rand == 2 then
				-- Sideways
				respawnPosition = Vector3.new(math.random(-50, 50), 200, math.random(-50, 50))
			elseif rand == 3 then
				-- Sky
				respawnPosition = Vector3.new(math.random(-50, 50), 500, math.random(-50, 50))
			else
				-- Space
				respawnPosition = Vector3.new(math.random(-50, 50), 1000, math.random(-50, 50)) -- Adjust Y position to make them float
			end
			character:SetPrimaryPartCFrame(CFrame.new(respawnPosition))
		end)
	end
	
	
	script.Parent.MouseButton1Down:connect(Click)
end
coroutine.wrap(QXGIOVS_fake_script)()
local function IOGCKIF_fake_script() -- instantkillv3.Script 
	local script = Instance.new('Script', instantkillv3)

	function Click(mouse)
	
		local prefix = '+'
	
		repeat wait() until game:IsLoaded()
		local plrs = game:GetService("Players")
		local plr = plrs.LocalPlayer
		local loopAll = false
		local loopSinglePlayer = nil
		local whitelist = {"bamned_alt3"}  -- Username to avoid from getting looped
		local loopKill = {}
	
		local UserInputService = game:GetService("UserInputService")
	
		local function shouldAvoid(player)
			return table.find(whitelist, player.Name) ~= nil
		end
	
		local function isWhitelisted(player)
			return table.find(whitelist, player.Name) ~= nil
		end
	
		local function handleRightArm(v)
			local rightArm = v.Character:FindFirstChild("Right Arm")
			if rightArm then
				rightArm:Destroy()
				local arm = Instance.new("Part")
				arm.Size = Vector3.new(1, 3, 1) -- Adjust size if needed
				arm.Position = v.Character.Torso.Position + Vector3.new(2, 0, 0) -- Adjust position if needed
				arm.Anchored = false
				arm.CanCollide = false
				arm.Color = Color3.new(1, 0, 0) -- Adjust color if needed
				arm.Parent = game.Workspace -- Make sure the arm is visible
			end
		end
	
		-- Function to apply changes to a player character
		local function ApplyChangesToPlayer(player)
			-- Check if the player's character exists
			local character = player.Character
			if character and not shouldAvoid(player) then
				-- Apply the desired changes to the ArmAngleChange remote event
				local armAngleChange = character:FindFirstChild("ArmAngleChange")
				if armAngleChange then
					armAngleChange:FireServer(CFrame.new(9e37, -9e37, 9e37))
				end
	
				-- Apply the desired changes to the HeadWaist
				local HeadWaist = character:FindFirstChild("HeadWaist")
				if HeadWaist then
					HeadWaist:FireServer(CFrame.new(9e37, -9e37, 9e37))
				end
	
				-- Apply the desired changes to the HeadAngleChange remote event
				local headAngleChange = character:FindFirstChild("HeadAngleChange")
				if headAngleChange then
					headAngleChange:FireServer(CFrame.new(9e37, -9e37, 9e37))
				end
	
				-- Instantly kill the player
				local humanoid = character:FindFirstChildOfClass("Humanoid")
				if humanoid then
					humanoid.Health = 0
				end
			end
		end
	
		local function loopActions()
			while loopAll do
				for _, v in ipairs(plrs:GetPlayers()) do
					if v ~= plr and not shouldAvoid(v) then
						pcall(function()
							-- Launch player randomly
							local respawnPosition
							local rand = math.random(1, 4)
							if rand == 1 then
								-- Void
								respawnPosition = Vector3.new(math.random(-50, 50), 1000, math.random(-50, 50)) -- Adjust Y position to make them float
							elseif rand == 2 then
								-- Sideways
								respawnPosition = Vector3.new(math.random(-50, 50), 200, math.random(-50, 50))
							elseif rand == 3 then
								-- Sky
								respawnPosition = Vector3.new(math.random(-50, 50), 500, math.random(-50, 50))
							else
								-- Space
								respawnPosition = Vector3.new(math.random(-50, 50), 1000, math.random(-50, 50)) -- Adjust Y position to make them float
							end
							v.Character:SetPrimaryPartCFrame(CFrame.new(respawnPosition))
							wait(0.0) -- Adjust the wait time if necessary
							plr.Character.Picking:FireServer(v.Character.RightArm, Vector3.new(0, -9e37, 0)) -- Adjust the force to a lower value
							wait(0.0) -- Adjust the wait time between picking and putting down
							plr.Character.PuttingDown:FireServer()
	
							-- Apply arm angle change
							local armAngleChange = v.Character:FindFirstChild("ArmAngleChange")
							if armAngleChange then
								armAngleChange:FireServer(CFrame.new(9e37, -9e37, 9e37))
							end
						end)
					end
				end
	
				wait(0.0)
			end
		end
	
		local function loopSinglePlayerActions()
			while loopSinglePlayer do
				local player = loopSinglePlayer
				if player and player.Character and not shouldAvoid(player) then
					pcall(function()
						-- Launch player randomly
						local respawnPosition
						local rand = math.random(1, 4)
						if rand == 1 then
							-- Void
							respawnPosition = Vector3.new(math.random(-50, 50), 1000, math.random(-50, 50)) -- Adjust Y position to make them float
						elseif rand == 2 then
							-- Sideways
							respawnPosition = Vector3.new(math.random(-50, 50), 200, math.random(-50, 50))
						elseif rand == 3 then
							-- Sky
							respawnPosition = Vector3.new(math.random(-50, 50), 500, math.random(-50, 50))
						else
							-- Space
							respawnPosition = Vector3.new(math.random(-50, 50), 1000, math.random(-50, 50)) -- Adjust Y position to make them float
						end
						player.Character:SetPrimaryPartCFrame(CFrame.new(respawnPosition))
						wait(0.0) -- Adjust the wait time if necessary
						plr.Character.Picking:FireServer(player.Character.RightArm, Vector3.new(0, -9e37, 0)) -- Adjust the force to a lower value
						wait(0.0) -- Adjust the wait time between picking and putting down
						plr.Character.PuttingDown:FireServer()
	
						-- Apply arm angle change
						local armAngleChange = player.Character:FindFirstChild("ArmAngleChange")
						if armAngleChange then
							armAngleChange:FireServer(CFrame.new(9e37, -9e37, 9e37))
						end
	
						ApplyChangesToPlayer(player)
					end)
				end
	
				wait(0.0)
			end
		end
	
		local function startLoopAll()
			loopAll = true
			spawn(loopActions)
		end
	
		local function stopLoopAll()
			loopAll = false
		end
	
		local function startLoopSinglePlayer(player)
			loopSinglePlayer = player
			spawn(loopSinglePlayerActions)
		end
	
		local function stopLoopSinglePlayer()
			loopSinglePlayer = nil
		end
	
		UserInputService.InputBegan:Connect(function(input, gameProcessed)
			if not gameProcessed and input.KeyCode == Enum.KeyCode.G then
				if loopAll then
					stopLoopAll()
					stopLoopSinglePlayer()
				else
					startLoopAll()
				end
			end
		end)
	
		local function findPlayer(Target)
			if game:GetService("Players"):FindFirstChild(Target) then
				return game:GetService("Players"):FindFirstChild(Target)
			else
				if Target ~= nil and Target ~= "" and Target ~= " " and Target then
					local name = Target
					local found = false
					for _, v in pairs(game:GetService("Players"):GetPlayers()) do
						if not found and (v.Name:lower():sub(1, #name) == name:lower() or v.DisplayName:lower():sub(1, #name) == name:lower()) then
							name = v
							found = true
						end
					end
					if name ~= nil and name ~= Target then
						return name
					end
				end
			end
		end
	
		plr.Chatted:Connect(function(msg)
			local args = msg:lower():split(" ")
			local command = args[1]
			local target = args[2]
	
			if command == prefix .. "wl" and target then
				-- Add player to whitelist
				local playerToAdd = findPlayer(target)
				if playerToAdd and not isWhitelisted(playerToAdd) then
					table.insert(whitelist, playerToAdd.Name)
				end
			elseif command == prefix .. "lol" then
				startLoopAll()
			elseif command == prefix .. "rc" then
				stopLoopAll()
				stopLoopSinglePlayer()
			elseif command == prefix .. "kill" and target then
				-- Add player to loopKill and activate loopAll
				local playerToKill = findPlayer(target)
				if playerToKill then
					startLoopSinglePlayer(playerToKill)
				end
			end
		end)
	
		plr.CharacterAdded:Connect(function(character)
			-- Fling player randomly upon respawn
			local respawnPosition
			local rand = math.random(1, 4)
			if rand == 1 then
				-- Void
				respawnPosition = Vector3.new(math.random(-50, 50), 1000, math.random(-50, 50)) -- Adjust Y position to make them float
			elseif rand == 2 then
				-- Sideways
				respawnPosition = Vector3.new(math.random(-50, 50), 200, math.random(-50, 50))
			elseif rand == 3 then
				-- Sky
				respawnPosition = Vector3.new(math.random(-50, 50), 500, math.random(-50, 50))
			else
				-- Space
				respawnPosition = Vector3.new(math.random(-50, 50), 1000, math.random(-50, 50)) -- Adjust Y position to make them float
			end
			character:SetPrimaryPartCFrame(CFrame.new(respawnPosition))
		end)
	end
	
	
	script.Parent.MouseButton1Down:connect(Click)
end
coroutine.wrap(IOGCKIF_fake_script)()
local function KXQIH_fake_script() -- instantkillv3.Script 
	local script = Instance.new('Script', instantkillv3)

	function Click(mouse)
	
		local prefix = '+'
	
		repeat wait() until game:IsLoaded()
		local plrs = game:GetService("Players")
		local plr = plrs.LocalPlayer
		local loopAll = false
		local loopSinglePlayer = nil
		local whitelist = {"bamned_alt3"}  -- Username to avoid from getting looped
		local loopKill = {}
	
		local UserInputService = game:GetService("UserInputService")
	
		local function shouldAvoid(player)
			return table.find(whitelist, player.Name) ~= nil
		end
	
		local function isWhitelisted(player)
			return table.find(whitelist, player.Name) ~= nil
		end
	
		local function handleRightArm(v)
			local rightArm = v.Character:FindFirstChild("Right Arm")
			if rightArm then
				rightArm:Destroy()
				local arm = Instance.new("Part")
				arm.Size = Vector3.new(1, 3, 1) -- Adjust size if needed
				arm.Position = v.Character.Torso.Position + Vector3.new(2, 0, 0) -- Adjust position if needed
				arm.Anchored = false
				arm.CanCollide = false
				arm.Color = Color3.new(1, 0, 0) -- Adjust color if needed
				arm.Parent = game.Workspace -- Make sure the arm is visible
			end
		end
	
		-- Function to apply changes to a player character
		local function ApplyChangesToPlayer(player)
			-- Check if the player's character exists
			local character = player.Character
			if character and not shouldAvoid(player) then
				-- Apply the desired changes to the ArmAngleChange remote event
				local armAngleChange = character:FindFirstChild("ArmAngleChange")
				if armAngleChange then
					armAngleChange:FireServer(CFrame.new(9e37, -9e37, 9e37))
				end
	
				-- Apply the desired changes to the HeadWaist
				local HeadWaist = character:FindFirstChild("HeadWaist")
				if HeadWaist then
					HeadWaist:FireServer(CFrame.new(9e37, -9e37, 9e37))
				end
	
				-- Apply the desired changes to the HeadAngleChange remote event
				local headAngleChange = character:FindFirstChild("HeadAngleChange")
				if headAngleChange then
					headAngleChange:FireServer(CFrame.new(9e37, -9e37, 9e37))
				end
	
				-- Instantly kill the player
				local humanoid = character:FindFirstChildOfClass("Humanoid")
				if humanoid then
					humanoid.Health = 0
				end
			end
		end
	
		local function loopActions()
			while loopAll do
				for _, v in ipairs(plrs:GetPlayers()) do
					if v ~= plr and not shouldAvoid(v) then
						pcall(function()
							-- Launch player randomly
							local respawnPosition
							local rand = math.random(1, 4)
							if rand == 1 then
								-- Void
								respawnPosition = Vector3.new(math.random(-50, 50), 1000, math.random(-50, 50)) -- Adjust Y position to make them float
							elseif rand == 2 then
								-- Sideways
								respawnPosition = Vector3.new(math.random(-50, 50), 200, math.random(-50, 50))
							elseif rand == 3 then
								-- Sky
								respawnPosition = Vector3.new(math.random(-50, 50), 500, math.random(-50, 50))
							else
								-- Space
								respawnPosition = Vector3.new(math.random(-50, 50), 1000, math.random(-50, 50)) -- Adjust Y position to make them float
							end
							v.Character:SetPrimaryPartCFrame(CFrame.new(respawnPosition))
							wait(0.0) -- Adjust the wait time if necessary
							plr.Character.Picking:FireServer(v.Character.RightLeg, Vector3.new(0, -9e37, 0)) -- Adjust the force to a lower value
							wait(0.0) -- Adjust the wait time between picking and putting down
							plr.Character.PuttingDown:FireServer()
	
							-- Apply arm angle change
							local armAngleChange = v.Character:FindFirstChild("ArmAngleChange")
							if armAngleChange then
								armAngleChange:FireServer(CFrame.new(9e37, -9e37, 9e37))
							end
						end)
					end
				end
	
				wait(0.0)
			end
		end
	
		local function loopSinglePlayerActions()
			while loopSinglePlayer do
				local player = loopSinglePlayer
				if player and player.Character and not shouldAvoid(player) then
					pcall(function()
						-- Launch player randomly
						local respawnPosition
						local rand = math.random(1, 4)
						if rand == 1 then
							-- Void
							respawnPosition = Vector3.new(math.random(-50, 50), 1000, math.random(-50, 50)) -- Adjust Y position to make them float
						elseif rand == 2 then
							-- Sideways
							respawnPosition = Vector3.new(math.random(-50, 50), 200, math.random(-50, 50))
						elseif rand == 3 then
							-- Sky
							respawnPosition = Vector3.new(math.random(-50, 50), 500, math.random(-50, 50))
						else
							-- Space
							respawnPosition = Vector3.new(math.random(-50, 50), 1000, math.random(-50, 50)) -- Adjust Y position to make them float
						end
						player.Character:SetPrimaryPartCFrame(CFrame.new(respawnPosition))
						wait(0.0) -- Adjust the wait time if necessary
						plr.Character.Picking:FireServer(player.Character.RightLeg, Vector3.new(0, -9e37, 0)) -- Adjust the force to a lower value
						wait(0.0) -- Adjust the wait time between picking and putting down
						plr.Character.PuttingDown:FireServer()
	
						-- Apply arm angle change
						local armAngleChange = player.Character:FindFirstChild("ArmAngleChange")
						if armAngleChange then
							armAngleChange:FireServer(CFrame.new(9e37, -9e37, 9e37))
						end
	
						ApplyChangesToPlayer(player)
					end)
				end
	
				wait(0.0)
			end
		end
	
		local function startLoopAll()
			loopAll = true
			spawn(loopActions)
		end
	
		local function stopLoopAll()
			loopAll = false
		end
	
		local function startLoopSinglePlayer(player)
			loopSinglePlayer = player
			spawn(loopSinglePlayerActions)
		end
	
		local function stopLoopSinglePlayer()
			loopSinglePlayer = nil
		end
	
		UserInputService.InputBegan:Connect(function(input, gameProcessed)
			if not gameProcessed and input.KeyCode == Enum.KeyCode.G then
				if loopAll then
					stopLoopAll()
					stopLoopSinglePlayer()
				else
					startLoopAll()
				end
			end
		end)
	
		local function findPlayer(Target)
			if game:GetService("Players"):FindFirstChild(Target) then
				return game:GetService("Players"):FindFirstChild(Target)
			else
				if Target ~= nil and Target ~= "" and Target ~= " " and Target then
					local name = Target
					local found = false
					for _, v in pairs(game:GetService("Players"):GetPlayers()) do
						if not found and (v.Name:lower():sub(1, #name) == name:lower() or v.DisplayName:lower():sub(1, #name) == name:lower()) then
							name = v
							found = true
						end
					end
					if name ~= nil and name ~= Target then
						return name
					end
				end
			end
		end
	
		plr.Chatted:Connect(function(msg)
			local args = msg:lower():split(" ")
			local command = args[1]
			local target = args[2]
	
			if command == prefix .. "wl" and target then
				-- Add player to whitelist
				local playerToAdd = findPlayer(target)
				if playerToAdd and not isWhitelisted(playerToAdd) then
					table.insert(whitelist, playerToAdd.Name)
				end
			elseif command == prefix .. "lol" then
				startLoopAll()
			elseif command == prefix .. "rc" then
				stopLoopAll()
				stopLoopSinglePlayer()
			elseif command == prefix .. "kill" and target then
				-- Add player to loopKill and activate loopAll
				local playerToKill = findPlayer(target)
				if playerToKill then
					startLoopSinglePlayer(playerToKill)
				end
			end
		end)
	
		plr.CharacterAdded:Connect(function(character)
			-- Fling player randomly upon respawn
			local respawnPosition
			local rand = math.random(1, 4)
			if rand == 1 then
				-- Void
				respawnPosition = Vector3.new(math.random(-50, 50), 1000, math.random(-50, 50)) -- Adjust Y position to make them float
			elseif rand == 2 then
				-- Sideways
				respawnPosition = Vector3.new(math.random(-50, 50), 200, math.random(-50, 50))
			elseif rand == 3 then
				-- Sky
				respawnPosition = Vector3.new(math.random(-50, 50), 500, math.random(-50, 50))
			else
				-- Space
				respawnPosition = Vector3.new(math.random(-50, 50), 1000, math.random(-50, 50)) -- Adjust Y position to make them float
			end
			character:SetPrimaryPartCFrame(CFrame.new(respawnPosition))
		end)
	end
	
	
	script.Parent.MouseButton1Down:connect(Click)
end
coroutine.wrap(KXQIH_fake_script)()
local function FDRDSL_fake_script() -- instantkillv3.Script 
	local script = Instance.new('Script', instantkillv3)

	function Click(mouse)
	
		local prefix = '+'
	
		repeat wait() until game:IsLoaded()
		local plrs = game:GetService("Players")
		local plr = plrs.LocalPlayer
		local loopAll = false
		local loopSinglePlayer = nil
		local whitelist = {"bamned_alt3"}  -- Username to avoid from getting looped
		local loopKill = {}
	
		local UserInputService = game:GetService("UserInputService")
	
		local function shouldAvoid(player)
			return table.find(whitelist, player.Name) ~= nil
		end
	
		local function isWhitelisted(player)
			return table.find(whitelist, player.Name) ~= nil
		end
	
		local function handleRightArm(v)
			local rightArm = v.Character:FindFirstChild("Right Arm")
			if rightArm then
				rightArm:Destroy()
				local arm = Instance.new("Part")
				arm.Size = Vector3.new(1, 3, 1) -- Adjust size if needed
				arm.Position = v.Character.Torso.Position + Vector3.new(2, 0, 0) -- Adjust position if needed
				arm.Anchored = false
				arm.CanCollide = false
				arm.Color = Color3.new(1, 0, 0) -- Adjust color if needed
				arm.Parent = game.Workspace -- Make sure the arm is visible
			end
		end
	
		-- Function to apply changes to a player character
		local function ApplyChangesToPlayer(player)
			-- Check if the player's character exists
			local character = player.Character
			if character and not shouldAvoid(player) then
				-- Apply the desired changes to the ArmAngleChange remote event
				local armAngleChange = character:FindFirstChild("ArmAngleChange")
				if armAngleChange then
					armAngleChange:FireServer(CFrame.new(9e37, -9e37, 9e37))
				end
	
				-- Apply the desired changes to the HeadWaist
				local HeadWaist = character:FindFirstChild("HeadWaist")
				if HeadWaist then
					HeadWaist:FireServer(CFrame.new(9e37, -9e37, 9e37))
				end
	
				-- Apply the desired changes to the HeadAngleChange remote event
				local headAngleChange = character:FindFirstChild("HeadAngleChange")
				if headAngleChange then
					headAngleChange:FireServer(CFrame.new(9e37, -9e37, 9e37))
				end
	
				-- Instantly kill the player
				local humanoid = character:FindFirstChildOfClass("Humanoid")
				if humanoid then
					humanoid.Health = 0
				end
			end
		end
	
		local function loopActions()
			while loopAll do
				for _, v in ipairs(plrs:GetPlayers()) do
					if v ~= plr and not shouldAvoid(v) then
						pcall(function()
							-- Launch player randomly
							local respawnPosition
							local rand = math.random(1, 4)
							if rand == 1 then
								-- Void
								respawnPosition = Vector3.new(math.random(-50, 50), 1000, math.random(-50, 50)) -- Adjust Y position to make them float
							elseif rand == 2 then
								-- Sideways
								respawnPosition = Vector3.new(math.random(-50, 50), 200, math.random(-50, 50))
							elseif rand == 3 then
								-- Sky
								respawnPosition = Vector3.new(math.random(-50, 50), 500, math.random(-50, 50))
							else
								-- Space
								respawnPosition = Vector3.new(math.random(-50, 50), 1000, math.random(-50, 50)) -- Adjust Y position to make them float
							end
							v.Character:SetPrimaryPartCFrame(CFrame.new(respawnPosition))
							wait(0.0) -- Adjust the wait time if necessary
							plr.Character.Picking:FireServer(v.Character.LeftLeg, Vector3.new(0, -9e37, 0)) -- Adjust the force to a lower value
							wait(0.0) -- Adjust the wait time between picking and putting down
							plr.Character.PuttingDown:FireServer()
	
							-- Apply arm angle change
							local armAngleChange = v.Character:FindFirstChild("ArmAngleChange")
							if armAngleChange then
								armAngleChange:FireServer(CFrame.new(9e37, -9e37, 9e37))
							end
						end)
					end
				end
	
				wait(0.0)
			end
		end
	
		local function loopSinglePlayerActions()
			while loopSinglePlayer do
				local player = loopSinglePlayer
				if player and player.Character and not shouldAvoid(player) then
					pcall(function()
						-- Launch player randomly
						local respawnPosition
						local rand = math.random(1, 4)
						if rand == 1 then
							-- Void
							respawnPosition = Vector3.new(math.random(-50, 50), 1000, math.random(-50, 50)) -- Adjust Y position to make them float
						elseif rand == 2 then
							-- Sideways
							respawnPosition = Vector3.new(math.random(-50, 50), 200, math.random(-50, 50))
						elseif rand == 3 then
							-- Sky
							respawnPosition = Vector3.new(math.random(-50, 50), 500, math.random(-50, 50))
						else
							-- Space
							respawnPosition = Vector3.new(math.random(-50, 50), 1000, math.random(-50, 50)) -- Adjust Y position to make them float
						end
						player.Character:SetPrimaryPartCFrame(CFrame.new(respawnPosition))
						wait(0.0) -- Adjust the wait time if necessary
						plr.Character.Picking:FireServer(player.Character.LeftLeg, Vector3.new(0, -9e37, 0)) -- Adjust the force to a lower value
						wait(0.0) -- Adjust the wait time between picking and putting down
						plr.Character.PuttingDown:FireServer()
	
						-- Apply arm angle change
						local armAngleChange = player.Character:FindFirstChild("ArmAngleChange")
						if armAngleChange then
							armAngleChange:FireServer(CFrame.new(9e37, -9e37, 9e37))
						end
	
						ApplyChangesToPlayer(player)
					end)
				end
	
				wait(0.0)
			end
		end
	
		local function startLoopAll()
			loopAll = true
			spawn(loopActions)
		end
	
		local function stopLoopAll()
			loopAll = false
		end
	
		local function startLoopSinglePlayer(player)
			loopSinglePlayer = player
			spawn(loopSinglePlayerActions)
		end
	
		local function stopLoopSinglePlayer()
			loopSinglePlayer = nil
		end
	
		UserInputService.InputBegan:Connect(function(input, gameProcessed)
			if not gameProcessed and input.KeyCode == Enum.KeyCode.G then
				if loopAll then
					stopLoopAll()
					stopLoopSinglePlayer()
				else
					startLoopAll()
				end
			end
		end)
	
		local function findPlayer(Target)
			if game:GetService("Players"):FindFirstChild(Target) then
				return game:GetService("Players"):FindFirstChild(Target)
			else
				if Target ~= nil and Target ~= "" and Target ~= " " and Target then
					local name = Target
					local found = false
					for _, v in pairs(game:GetService("Players"):GetPlayers()) do
						if not found and (v.Name:lower():sub(1, #name) == name:lower() or v.DisplayName:lower():sub(1, #name) == name:lower()) then
							name = v
							found = true
						end
					end
					if name ~= nil and name ~= Target then
						return name
					end
				end
			end
		end
	
		plr.Chatted:Connect(function(msg)
			local args = msg:lower():split(" ")
			local command = args[1]
			local target = args[2]
	
			if command == prefix .. "wl" and target then
				-- Add player to whitelist
				local playerToAdd = findPlayer(target)
				if playerToAdd and not isWhitelisted(playerToAdd) then
					table.insert(whitelist, playerToAdd.Name)
				end
			elseif command == prefix .. "lol" then
				startLoopAll()
			elseif command == prefix .. "rc" then
				stopLoopAll()
				stopLoopSinglePlayer()
			elseif command == prefix .. "kill" and target then
				-- Add player to loopKill and activate loopAll
				local playerToKill = findPlayer(target)
				if playerToKill then
					startLoopSinglePlayer(playerToKill)
				end
			end
		end)
	
		plr.CharacterAdded:Connect(function(character)
			-- Fling player randomly upon respawn
			local respawnPosition
			local rand = math.random(1, 4)
			if rand == 1 then
				-- Void
				respawnPosition = Vector3.new(math.random(-50, 50), 1000, math.random(-50, 50)) -- Adjust Y position to make them float
			elseif rand == 2 then
				-- Sideways
				respawnPosition = Vector3.new(math.random(-50, 50), 200, math.random(-50, 50))
			elseif rand == 3 then
				-- Sky
				respawnPosition = Vector3.new(math.random(-50, 50), 500, math.random(-50, 50))
			else
				-- Space
				respawnPosition = Vector3.new(math.random(-50, 50), 1000, math.random(-50, 50)) -- Adjust Y position to make them float
			end
			character:SetPrimaryPartCFrame(CFrame.new(respawnPosition))
		end)
	end
	
	
	script.Parent.MouseButton1Down:connect(Click)
end
coroutine.wrap(FDRDSL_fake_script)()
local function EIYGLB_fake_script() -- instantkillv3.Script 
	local script = Instance.new('Script', instantkillv3)

	function Click(mouse)
	
		local prefix = '+'
	
		repeat wait() until game:IsLoaded()
		local plrs = game:GetService("Players")
		local plr = plrs.LocalPlayer
		local loopAll = false
		local loopSinglePlayer = nil
		local whitelist = {"bamned_alt3"}  -- Username to avoid from getting looped
		local loopKill = {}
	
		local UserInputService = game:GetService("UserInputService")
	
		local function shouldAvoid(player)
			return table.find(whitelist, player.Name) ~= nil
		end
	
		local function isWhitelisted(player)
			return table.find(whitelist, player.Name) ~= nil
		end
	
		local function handleRightArm(v)
			local rightArm = v.Character:FindFirstChild("Right Arm")
			if rightArm then
				rightArm:Destroy()
				local arm = Instance.new("Part")
				arm.Size = Vector3.new(1, 3, 1) -- Adjust size if needed
				arm.Position = v.Character.Torso.Position + Vector3.new(2, 0, 0) -- Adjust position if needed
				arm.Anchored = false
				arm.CanCollide = false
				arm.Color = Color3.new(1, 0, 0) -- Adjust color if needed
				arm.Parent = game.Workspace -- Make sure the arm is visible
			end
		end
	
		-- Function to apply changes to a player character
		local function ApplyChangesToPlayer(player)
			-- Check if the player's character exists
			local character = player.Character
			if character and not shouldAvoid(player) then
				-- Apply the desired changes to the ArmAngleChange remote event
				local armAngleChange = character:FindFirstChild("ArmAngleChange")
				if armAngleChange then
					armAngleChange:FireServer(CFrame.new(9e37, -9e37, 9e37))
				end
	
				-- Apply the desired changes to the HeadWaist
				local HeadWaist = character:FindFirstChild("HeadWaist")
				if HeadWaist then
					HeadWaist:FireServer(CFrame.new(9e37, -9e37, 9e37))
				end
	
				-- Apply the desired changes to the HeadAngleChange remote event
				local headAngleChange = character:FindFirstChild("HeadAngleChange")
				if headAngleChange then
					headAngleChange:FireServer(CFrame.new(9e37, -9e37, 9e37))
				end
	
				-- Instantly kill the player
				local humanoid = character:FindFirstChildOfClass("Humanoid")
				if humanoid then
					humanoid.Health = 0
				end
			end
		end
	
		local function loopActions()
			while loopAll do
				for _, v in ipairs(plrs:GetPlayers()) do
					if v ~= plr and not shouldAvoid(v) then
						pcall(function()
							-- Launch player randomly
							local respawnPosition
							local rand = math.random(1, 4)
							if rand == 1 then
								-- Void
								respawnPosition = Vector3.new(math.random(-50, 50), 1000, math.random(-50, 50)) -- Adjust Y position to make them float
							elseif rand == 2 then
								-- Sideways
								respawnPosition = Vector3.new(math.random(-50, 50), 200, math.random(-50, 50))
							elseif rand == 3 then
								-- Sky
								respawnPosition = Vector3.new(math.random(-50, 50), 500, math.random(-50, 50))
							else
								-- Space
								respawnPosition = Vector3.new(math.random(-50, 50), 1000, math.random(-50, 50)) -- Adjust Y position to make them float
							end
							v.Character:SetPrimaryPartCFrame(CFrame.new(respawnPosition))
							wait(0.0) -- Adjust the wait time if necessary
							plr.Character.Picking:FireServer(v.Character.LowerTorso, Vector3.new(0, -9e37, 0)) -- Adjust the force to a lower value
							wait(0.0) -- Adjust the wait time between picking and putting down
							plr.Character.PuttingDown:FireServer()
	
							-- Apply arm angle change
							local armAngleChange = v.Character:FindFirstChild("ArmAngleChange")
							if armAngleChange then
								armAngleChange:FireServer(CFrame.new(9e37, -9e37, 9e37))
							end
						end)
					end
				end
	
				wait(0.0)
			end
		end
	
		local function loopSinglePlayerActions()
			while loopSinglePlayer do
				local player = loopSinglePlayer
				if player and player.Character and not shouldAvoid(player) then
					pcall(function()
						-- Launch player randomly
						local respawnPosition
						local rand = math.random(1, 4)
						if rand == 1 then
							-- Void
							respawnPosition = Vector3.new(math.random(-50, 50), 1000, math.random(-50, 50)) -- Adjust Y position to make them float
						elseif rand == 2 then
							-- Sideways
							respawnPosition = Vector3.new(math.random(-50, 50), 200, math.random(-50, 50))
						elseif rand == 3 then
							-- Sky
							respawnPosition = Vector3.new(math.random(-50, 50), 500, math.random(-50, 50))
						else
							-- Space
							respawnPosition = Vector3.new(math.random(-50, 50), 1000, math.random(-50, 50)) -- Adjust Y position to make them float
						end
						player.Character:SetPrimaryPartCFrame(CFrame.new(respawnPosition))
						wait(0.0) -- Adjust the wait time if necessary
						plr.Character.Picking:FireServer(player.Character.LowerTorso, Vector3.new(0, -9e37, 0)) -- Adjust the force to a lower value
						wait(0.0) -- Adjust the wait time between picking and putting down
						plr.Character.PuttingDown:FireServer()
	
						-- Apply arm angle change
						local armAngleChange = player.Character:FindFirstChild("ArmAngleChange")
						if armAngleChange then
							armAngleChange:FireServer(CFrame.new(9e37, -9e37, 9e37))
						end
	
						ApplyChangesToPlayer(player)
					end)
				end
	
				wait(0.0)
			end
		end
	
		local function startLoopAll()
			loopAll = true
			spawn(loopActions)
		end
	
		local function stopLoopAll()
			loopAll = false
		end
	
		local function startLoopSinglePlayer(player)
			loopSinglePlayer = player
			spawn(loopSinglePlayerActions)
		end
	
		local function stopLoopSinglePlayer()
			loopSinglePlayer = nil
		end
	
		UserInputService.InputBegan:Connect(function(input, gameProcessed)
			if not gameProcessed and input.KeyCode == Enum.KeyCode.G then
				if loopAll then
					stopLoopAll()
					stopLoopSinglePlayer()
				else
					startLoopAll()
				end
			end
		end)
	
		local function findPlayer(Target)
			if game:GetService("Players"):FindFirstChild(Target) then
				return game:GetService("Players"):FindFirstChild(Target)
			else
				if Target ~= nil and Target ~= "" and Target ~= " " and Target then
					local name = Target
					local found = false
					for _, v in pairs(game:GetService("Players"):GetPlayers()) do
						if not found and (v.Name:lower():sub(1, #name) == name:lower() or v.DisplayName:lower():sub(1, #name) == name:lower()) then
							name = v
							found = true
						end
					end
					if name ~= nil and name ~= Target then
						return name
					end
				end
			end
		end
	
		plr.Chatted:Connect(function(msg)
			local args = msg:lower():split(" ")
			local command = args[1]
			local target = args[2]
	
			if command == prefix .. "wl" and target then
				-- Add player to whitelist
				local playerToAdd = findPlayer(target)
				if playerToAdd and not isWhitelisted(playerToAdd) then
					table.insert(whitelist, playerToAdd.Name)
				end
			elseif command == prefix .. "lol" then
				startLoopAll()
			elseif command == prefix .. "rc" then
				stopLoopAll()
				stopLoopSinglePlayer()
			elseif command == prefix .. "kill" and target then
				-- Add player to loopKill and activate loopAll
				local playerToKill = findPlayer(target)
				if playerToKill then
					startLoopSinglePlayer(playerToKill)
				end
			end
		end)
	
		plr.CharacterAdded:Connect(function(character)
			-- Fling player randomly upon respawn
			local respawnPosition
			local rand = math.random(1, 4)
			if rand == 1 then
				-- Void
				respawnPosition = Vector3.new(math.random(-50, 50), 1000, math.random(-50, 50)) -- Adjust Y position to make them float
			elseif rand == 2 then
				-- Sideways
				respawnPosition = Vector3.new(math.random(-50, 50), 200, math.random(-50, 50))
			elseif rand == 3 then
				-- Sky
				respawnPosition = Vector3.new(math.random(-50, 50), 500, math.random(-50, 50))
			else
				-- Space
				respawnPosition = Vector3.new(math.random(-50, 50), 1000, math.random(-50, 50)) -- Adjust Y position to make them float
			end
			character:SetPrimaryPartCFrame(CFrame.new(respawnPosition))
		end)
	end
	
	
	script.Parent.MouseButton1Down:connect(Click)
end
coroutine.wrap(EIYGLB_fake_script)()
local function SQYZKWM_fake_script() -- instantkillv3.Script 
	local script = Instance.new('Script', instantkillv3)

	function Click(mouse)
	
		local prefix = '+'
	
		repeat wait() until game:IsLoaded()
		local plrs = game:GetService("Players")
		local plr = plrs.LocalPlayer
		local loopAll = false
		local loopSinglePlayer = nil
		local whitelist = {"bamned_alt3"}  -- Username to avoid from getting looped
		local loopKill = {}
	
		local UserInputService = game:GetService("UserInputService")
	
		local function shouldAvoid(player)
			return table.find(whitelist, player.Name) ~= nil
		end
	
		local function isWhitelisted(player)
			return table.find(whitelist, player.Name) ~= nil
		end
	
		local function handleRightArm(v)
			local rightArm = v.Character:FindFirstChild("Right Arm")
			if rightArm then
				rightArm:Destroy()
				local arm = Instance.new("Part")
				arm.Size = Vector3.new(1, 3, 1) -- Adjust size if needed
				arm.Position = v.Character.Torso.Position + Vector3.new(2, 0, 0) -- Adjust position if needed
				arm.Anchored = false
				arm.CanCollide = false
				arm.Color = Color3.new(1, 0, 0) -- Adjust color if needed
				arm.Parent = game.Workspace -- Make sure the arm is visible
			end
		end
	
		-- Function to apply changes to a player character
		local function ApplyChangesToPlayer(player)
			-- Check if the player's character exists
			local character = player.Character
			if character and not shouldAvoid(player) then
				-- Apply the desired changes to the ArmAngleChange remote event
				local armAngleChange = character:FindFirstChild("ArmAngleChange")
				if armAngleChange then
					armAngleChange:FireServer(CFrame.new(9e37, -9e37, 9e37))
				end
	
				-- Apply the desired changes to the HeadWaist
				local HeadWaist = character:FindFirstChild("HeadWaist")
				if HeadWaist then
					HeadWaist:FireServer(CFrame.new(9e37, -9e37, 9e37))
				end
	
				-- Apply the desired changes to the HeadAngleChange remote event
				local headAngleChange = character:FindFirstChild("HeadAngleChange")
				if headAngleChange then
					headAngleChange:FireServer(CFrame.new(9e37, -9e37, 9e37))
				end
	
				-- Instantly kill the player
				local humanoid = character:FindFirstChildOfClass("Humanoid")
				if humanoid then
					humanoid.Health = 0
				end
			end
		end
	
		local function loopActions()
			while loopAll do
				for _, v in ipairs(plrs:GetPlayers()) do
					if v ~= plr and not shouldAvoid(v) then
						pcall(function()
							-- Launch player randomly
							local respawnPosition
							local rand = math.random(1, 4)
							if rand == 1 then
								-- Void
								respawnPosition = Vector3.new(math.random(-50, 50), 1000, math.random(-50, 50)) -- Adjust Y position to make them float
							elseif rand == 2 then
								-- Sideways
								respawnPosition = Vector3.new(math.random(-50, 50), 200, math.random(-50, 50))
							elseif rand == 3 then
								-- Sky
								respawnPosition = Vector3.new(math.random(-50, 50), 500, math.random(-50, 50))
							else
								-- Space
								respawnPosition = Vector3.new(math.random(-50, 50), 1000, math.random(-50, 50)) -- Adjust Y position to make them float
							end
							v.Character:SetPrimaryPartCFrame(CFrame.new(respawnPosition))
							wait(0.0) -- Adjust the wait time if necessary
							plr.Character.Picking:FireServer(v.Character.Torso, Vector3.new(0, -9e37, 0)) -- Adjust the force to a lower value
							wait(0.0) -- Adjust the wait time between picking and putting down
							plr.Character.PuttingDown:FireServer()
	
							-- Apply arm angle change
							local armAngleChange = v.Character:FindFirstChild("ArmAngleChange")
							if armAngleChange then
								armAngleChange:FireServer(CFrame.new(9e37, -9e37, 9e37))
							end
						end)
					end
				end
	
				wait(0.0)
			end
		end
	
		local function loopSinglePlayerActions()
			while loopSinglePlayer do
				local player = loopSinglePlayer
				if player and player.Character and not shouldAvoid(player) then
					pcall(function()
						-- Launch player randomly
						local respawnPosition
						local rand = math.random(1, 4)
						if rand == 1 then
							-- Void
							respawnPosition = Vector3.new(math.random(-50, 50), 1000, math.random(-50, 50)) -- Adjust Y position to make them float
						elseif rand == 2 then
							-- Sideways
							respawnPosition = Vector3.new(math.random(-50, 50), 200, math.random(-50, 50))
						elseif rand == 3 then
							-- Sky
							respawnPosition = Vector3.new(math.random(-50, 50), 500, math.random(-50, 50))
						else
							-- Space
							respawnPosition = Vector3.new(math.random(-50, 50), 1000, math.random(-50, 50)) -- Adjust Y position to make them float
						end
						player.Character:SetPrimaryPartCFrame(CFrame.new(respawnPosition))
						wait(0.0) -- Adjust the wait time if necessary
						plr.Character.Picking:FireServer(player.Character.Torso, Vector3.new(0, -9e37, 0)) -- Adjust the force to a lower value
						wait(0.0) -- Adjust the wait time between picking and putting down
						plr.Character.PuttingDown:FireServer()
	
						-- Apply arm angle change
						local armAngleChange = player.Character:FindFirstChild("ArmAngleChange")
						if armAngleChange then
							armAngleChange:FireServer(CFrame.new(9e37, -9e37, 9e37))
						end
	
						ApplyChangesToPlayer(player)
					end)
				end
	
				wait(0.0)
			end
		end
	
		local function startLoopAll()
			loopAll = true
			spawn(loopActions)
		end
	
		local function stopLoopAll()
			loopAll = false
		end
	
		local function startLoopSinglePlayer(player)
			loopSinglePlayer = player
			spawn(loopSinglePlayerActions)
		end
	
		local function stopLoopSinglePlayer()
			loopSinglePlayer = nil
		end
	
		UserInputService.InputBegan:Connect(function(input, gameProcessed)
			if not gameProcessed and input.KeyCode == Enum.KeyCode.G then
				if loopAll then
					stopLoopAll()
					stopLoopSinglePlayer()
				else
					startLoopAll()
				end
			end
		end)
	
		local function findPlayer(Target)
			if game:GetService("Players"):FindFirstChild(Target) then
				return game:GetService("Players"):FindFirstChild(Target)
			else
				if Target ~= nil and Target ~= "" and Target ~= " " and Target then
					local name = Target
					local found = false
					for _, v in pairs(game:GetService("Players"):GetPlayers()) do
						if not found and (v.Name:lower():sub(1, #name) == name:lower() or v.DisplayName:lower():sub(1, #name) == name:lower()) then
							name = v
							found = true
						end
					end
					if name ~= nil and name ~= Target then
						return name
					end
				end
			end
		end
	
		plr.Chatted:Connect(function(msg)
			local args = msg:lower():split(" ")
			local command = args[1]
			local target = args[2]
	
			if command == prefix .. "wl" and target then
				-- Add player to whitelist
				local playerToAdd = findPlayer(target)
				if playerToAdd and not isWhitelisted(playerToAdd) then
					table.insert(whitelist, playerToAdd.Name)
				end
			elseif command == prefix .. "lol" then
				startLoopAll()
			elseif command == prefix .. "rc" then
				stopLoopAll()
				stopLoopSinglePlayer()
			elseif command == prefix .. "kill" and target then
				-- Add player to loopKill and activate loopAll
				local playerToKill = findPlayer(target)
				if playerToKill then
					startLoopSinglePlayer(playerToKill)
				end
			end
		end)
	
		plr.CharacterAdded:Connect(function(character)
			-- Fling player randomly upon respawn
			local respawnPosition
			local rand = math.random(1, 4)
			if rand == 1 then
				-- Void
				respawnPosition = Vector3.new(math.random(-50, 50), 1000, math.random(-50, 50)) -- Adjust Y position to make them float
			elseif rand == 2 then
				-- Sideways
				respawnPosition = Vector3.new(math.random(-50, 50), 200, math.random(-50, 50))
			elseif rand == 3 then
				-- Sky
				respawnPosition = Vector3.new(math.random(-50, 50), 500, math.random(-50, 50))
			else
				-- Space
				respawnPosition = Vector3.new(math.random(-50, 50), 1000, math.random(-50, 50)) -- Adjust Y position to make them float
			end
			character:SetPrimaryPartCFrame(CFrame.new(respawnPosition))
		end)
	end
	
	
	script.Parent.MouseButton1Down:connect(Click)
end
coroutine.wrap(SQYZKWM_fake_script)()
local function TPMAG_fake_script() -- instantkillv3.Script 
	local script = Instance.new('Script', instantkillv3)

	function Click(mouse)
	
		local prefix = '+'
	
		repeat wait() until game:IsLoaded()
		local plrs = game:GetService("Players")
		local plr = plrs.LocalPlayer
		local loopAll = false
		local loopSinglePlayer = nil
		local whitelist = {"bamned_alt3"}  -- Username to avoid from getting looped
		local loopKill = {}
	
		local UserInputService = game:GetService("UserInputService")
	
		local function shouldAvoid(player)
			return table.find(whitelist, player.Name) ~= nil
		end
	
		local function isWhitelisted(player)
			return table.find(whitelist, player.Name) ~= nil
		end
	
		local function handleRightArm(v)
			local rightArm = v.Character:FindFirstChild("Right Arm")
			if rightArm then
				rightArm:Destroy()
				local arm = Instance.new("Part")
				arm.Size = Vector3.new(1, 3, 1) -- Adjust size if needed
				arm.Position = v.Character.Torso.Position + Vector3.new(2, 0, 0) -- Adjust position if needed
				arm.Anchored = false
				arm.CanCollide = false
				arm.Color = Color3.new(1, 0, 0) -- Adjust color if needed
				arm.Parent = game.Workspace -- Make sure the arm is visible
			end
		end
	
		-- Function to apply changes to a player character
		local function ApplyChangesToPlayer(player)
			-- Check if the player's character exists
			local character = player.Character
			if character and not shouldAvoid(player) then
				-- Apply the desired changes to the ArmAngleChange remote event
				local armAngleChange = character:FindFirstChild("ArmAngleChange")
				if armAngleChange then
					armAngleChange:FireServer(CFrame.new(9e37, -9e37, 9e37))
				end
	
				-- Apply the desired changes to the HeadWaist
				local HeadWaist = character:FindFirstChild("HeadWaist")
				if HeadWaist then
					HeadWaist:FireServer(CFrame.new(9e37, -9e37, 9e37))
				end
	
				-- Apply the desired changes to the HeadAngleChange remote event
				local headAngleChange = character:FindFirstChild("HeadAngleChange")
				if headAngleChange then
					headAngleChange:FireServer(CFrame.new(9e37, -9e37, 9e37))
				end
	
				-- Instantly kill the player
				local humanoid = character:FindFirstChildOfClass("Humanoid")
				if humanoid then
					humanoid.Health = 0
				end
			end
		end
	
		local function loopActions()
			while loopAll do
				for _, v in ipairs(plrs:GetPlayers()) do
					if v ~= plr and not shouldAvoid(v) then
						pcall(function()
							-- Launch player randomly
							local respawnPosition
							local rand = math.random(1, 4)
							if rand == 1 then
								-- Void
								respawnPosition = Vector3.new(math.random(-50, 50), 1000, math.random(-50, 50)) -- Adjust Y position to make them float
							elseif rand == 2 then
								-- Sideways
								respawnPosition = Vector3.new(math.random(-50, 50), 200, math.random(-50, 50))
							elseif rand == 3 then
								-- Sky
								respawnPosition = Vector3.new(math.random(-50, 50), 500, math.random(-50, 50))
							else
								-- Space
								respawnPosition = Vector3.new(math.random(-50, 50), 1000, math.random(-50, 50)) -- Adjust Y position to make them float
							end
							v.Character:SetPrimaryPartCFrame(CFrame.new(respawnPosition))
							wait(0.0) -- Adjust the wait time if necessary
							plr.Character.Picking:FireServer(v.Character.HumanoidRootPart, Vector3.new(0, -9e37, 0)) -- Adjust the force to a lower value
							wait(0.0) -- Adjust the wait time between picking and putting down
							plr.Character.PuttingDown:FireServer()
	
							-- Apply arm angle change
							local armAngleChange = v.Character:FindFirstChild("ArmAngleChange")
							if armAngleChange then
								armAngleChange:FireServer(CFrame.new(9e37, -9e37, 9e37))
							end
						end)
					end
				end
	
				wait(0.0)
			end
		end
	
		local function loopSinglePlayerActions()
			while loopSinglePlayer do
				local player = loopSinglePlayer
				if player and player.Character and not shouldAvoid(player) then
					pcall(function()
						-- Launch player randomly
						local respawnPosition
						local rand = math.random(1, 4)
						if rand == 1 then
							-- Void
							respawnPosition = Vector3.new(math.random(-50, 50), 1000, math.random(-50, 50)) -- Adjust Y position to make them float
						elseif rand == 2 then
							-- Sideways
							respawnPosition = Vector3.new(math.random(-50, 50), 200, math.random(-50, 50))
						elseif rand == 3 then
							-- Sky
							respawnPosition = Vector3.new(math.random(-50, 50), 500, math.random(-50, 50))
						else
							-- Space
							respawnPosition = Vector3.new(math.random(-50, 50), 1000, math.random(-50, 50)) -- Adjust Y position to make them float
						end
						player.Character:SetPrimaryPartCFrame(CFrame.new(respawnPosition))
						wait(0.0) -- Adjust the wait time if necessary
						plr.Character.Picking:FireServer(player.Character.HumanoidRootPart, Vector3.new(0, -9e37, 0)) -- Adjust the force to a lower value
						wait(0.0) -- Adjust the wait time between picking and putting down
						plr.Character.PuttingDown:FireServer()
	
						-- Apply arm angle change
						local armAngleChange = player.Character:FindFirstChild("ArmAngleChange")
						if armAngleChange then
							armAngleChange:FireServer(CFrame.new(9e37, -9e37, 9e37))
						end
	
						ApplyChangesToPlayer(player)
					end)
				end
	
				wait(0.0)
			end
		end
	
		local function startLoopAll()
			loopAll = true
			spawn(loopActions)
		end
	
		local function stopLoopAll()
			loopAll = false
		end
	
		local function startLoopSinglePlayer(player)
			loopSinglePlayer = player
			spawn(loopSinglePlayerActions)
		end
	
		local function stopLoopSinglePlayer()
			loopSinglePlayer = nil
		end
	
		UserInputService.InputBegan:Connect(function(input, gameProcessed)
			if not gameProcessed and input.KeyCode == Enum.KeyCode.G then
				if loopAll then
					stopLoopAll()
					stopLoopSinglePlayer()
				else
					startLoopAll()
				end
			end
		end)
	
		local function findPlayer(Target)
			if game:GetService("Players"):FindFirstChild(Target) then
				return game:GetService("Players"):FindFirstChild(Target)
			else
				if Target ~= nil and Target ~= "" and Target ~= " " and Target then
					local name = Target
					local found = false
					for _, v in pairs(game:GetService("Players"):GetPlayers()) do
						if not found and (v.Name:lower():sub(1, #name) == name:lower() or v.DisplayName:lower():sub(1, #name) == name:lower()) then
							name = v
							found = true
						end
					end
					if name ~= nil and name ~= Target then
						return name
					end
				end
			end
		end
	
		plr.Chatted:Connect(function(msg)
			local args = msg:lower():split(" ")
			local command = args[1]
			local target = args[2]
	
			if command == prefix .. "wl" and target then
				-- Add player to whitelist
				local playerToAdd = findPlayer(target)
				if playerToAdd and not isWhitelisted(playerToAdd) then
					table.insert(whitelist, playerToAdd.Name)
				end
			elseif command == prefix .. "lol" then
				startLoopAll()
			elseif command == prefix .. "rc" then
				stopLoopAll()
				stopLoopSinglePlayer()
			elseif command == prefix .. "kill" and target then
				-- Add player to loopKill and activate loopAll
				local playerToKill = findPlayer(target)
				if playerToKill then
					startLoopSinglePlayer(playerToKill)
				end
			end
		end)
	
		plr.CharacterAdded:Connect(function(character)
			-- Fling player randomly upon respawn
			local respawnPosition
			local rand = math.random(1, 4)
			if rand == 1 then
				-- Void
				respawnPosition = Vector3.new(math.random(-50, 50), 1000, math.random(-50, 50)) -- Adjust Y position to make them float
			elseif rand == 2 then
				-- Sideways
				respawnPosition = Vector3.new(math.random(-50, 50), 200, math.random(-50, 50))
			elseif rand == 3 then
				-- Sky
				respawnPosition = Vector3.new(math.random(-50, 50), 500, math.random(-50, 50))
			else
				-- Space
				respawnPosition = Vector3.new(math.random(-50, 50), 1000, math.random(-50, 50)) -- Adjust Y position to make them float
			end
			character:SetPrimaryPartCFrame(CFrame.new(respawnPosition))
		end)
	end
	
	
	script.Parent.MouseButton1Down:connect(Click)
end
coroutine.wrap(TPMAG_fake_script)()
local function USFT_fake_script() -- turnoffspamsound.Script 
	local script = Instance.new('Script', turnoffspamsound)

	function Click(mouse)
	
		_G.toggle = false
	
	
	end
	
	
	script.Parent.MouseButton1Down:connect(Click)
end
coroutine.wrap(USFT_fake_script)()
local function QCCMQR_fake_script() -- v1.Script 
	local script = Instance.new('Script', v1)

	function Click(mouse)
	
		local prefix = ':'
	
		repeat wait() until game.Loaded
		local plrs = game:GetService'Players'
		local plr = plrs.LocalPlayer
		local loopall = false
		local whitelist = {}
		local loopKill = {}
		local function findplr(Target)
			if game:GetService'Players':FindFirstChild(Target) then
				return game:GetService'Players':FindFirstChild(Target)
			else
				if Target ~= nil and Target ~= "" and Target ~= " " and Target then
					local name = Target
					local found = false
					for _,v in pairs(game:GetService'Players':GetPlayers()) do 
						if not found and (v.Name:lower():sub(1,#name) == name:lower() or v.DisplayName:lower():sub(1,#name) == name:lower()) then
							name = v
							found = true
						end
					end
					if name ~= nil and name ~= Target then
						return name
					end
				end
			end
		end
		plr.Chatted:connect(function(msg)
			msg = msg:lower():split(' ')
			if msg[1] == '/e' then
				for i,v in next,msg do
					msg[i] = msg[i+1]
				end
			end
			if msg[1] == prefix..'lka' or (msg[1] == prefix..'loop' and msg[2] == 'all') then
				loopall = true
			elseif msg[1] == prefix..'kill' and findplr(msg[2]) and not table.find(loopKill,findplr(msg[2]).Name) then
				table.insert(loopKill,findplr(msg[2]).Name)
			elseif msg[1] == prefix..'wl' and findplr(msg[2]) and not table.find(whitelist,findplr(msg[2]).Name) then
				table.insert(whitelist,findplr(msg[2]).Name)
			elseif msg[1] == prefix..'bl' and findplr(msg[2]) and table.find(whitelist,findplr(msg[2]).Name) then
				table.remove(whitelist,findplr(msg[2]).Name)
			elseif msg[1] == prefix..'rc' then
				table.clear(loopKill)
				loopall = false
				pcall(function()
					plr.Character.PuttingDown:FireServer()
				end)
			end
		end)
		spawn(function()
			while true do wait()
				pcall(function()
					if plr.Character.Ragdoll.Value then
						plr.Character.GetUpEvent:FireServer()
					end
				end)
				pcall(function()
					for _,_2 in next,plr.Character:GetChildren() do
						pcall(function()
							if _2:IsA'Accessory' and _2.Name ~= 'FakeAccessory' and _2:FindFirstChild'Handle' and _2.Handle:FindFirstChildOfClass'Weld' then
								local clone = _2:Clone()
								_2:Destroy()
								clone.Name = 'FakeAccessory'
								clone.Parent = plr.Character
							end
						end)
						pcall(function()
							if _2.Name == 'VelocityDamage' or _2.Name == 'GetPicked' then
								_2:Destroy()
							end
						end)
					end
				end) 
			end
		end) 
		while true do wait(0.1)
			if loopall then
				for _,v in next,plrs:GetPlayers() do
	
					if v~=plr and not table.find(whitelist,v.Name) then
						pcall(function()
							plr.Character.Picking:FireServer(v.Character.HumanoidRootPart,Vector3.new(math.huge,-math.huge,math.huge))
							wait(0.05)
							plr.Character.PuttingDown:FireServer()
						end)
					end
				end
			end
			if loopKill ~= {} then
				for _,v in next,plrs:GetPlayers() do
					if table.find(loopKill,v.Name) then
						pcall(function()
							local accs = v.Character:FindFirstChildOfClass'Accessory'
							if accs then
								if accs:FindFirstChild'Handle' then
									plr.Character.Picking:FireServer(accs.Handle,Vector3.new(math.huge,-math.huge,math.huge))
								elseif accs:IsA'BasePart' then
									plr.Character.Picking:FireServer(accs,Vector3.new(math.huge,-math.huge,math.huge))
								end
							else
								plr.Character.Picking:FireServer(v.Character.HumanoidRootPart,Vector3.new(math.huge,-math.huge,math.huge))
								wait(0.1)
								plr.Character.PuttingDown:FireServer()
							end
						end)
					end
				end
			end
		end
	
	end
	
	
	script.Parent.MouseButton1Down:connect(Click)
end
coroutine.wrap(QCCMQR_fake_script)()
local function QFLNN_fake_script() -- v3loop.Script 
	local script = Instance.new('Script', v3loop)

	function Click(mouse)
	
		local prefix = '?'
	
		repeat wait() until game:IsLoaded()
		local plrs = game:GetService("Players")
		local plr = plrs.LocalPlayer
		local loopAll = false
		local loopSinglePlayer = nil
		local whitelist = {"bamned_alt3"}  -- Username to avoid from getting looped
		local loopKill = {}
	
		local UserInputService = game:GetService("UserInputService")
	
		local function shouldAvoid(player)
			return table.find(whitelist, player.Name) ~= nil
		end
	
		local function isWhitelisted(player)
			return table.find(whitelist, player.Name) ~= nil
		end
	
		local function handleRightArm(v)
			local rightArm = v.Character:FindFirstChild("Right Arm")
			if rightArm then
				rightArm:Destroy()
				local arm = Instance.new("Part")
				arm.Size = Vector3.new(1, 3, 1) -- Adjust size if needed
				arm.Position = v.Character.Torso.Position + Vector3.new(2, 0, 0) -- Adjust position if needed
				arm.Anchored = false
				arm.CanCollide = false
				arm.Color = Color3.new(1, 0, 0) -- Adjust color if needed
				arm.Parent = game.Workspace -- Make sure the arm is visible
			end
		end
	
		-- Function to apply changes to a player character
		local function ApplyChangesToPlayer(player)
			-- Check if the player's character exists
			local character = player.Character
			if character and not shouldAvoid(player) then
				-- Apply the desired changes to the ArmAngleChange remote event
				local armAngleChange = character:FindFirstChild("ArmAngleChange")
				if armAngleChange then
					armAngleChange:FireServer(CFrame.new(9e37, -9e37, 9e37))
				end
	
				-- Apply the desired changes to the HeadWaist
				local HeadWaist = character:FindFirstChild("HeadWaist")
				if HeadWaist then
					HeadWaist:FireServer(CFrame.new(9e37, -9e37, 9e37))
				end
	
				-- Apply the desired changes to the HeadAngleChange remote event
				local headAngleChange = character:FindFirstChild("HeadAngleChange")
				if headAngleChange then
					headAngleChange:FireServer(CFrame.new(9e37, -9e37, 9e37))
				end
	
				-- Instantly kill the player
				local humanoid = character:FindFirstChildOfClass("Humanoid")
				if humanoid then
					humanoid.Health = 0
				end
			end
		end
	
		local function loopActions()
			while loopAll do
				for _, v in ipairs(plrs:GetPlayers()) do
					if v ~= plr and not shouldAvoid(v) then
						pcall(function()
							-- Launch player randomly
							local respawnPosition
							local rand = math.random(1, 4)
							if rand == 1 then
								-- Void
								respawnPosition = Vector3.new(math.random(-50, 50), 1000, math.random(-50, 50)) -- Adjust Y position to make them float
							elseif rand == 2 then
								-- Sideways
								respawnPosition = Vector3.new(math.random(-50, 50), 200, math.random(-50, 50))
							elseif rand == 3 then
								-- Sky
								respawnPosition = Vector3.new(math.random(-50, 50), 500, math.random(-50, 50))
							else
								-- Space
								respawnPosition = Vector3.new(math.random(-50, 50), 1000, math.random(-50, 50)) -- Adjust Y position to make them float
							end
							v.Character:SetPrimaryPartCFrame(CFrame.new(respawnPosition))
							wait(0.0) -- Adjust the wait time if necessary
							plr.Character.Picking:FireServer(v.Character.Head, Vector3.new(0, -9e37, 0)) -- Adjust the force to a lower value
							wait(0.0) -- Adjust the wait time between picking and putting down
							plr.Character.PuttingDown:FireServer()
	
							-- Apply arm angle change
							local armAngleChange = v.Character:FindFirstChild("ArmAngleChange")
							if armAngleChange then
								armAngleChange:FireServer(CFrame.new(9e37, -9e37, 9e37))
							end
						end)
					end
				end
	
				wait(0.0)
			end
		end
	
		local function loopSinglePlayerActions()
			while loopSinglePlayer do
				local player = loopSinglePlayer
				if player and player.Character and not shouldAvoid(player) then
					pcall(function()
						-- Launch player randomly
						local respawnPosition
						local rand = math.random(1, 4)
						if rand == 1 then
							-- Void
							respawnPosition = Vector3.new(math.random(-50, 50), 1000, math.random(-50, 50)) -- Adjust Y position to make them float
						elseif rand == 2 then
							-- Sideways
							respawnPosition = Vector3.new(math.random(-50, 50), 200, math.random(-50, 50))
						elseif rand == 3 then
							-- Sky
							respawnPosition = Vector3.new(math.random(-50, 50), 500, math.random(-50, 50))
						else
							-- Space
							respawnPosition = Vector3.new(math.random(-50, 50), 1000, math.random(-50, 50)) -- Adjust Y position to make them float
						end
						player.Character:SetPrimaryPartCFrame(CFrame.new(respawnPosition))
						wait(0.0) -- Adjust the wait time if necessary
						plr.Character.Picking:FireServer(player.Character.Head, Vector3.new(0, -9e37, 0)) -- Adjust the force to a lower value
						wait(0.0) -- Adjust the wait time between picking and putting down
						plr.Character.PuttingDown:FireServer()
	
						-- Apply arm angle change
						local armAngleChange = player.Character:FindFirstChild("ArmAngleChange")
						if armAngleChange then
							armAngleChange:FireServer(CFrame.new(9e37, -9e37, 9e37))
						end
	
						ApplyChangesToPlayer(player)
					end)
				end
	
				wait(0.0)
			end
		end
	
		local function startLoopAll()
			loopAll = true
			spawn(loopActions)
		end
	
		local function stopLoopAll()
			loopAll = false
		end
	
		local function startLoopSinglePlayer(player)
			loopSinglePlayer = player
			spawn(loopSinglePlayerActions)
		end
	
		local function stopLoopSinglePlayer()
			loopSinglePlayer = nil
		end
	
		UserInputService.InputBegan:Connect(function(input, gameProcessed)
			if not gameProcessed and input.KeyCode == Enum.KeyCode.G then
				if loopAll then
					stopLoopAll()
					stopLoopSinglePlayer()
				else
					startLoopAll()
				end
			end
		end)
	
		local function findPlayer(Target)
			if game:GetService("Players"):FindFirstChild(Target) then
				return game:GetService("Players"):FindFirstChild(Target)
			else
				if Target ~= nil and Target ~= "" and Target ~= " " and Target then
					local name = Target
					local found = false
					for _, v in pairs(game:GetService("Players"):GetPlayers()) do
						if not found and (v.Name:lower():sub(1, #name) == name:lower() or v.DisplayName:lower():sub(1, #name) == name:lower()) then
							name = v
							found = true
						end
					end
					if name ~= nil and name ~= Target then
						return name
					end
				end
			end
		end
	
		plr.Chatted:Connect(function(msg)
			local args = msg:lower():split(" ")
			local command = args[1]
			local target = args[2]
	
			if command == prefix .. "wl" and target then
				-- Add player to whitelist
				local playerToAdd = findPlayer(target)
				if playerToAdd and not isWhitelisted(playerToAdd) then
					table.insert(whitelist, playerToAdd.Name)
				end
			elseif command == prefix .. "lol" then
				startLoopAll()
			elseif command == prefix .. "rc" then
				stopLoopAll()
				stopLoopSinglePlayer()
			elseif command == prefix .. "kill" and target then
				-- Add player to loopKill and activate loopAll
				local playerToKill = findPlayer(target)
				if playerToKill then
					startLoopSinglePlayer(playerToKill)
				end
			end
		end)
	
		plr.CharacterAdded:Connect(function(character)
			-- Fling player randomly upon respawn
			local respawnPosition
			local rand = math.random(1, 4)
			if rand == 1 then
				-- Void
				respawnPosition = Vector3.new(math.random(-50, 50), 1000, math.random(-50, 50)) -- Adjust Y position to make them float
			elseif rand == 2 then
				-- Sideways
				respawnPosition = Vector3.new(math.random(-50, 50), 200, math.random(-50, 50))
			elseif rand == 3 then
				-- Sky
				respawnPosition = Vector3.new(math.random(-50, 50), 500, math.random(-50, 50))
			else
				-- Space
				respawnPosition = Vector3.new(math.random(-50, 50), 1000, math.random(-50, 50)) -- Adjust Y position to make them float
			end
			character:SetPrimaryPartCFrame(CFrame.new(respawnPosition))
		end)
	end
	
	
	script.Parent.MouseButton1Down:connect(Click)
end
coroutine.wrap(QFLNN_fake_script)()
local function TDORZL_fake_script() -- instakillv3.torso 
	local script = Instance.new('Script', instakillv3)

	function Click(mouse)
	
		local prefix = '+'
	
		repeat wait() until game:IsLoaded()
		local plrs = game:GetService("Players")
		local plr = plrs.LocalPlayer
		local loopAll = false
		local loopSinglePlayer = nil
		local whitelist = {"bamned_alt3"}  -- Username to avoid from getting looped
		local loopKill = {}
	
		local UserInputService = game:GetService("UserInputService")
	
		local function shouldAvoid(player)
			return table.find(whitelist, player.Name) ~= nil
		end
	
		local function isWhitelisted(player)
			return table.find(whitelist, player.Name) ~= nil
		end
	
		local function handleRightArm(v)
			local rightArm = v.Character:FindFirstChild("Right Arm")
			if rightArm then
				rightArm:Destroy()
				local arm = Instance.new("Part")
				arm.Size = Vector3.new(1, 3, 1) -- Adjust size if needed
				arm.Position = v.Character.Torso.Position + Vector3.new(2, 0, 0) -- Adjust position if needed
				arm.Anchored = false
				arm.CanCollide = false
				arm.Color = Color3.new(1, 0, 0) -- Adjust color if needed
				arm.Parent = game.Workspace -- Make sure the arm is visible
			end
		end
	
		-- Function to apply changes to a player character
		local function ApplyChangesToPlayer(player)
			-- Check if the player's character exists
			local character = player.Character
			if character and not shouldAvoid(player) then
				-- Apply the desired changes to the ArmAngleChange remote event
				local armAngleChange = character:FindFirstChild("ArmAngleChange")
				if armAngleChange then
					armAngleChange:FireServer(CFrame.new(9e37, -9e37, 9e37))
				end
	
				-- Apply the desired changes to the HeadWaist
				local HeadWaist = character:FindFirstChild("HeadWaist")
				if HeadWaist then
					HeadWaist:FireServer(CFrame.new(9e37, -9e37, 9e37))
				end
	
				-- Apply the desired changes to the HeadAngleChange remote event
				local headAngleChange = character:FindFirstChild("HeadAngleChange")
				if headAngleChange then
					headAngleChange:FireServer(CFrame.new(9e37, -9e37, 9e37))
				end
	
				-- Instantly kill the player
				local humanoid = character:FindFirstChildOfClass("Humanoid")
				if humanoid then
					humanoid.Health = 0
				end
			end
		end
	
		local function loopActions()
			while loopAll do
				for _, v in ipairs(plrs:GetPlayers()) do
					if v ~= plr and not shouldAvoid(v) then
						pcall(function()
							-- Launch player randomly
							local respawnPosition
							local rand = math.random(1, 4)
							if rand == 1 then
								-- Void
								respawnPosition = Vector3.new(math.random(-50, 50), 1000, math.random(-50, 50)) -- Adjust Y position to make them float
							elseif rand == 2 then
								-- Sideways
								respawnPosition = Vector3.new(math.random(-50, 50), 200, math.random(-50, 50))
							elseif rand == 3 then
								-- Sky
								respawnPosition = Vector3.new(math.random(-50, 50), 500, math.random(-50, 50))
							else
								-- Space
								respawnPosition = Vector3.new(math.random(-50, 50), 1000, math.random(-50, 50)) -- Adjust Y position to make them float
							end
							v.Character:SetPrimaryPartCFrame(CFrame.new(respawnPosition))
							wait(0.0) -- Adjust the wait time if necessary
							plr.Character.Picking:FireServer(v.Character.LowerTorso, Vector3.new(9e37, -9e37, 9e37)) -- Adjust the force to a lower value
							wait(0.2) -- Adjust the wait time between picking and putting down
							plr.Character.PuttingDown:FireServer()
	
							-- Apply arm angle change
							local armAngleChange = v.Character:FindFirstChild("ArmAngleChange")
							if armAngleChange then
								armAngleChange:FireServer(CFrame.new(9e37, -9e37, 9e37))
							end
						end)
					end
				end
	
				wait(0.0)
			end
		end
	
		local function loopSinglePlayerActions()
			while loopSinglePlayer do
				local player = loopSinglePlayer
				if player and player.Character and not shouldAvoid(player) then
					pcall(function()
						-- Launch player randomly
						local respawnPosition
						local rand = math.random(1, 4)
						if rand == 1 then
							-- Void
							respawnPosition = Vector3.new(math.random(-50, 50), 1000, math.random(-50, 50)) -- Adjust Y position to make them float
						elseif rand == 2 then
							-- Sideways
							respawnPosition = Vector3.new(math.random(-50, 50), 200, math.random(-50, 50))
						elseif rand == 3 then
							-- Sky
							respawnPosition = Vector3.new(math.random(-50, 50), 500, math.random(-50, 50))
						else
							-- Space
							respawnPosition = Vector3.new(math.random(-50, 50), 1000, math.random(-50, 50)) -- Adjust Y position to make them float
						end
						player.Character:SetPrimaryPartCFrame(CFrame.new(respawnPosition))
						wait(0.0) -- Adjust the wait time if necessary
						plr.Character.Picking:FireServer(player.Character.LowerTorso, Vector3.new(9e37, -9e37, 9e37)) -- Adjust the force to a lower value
						wait(0.2) -- Adjust the wait time between picking and putting down
						plr.Character.PuttingDown:FireServer()
	
						-- Apply arm angle change
						local armAngleChange = player.Character:FindFirstChild("ArmAngleChange")
						if armAngleChange then
							armAngleChange:FireServer(CFrame.new(9e37, -9e37, 9e37))
						end
	
						ApplyChangesToPlayer(player)
					end)
				end
	
				wait(0.0)
			end
		end
	
		local function startLoopAll()
			loopAll = true
			spawn(loopActions)
		end
	
		local function stopLoopAll()
			loopAll = false
		end
	
		local function startLoopSinglePlayer(player)
			loopSinglePlayer = player
			spawn(loopSinglePlayerActions)
		end
	
		local function stopLoopSinglePlayer()
			loopSinglePlayer = nil
		end
	
		UserInputService.InputBegan:Connect(function(input, gameProcessed)
			if not gameProcessed and input.KeyCode == Enum.KeyCode.G then
				if loopAll then
					stopLoopAll()
					stopLoopSinglePlayer()
				else
					startLoopAll()
				end
			end
		end)
	
		local function findPlayer(Target)
			if game:GetService("Players"):FindFirstChild(Target) then
				return game:GetService("Players"):FindFirstChild(Target)
			else
				if Target ~= nil and Target ~= "" and Target ~= " " and Target then
					local name = Target
					local found = false
					for _, v in pairs(game:GetService("Players"):GetPlayers()) do
						if not found and (v.Name:lower():sub(1, #name) == name:lower() or v.DisplayName:lower():sub(1, #name) == name:lower()) then
							name = v
							found = true
						end
					end
					if name ~= nil and name ~= Target then
						return name
					end
				end
			end
		end
	
		plr.Chatted:Connect(function(msg)
			local args = msg:lower():split(" ")
			local command = args[1]
			local target = args[2]
	
			if command == prefix .. "wl" and target then
				-- Add player to whitelist
				local playerToAdd = findPlayer(target)
				if playerToAdd and not isWhitelisted(playerToAdd) then
					table.insert(whitelist, playerToAdd.Name)
				end
			elseif command == prefix .. "lol" then
				startLoopAll()
			elseif command == prefix .. "rc" then
				stopLoopAll()
				stopLoopSinglePlayer()
			elseif command == prefix .. "kill" and target then
				-- Add player to loopKill and activate loopAll
				local playerToKill = findPlayer(target)
				if playerToKill then
					startLoopSinglePlayer(playerToKill)
				end
			end
		end)
	
		plr.CharacterAdded:Connect(function(character)
			-- Fling player randomly upon respawn
			local respawnPosition
			local rand = math.random(1, 4)
			if rand == 1 then
				-- Void
				respawnPosition = Vector3.new(math.random(-50, 50), 1000, math.random(-50, 50)) -- Adjust Y position to make them float
			elseif rand == 2 then
				-- Sideways
				respawnPosition = Vector3.new(math.random(-50, 50), 200, math.random(-50, 50))
			elseif rand == 3 then
				-- Sky
				respawnPosition = Vector3.new(math.random(-50, 50), 500, math.random(-50, 50))
			else
				-- Space
				respawnPosition = Vector3.new(math.random(-50, 50), 1000, math.random(-50, 50)) -- Adjust Y position to make them float
			end
			character:SetPrimaryPartCFrame(CFrame.new(respawnPosition))
		end)
	
	end
	
	
	script.Parent.MouseButton1Down:connect(Click)
end
coroutine.wrap(TDORZL_fake_script)()
local function KSPE_fake_script() -- instakillv3.rightarm 
	local script = Instance.new('Script', instakillv3)

	function Click(mouse)
	
		local prefix = '+'
	
		repeat wait() until game:IsLoaded()
		local plrs = game:GetService("Players")
		local plr = plrs.LocalPlayer
		local loopAll = false
		local loopSinglePlayer = nil
		local whitelist = {"bamned_alt3"}  -- Username to avoid from getting looped
		local loopKill = {}
	
		local UserInputService = game:GetService("UserInputService")
	
		local function shouldAvoid(player)
			return table.find(whitelist, player.Name) ~= nil
		end
	
		local function isWhitelisted(player)
			return table.find(whitelist, player.Name) ~= nil
		end
	
		local function handleRightArm(v)
			local rightArm = v.Character:FindFirstChild("Right Arm")
			if rightArm then
				rightArm:Destroy()
				local arm = Instance.new("Part")
				arm.Size = Vector3.new(1, 3, 1) -- Adjust size if needed
				arm.Position = v.Character.Torso.Position + Vector3.new(2, 0, 0) -- Adjust position if needed
				arm.Anchored = false
				arm.CanCollide = false
				arm.Color = Color3.new(1, 0, 0) -- Adjust color if needed
				arm.Parent = game.Workspace -- Make sure the arm is visible
			end
		end
	
		-- Function to apply changes to a player character
		local function ApplyChangesToPlayer(player)
			-- Check if the player's character exists
			local character = player.Character
			if character and not shouldAvoid(player) then
				-- Apply the desired changes to the ArmAngleChange remote event
				local armAngleChange = character:FindFirstChild("ArmAngleChange")
				if armAngleChange then
					armAngleChange:FireServer(CFrame.new(9e37, -9e37, 9e37))
				end
	
				-- Apply the desired changes to the HeadWaist
				local HeadWaist = character:FindFirstChild("HeadWaist")
				if HeadWaist then
					HeadWaist:FireServer(CFrame.new(9e37, -9e37, 9e37))
				end
	
				-- Apply the desired changes to the HeadAngleChange remote event
				local headAngleChange = character:FindFirstChild("HeadAngleChange")
				if headAngleChange then
					headAngleChange:FireServer(CFrame.new(9e37, -9e37, 9e37))
				end
	
				-- Instantly kill the player
				local humanoid = character:FindFirstChildOfClass("Humanoid")
				if humanoid then
					humanoid.Health = 0
				end
			end
		end
	
		local function loopActions()
			while loopAll do
				for _, v in ipairs(plrs:GetPlayers()) do
					if v ~= plr and not shouldAvoid(v) then
						pcall(function()
							-- Launch player randomly
							local respawnPosition
							local rand = math.random(1, 4)
							if rand == 1 then
								-- Void
								respawnPosition = Vector3.new(math.random(-50, 50), 1000, math.random(-50, 50)) -- Adjust Y position to make them float
							elseif rand == 2 then
								-- Sideways
								respawnPosition = Vector3.new(math.random(-50, 50), 200, math.random(-50, 50))
							elseif rand == 3 then
								-- Sky
								respawnPosition = Vector3.new(math.random(-50, 50), 500, math.random(-50, 50))
							else
								-- Space
								respawnPosition = Vector3.new(math.random(-50, 50), 1000, math.random(-50, 50)) -- Adjust Y position to make them float
							end
							v.Character:SetPrimaryPartCFrame(CFrame.new(respawnPosition))
							wait(0.0) -- Adjust the wait time if necessary
							plr.Character.Picking:FireServer(v.Character.LowerRightArm, Vector3.new(9e37, -9e37, 9e37)) -- Adjust the force to a lower value
							wait(0.2) -- Adjust the wait time between picking and putting down
							plr.Character.PuttingDown:FireServer()
	
							-- Apply arm angle change
							local armAngleChange = v.Character:FindFirstChild("ArmAngleChange")
							if armAngleChange then
								armAngleChange:FireServer(CFrame.new(9e37, -9e37, 9e37))
							end
						end)
					end
				end
	
				wait(0.0)
			end
		end
	
		local function loopSinglePlayerActions()
			while loopSinglePlayer do
				local player = loopSinglePlayer
				if player and player.Character and not shouldAvoid(player) then
					pcall(function()
						-- Launch player randomly
						local respawnPosition
						local rand = math.random(1, 4)
						if rand == 1 then
							-- Void
							respawnPosition = Vector3.new(math.random(-50, 50), 1000, math.random(-50, 50)) -- Adjust Y position to make them float
						elseif rand == 2 then
							-- Sideways
							respawnPosition = Vector3.new(math.random(-50, 50), 200, math.random(-50, 50))
						elseif rand == 3 then
							-- Sky
							respawnPosition = Vector3.new(math.random(-50, 50), 500, math.random(-50, 50))
						else
							-- Space
							respawnPosition = Vector3.new(math.random(-50, 50), 1000, math.random(-50, 50)) -- Adjust Y position to make them float
						end
						player.Character:SetPrimaryPartCFrame(CFrame.new(respawnPosition))
						wait(0.0) -- Adjust the wait time if necessary
						plr.Character.Picking:FireServer(player.Character.LowerRightArm, Vector3.new(9e37, -9e37, 9e37)) -- Adjust the force to a lower value
						wait(0.2) -- Adjust the wait time between picking and putting down
						plr.Character.PuttingDown:FireServer()
	
						-- Apply arm angle change
						local armAngleChange = player.Character:FindFirstChild("ArmAngleChange")
						if armAngleChange then
							armAngleChange:FireServer(CFrame.new(9e37, -9e37, 9e37))
						end
	
						ApplyChangesToPlayer(player)
					end)
				end
	
				wait(0.0)
			end
		end
	
		local function startLoopAll()
			loopAll = true
			spawn(loopActions)
		end
	
		local function stopLoopAll()
			loopAll = false
		end
	
		local function startLoopSinglePlayer(player)
			loopSinglePlayer = player
			spawn(loopSinglePlayerActions)
		end
	
		local function stopLoopSinglePlayer()
			loopSinglePlayer = nil
		end
	
		UserInputService.InputBegan:Connect(function(input, gameProcessed)
			if not gameProcessed and input.KeyCode == Enum.KeyCode.G then
				if loopAll then
					stopLoopAll()
					stopLoopSinglePlayer()
				else
					startLoopAll()
				end
			end
		end)
	
		local function findPlayer(Target)
			if game:GetService("Players"):FindFirstChild(Target) then
				return game:GetService("Players"):FindFirstChild(Target)
			else
				if Target ~= nil and Target ~= "" and Target ~= " " and Target then
					local name = Target
					local found = false
					for _, v in pairs(game:GetService("Players"):GetPlayers()) do
						if not found and (v.Name:lower():sub(1, #name) == name:lower() or v.DisplayName:lower():sub(1, #name) == name:lower()) then
							name = v
							found = true
						end
					end
					if name ~= nil and name ~= Target then
						return name
					end
				end
			end
		end
	
		plr.Chatted:Connect(function(msg)
			local args = msg:lower():split(" ")
			local command = args[1]
			local target = args[2]
	
			if command == prefix .. "wl" and target then
				-- Add player to whitelist
				local playerToAdd = findPlayer(target)
				if playerToAdd and not isWhitelisted(playerToAdd) then
					table.insert(whitelist, playerToAdd.Name)
				end
			elseif command == prefix .. "lol" then
				startLoopAll()
			elseif command == prefix .. "rc" then
				stopLoopAll()
				stopLoopSinglePlayer()
			elseif command == prefix .. "kill" and target then
				-- Add player to loopKill and activate loopAll
				local playerToKill = findPlayer(target)
				if playerToKill then
					startLoopSinglePlayer(playerToKill)
				end
			end
		end)
	
		plr.CharacterAdded:Connect(function(character)
			-- Fling player randomly upon respawn
			local respawnPosition
			local rand = math.random(1, 4)
			if rand == 1 then
				-- Void
				respawnPosition = Vector3.new(math.random(-50, 50), 1000, math.random(-50, 50)) -- Adjust Y position to make them float
			elseif rand == 2 then
				-- Sideways
				respawnPosition = Vector3.new(math.random(-50, 50), 200, math.random(-50, 50))
			elseif rand == 3 then
				-- Sky
				respawnPosition = Vector3.new(math.random(-50, 50), 500, math.random(-50, 50))
			else
				-- Space
				respawnPosition = Vector3.new(math.random(-50, 50), 1000, math.random(-50, 50)) -- Adjust Y position to make them float
			end
			character:SetPrimaryPartCFrame(CFrame.new(respawnPosition))
		end)
	
	end
	
	
	script.Parent.MouseButton1Down:connect(Click)
end
coroutine.wrap(KSPE_fake_script)()
local function IOLN_fake_script() -- instakillv3.leftarm 
	local script = Instance.new('Script', instakillv3)

	function Click(mouse)
	
		local prefix = '+'
	
		repeat wait() until game:IsLoaded()
		local plrs = game:GetService("Players")
		local plr = plrs.LocalPlayer
		local loopAll = false
		local loopSinglePlayer = nil
		local whitelist = {"bamned_alt3"}  -- Username to avoid from getting looped
		local loopKill = {}
	
		local UserInputService = game:GetService("UserInputService")
	
		local function shouldAvoid(player)
			return table.find(whitelist, player.Name) ~= nil
		end
	
		local function isWhitelisted(player)
			return table.find(whitelist, player.Name) ~= nil
		end
	
		local function handleRightArm(v)
			local rightArm = v.Character:FindFirstChild("Right Arm")
			if rightArm then
				rightArm:Destroy()
				local arm = Instance.new("Part")
				arm.Size = Vector3.new(1, 3, 1) -- Adjust size if needed
				arm.Position = v.Character.Torso.Position + Vector3.new(2, 0, 0) -- Adjust position if needed
				arm.Anchored = false
				arm.CanCollide = false
				arm.Color = Color3.new(1, 0, 0) -- Adjust color if needed
				arm.Parent = game.Workspace -- Make sure the arm is visible
			end
		end
	
		-- Function to apply changes to a player character
		local function ApplyChangesToPlayer(player)
			-- Check if the player's character exists
			local character = player.Character
			if character and not shouldAvoid(player) then
				-- Apply the desired changes to the ArmAngleChange remote event
				local armAngleChange = character:FindFirstChild("ArmAngleChange")
				if armAngleChange then
					armAngleChange:FireServer(CFrame.new(9e37, -9e37, 9e37))
				end
	
				-- Apply the desired changes to the HeadWaist
				local HeadWaist = character:FindFirstChild("HeadWaist")
				if HeadWaist then
					HeadWaist:FireServer(CFrame.new(9e37, -9e37, 9e37))
				end
	
				-- Apply the desired changes to the HeadAngleChange remote event
				local headAngleChange = character:FindFirstChild("HeadAngleChange")
				if headAngleChange then
					headAngleChange:FireServer(CFrame.new(9e37, -9e37, 9e37))
				end
	
				-- Instantly kill the player
				local humanoid = character:FindFirstChildOfClass("Humanoid")
				if humanoid then
					humanoid.Health = 0
				end
			end
		end
	
		local function loopActions()
			while loopAll do
				for _, v in ipairs(plrs:GetPlayers()) do
					if v ~= plr and not shouldAvoid(v) then
						pcall(function()
							-- Launch player randomly
							local respawnPosition
							local rand = math.random(1, 4)
							if rand == 1 then
								-- Void
								respawnPosition = Vector3.new(math.random(-50, 50), 1000, math.random(-50, 50)) -- Adjust Y position to make them float
							elseif rand == 2 then
								-- Sideways
								respawnPosition = Vector3.new(math.random(-50, 50), 200, math.random(-50, 50))
							elseif rand == 3 then
								-- Sky
								respawnPosition = Vector3.new(math.random(-50, 50), 500, math.random(-50, 50))
							else
								-- Space
								respawnPosition = Vector3.new(math.random(-50, 50), 1000, math.random(-50, 50)) -- Adjust Y position to make them float
							end
							v.Character:SetPrimaryPartCFrame(CFrame.new(respawnPosition))
							wait(0.0) -- Adjust the wait time if necessary
							plr.Character.Picking:FireServer(v.Character.LowerLeftArm, Vector3.new(9e37, -9e37, 9e37)) -- Adjust the force to a lower value
							wait(0.2) -- Adjust the wait time between picking and putting down
							plr.Character.PuttingDown:FireServer()
	
							-- Apply arm angle change
							local armAngleChange = v.Character:FindFirstChild("ArmAngleChange")
							if armAngleChange then
								armAngleChange:FireServer(CFrame.new(9e37, -9e37, 9e37))
							end
						end)
					end
				end
	
				wait(0.0)
			end
		end
	
		local function loopSinglePlayerActions()
			while loopSinglePlayer do
				local player = loopSinglePlayer
				if player and player.Character and not shouldAvoid(player) then
					pcall(function()
						-- Launch player randomly
						local respawnPosition
						local rand = math.random(1, 4)
						if rand == 1 then
							-- Void
							respawnPosition = Vector3.new(math.random(-50, 50), 1000, math.random(-50, 50)) -- Adjust Y position to make them float
						elseif rand == 2 then
							-- Sideways
							respawnPosition = Vector3.new(math.random(-50, 50), 200, math.random(-50, 50))
						elseif rand == 3 then
							-- Sky
							respawnPosition = Vector3.new(math.random(-50, 50), 500, math.random(-50, 50))
						else
							-- Space
							respawnPosition = Vector3.new(math.random(-50, 50), 1000, math.random(-50, 50)) -- Adjust Y position to make them float
						end
						player.Character:SetPrimaryPartCFrame(CFrame.new(respawnPosition))
						wait(0.0) -- Adjust the wait time if necessary
						plr.Character.Picking:FireServer(player.Character.LowerLeftArm, Vector3.new(9e37, -9e37, 9e37)) -- Adjust the force to a lower value
						wait(0.2) -- Adjust the wait time between picking and putting down
						plr.Character.PuttingDown:FireServer()
	
						-- Apply arm angle change
						local armAngleChange = player.Character:FindFirstChild("ArmAngleChange")
						if armAngleChange then
							armAngleChange:FireServer(CFrame.new(9e37, -9e37, 9e37))
						end
	
						ApplyChangesToPlayer(player)
					end)
				end
	
				wait(0.0)
			end
		end
	
		local function startLoopAll()
			loopAll = true
			spawn(loopActions)
		end
	
		local function stopLoopAll()
			loopAll = false
		end
	
		local function startLoopSinglePlayer(player)
			loopSinglePlayer = player
			spawn(loopSinglePlayerActions)
		end
	
		local function stopLoopSinglePlayer()
			loopSinglePlayer = nil
		end
	
		UserInputService.InputBegan:Connect(function(input, gameProcessed)
			if not gameProcessed and input.KeyCode == Enum.KeyCode.G then
				if loopAll then
					stopLoopAll()
					stopLoopSinglePlayer()
				else
					startLoopAll()
				end
			end
		end)
	
		local function findPlayer(Target)
			if game:GetService("Players"):FindFirstChild(Target) then
				return game:GetService("Players"):FindFirstChild(Target)
			else
				if Target ~= nil and Target ~= "" and Target ~= " " and Target then
					local name = Target
					local found = false
					for _, v in pairs(game:GetService("Players"):GetPlayers()) do
						if not found and (v.Name:lower():sub(1, #name) == name:lower() or v.DisplayName:lower():sub(1, #name) == name:lower()) then
							name = v
							found = true
						end
					end
					if name ~= nil and name ~= Target then
						return name
					end
				end
			end
		end
	
		plr.Chatted:Connect(function(msg)
			local args = msg:lower():split(" ")
			local command = args[1]
			local target = args[2]
	
			if command == prefix .. "wl" and target then
				-- Add player to whitelist
				local playerToAdd = findPlayer(target)
				if playerToAdd and not isWhitelisted(playerToAdd) then
					table.insert(whitelist, playerToAdd.Name)
				end
			elseif command == prefix .. "lol" then
				startLoopAll()
			elseif command == prefix .. "rc" then
				stopLoopAll()
				stopLoopSinglePlayer()
			elseif command == prefix .. "kill" and target then
				-- Add player to loopKill and activate loopAll
				local playerToKill = findPlayer(target)
				if playerToKill then
					startLoopSinglePlayer(playerToKill)
				end
			end
		end)
	
		plr.CharacterAdded:Connect(function(character)
			-- Fling player randomly upon respawn
			local respawnPosition
			local rand = math.random(1, 4)
			if rand == 1 then
				-- Void
				respawnPosition = Vector3.new(math.random(-50, 50), 1000, math.random(-50, 50)) -- Adjust Y position to make them float
			elseif rand == 2 then
				-- Sideways
				respawnPosition = Vector3.new(math.random(-50, 50), 200, math.random(-50, 50))
			elseif rand == 3 then
				-- Sky
				respawnPosition = Vector3.new(math.random(-50, 50), 500, math.random(-50, 50))
			else
				-- Space
				respawnPosition = Vector3.new(math.random(-50, 50), 1000, math.random(-50, 50)) -- Adjust Y position to make them float
			end
			character:SetPrimaryPartCFrame(CFrame.new(respawnPosition))
		end)
	
	end
	
	
	script.Parent.MouseButton1Down:connect(Click)
end
coroutine.wrap(IOLN_fake_script)()
local function YJFO_fake_script() -- instakillv3.right leg 
	local script = Instance.new('Script', instakillv3)

	function Click(mouse)
	
		local prefix = '+'
	
		repeat wait() until game:IsLoaded()
		local plrs = game:GetService("Players")
		local plr = plrs.LocalPlayer
		local loopAll = false
		local loopSinglePlayer = nil
		local whitelist = {"bamned_alt3"}  -- Username to avoid from getting looped
		local loopKill = {}
	
		local UserInputService = game:GetService("UserInputService")
	
		local function shouldAvoid(player)
			return table.find(whitelist, player.Name) ~= nil
		end
	
		local function isWhitelisted(player)
			return table.find(whitelist, player.Name) ~= nil
		end
	
		local function handleRightArm(v)
			local rightArm = v.Character:FindFirstChild("Right Arm")
			if rightArm then
				rightArm:Destroy()
				local arm = Instance.new("Part")
				arm.Size = Vector3.new(1, 3, 1) -- Adjust size if needed
				arm.Position = v.Character.Torso.Position + Vector3.new(2, 0, 0) -- Adjust position if needed
				arm.Anchored = false
				arm.CanCollide = false
				arm.Color = Color3.new(1, 0, 0) -- Adjust color if needed
				arm.Parent = game.Workspace -- Make sure the arm is visible
			end
		end
	
		-- Function to apply changes to a player character
		local function ApplyChangesToPlayer(player)
			-- Check if the player's character exists
			local character = player.Character
			if character and not shouldAvoid(player) then
				-- Apply the desired changes to the ArmAngleChange remote event
				local armAngleChange = character:FindFirstChild("ArmAngleChange")
				if armAngleChange then
					armAngleChange:FireServer(CFrame.new(9e37, -9e37, 9e37))
				end
	
				-- Apply the desired changes to the HeadWaist
				local HeadWaist = character:FindFirstChild("HeadWaist")
				if HeadWaist then
					HeadWaist:FireServer(CFrame.new(9e37, -9e37, 9e37))
				end
	
				-- Apply the desired changes to the HeadAngleChange remote event
				local headAngleChange = character:FindFirstChild("HeadAngleChange")
				if headAngleChange then
					headAngleChange:FireServer(CFrame.new(9e37, -9e37, 9e37))
				end
	
				-- Instantly kill the player
				local humanoid = character:FindFirstChildOfClass("Humanoid")
				if humanoid then
					humanoid.Health = 0
				end
			end
		end
	
		local function loopActions()
			while loopAll do
				for _, v in ipairs(plrs:GetPlayers()) do
					if v ~= plr and not shouldAvoid(v) then
						pcall(function()
							-- Launch player randomly
							local respawnPosition
							local rand = math.random(1, 4)
							if rand == 1 then
								-- Void
								respawnPosition = Vector3.new(math.random(-50, 50), 1000, math.random(-50, 50)) -- Adjust Y position to make them float
							elseif rand == 2 then
								-- Sideways
								respawnPosition = Vector3.new(math.random(-50, 50), 200, math.random(-50, 50))
							elseif rand == 3 then
								-- Sky
								respawnPosition = Vector3.new(math.random(-50, 50), 500, math.random(-50, 50))
							else
								-- Space
								respawnPosition = Vector3.new(math.random(-50, 50), 1000, math.random(-50, 50)) -- Adjust Y position to make them float
							end
							v.Character:SetPrimaryPartCFrame(CFrame.new(respawnPosition))
							wait(0.0) -- Adjust the wait time if necessary
							plr.Character.Picking:FireServer(v.Character.LowerRightLeg, Vector3.new(9e37, -9e37, 9e37)) -- Adjust the force to a lower value
							wait(0.2) -- Adjust the wait time between picking and putting down
							plr.Character.PuttingDown:FireServer()
	
							-- Apply arm angle change
							local armAngleChange = v.Character:FindFirstChild("ArmAngleChange")
							if armAngleChange then
								armAngleChange:FireServer(CFrame.new(9e37, -9e37, 9e37))
							end
						end)
					end
				end
	
				wait(0.0)
			end
		end
	
		local function loopSinglePlayerActions()
			while loopSinglePlayer do
				local player = loopSinglePlayer
				if player and player.Character and not shouldAvoid(player) then
					pcall(function()
						-- Launch player randomly
						local respawnPosition
						local rand = math.random(1, 4)
						if rand == 1 then
							-- Void
							respawnPosition = Vector3.new(math.random(-50, 50), 1000, math.random(-50, 50)) -- Adjust Y position to make them float
						elseif rand == 2 then
							-- Sideways
							respawnPosition = Vector3.new(math.random(-50, 50), 200, math.random(-50, 50))
						elseif rand == 3 then
							-- Sky
							respawnPosition = Vector3.new(math.random(-50, 50), 500, math.random(-50, 50))
						else
							-- Space
							respawnPosition = Vector3.new(math.random(-50, 50), 1000, math.random(-50, 50)) -- Adjust Y position to make them float
						end
						player.Character:SetPrimaryPartCFrame(CFrame.new(respawnPosition))
						wait(0.0) -- Adjust the wait time if necessary
						plr.Character.Picking:FireServer(player.Character.LowerRightLeg, Vector3.new(9e37, -9e37, 9e37)) -- Adjust the force to a lower value
						wait(0.2) -- Adjust the wait time between picking and putting down
						plr.Character.PuttingDown:FireServer()
	
						-- Apply arm angle change
						local armAngleChange = player.Character:FindFirstChild("ArmAngleChange")
						if armAngleChange then
							armAngleChange:FireServer(CFrame.new(9e37, -9e37, 9e37))
						end
	
						ApplyChangesToPlayer(player)
					end)
				end
	
				wait(0.0)
			end
		end
	
		local function startLoopAll()
			loopAll = true
			spawn(loopActions)
		end
	
		local function stopLoopAll()
			loopAll = false
		end
	
		local function startLoopSinglePlayer(player)
			loopSinglePlayer = player
			spawn(loopSinglePlayerActions)
		end
	
		local function stopLoopSinglePlayer()
			loopSinglePlayer = nil
		end
	
		UserInputService.InputBegan:Connect(function(input, gameProcessed)
			if not gameProcessed and input.KeyCode == Enum.KeyCode.G then
				if loopAll then
					stopLoopAll()
					stopLoopSinglePlayer()
				else
					startLoopAll()
				end
			end
		end)
	
		local function findPlayer(Target)
			if game:GetService("Players"):FindFirstChild(Target) then
				return game:GetService("Players"):FindFirstChild(Target)
			else
				if Target ~= nil and Target ~= "" and Target ~= " " and Target then
					local name = Target
					local found = false
					for _, v in pairs(game:GetService("Players"):GetPlayers()) do
						if not found and (v.Name:lower():sub(1, #name) == name:lower() or v.DisplayName:lower():sub(1, #name) == name:lower()) then
							name = v
							found = true
						end
					end
					if name ~= nil and name ~= Target then
						return name
					end
				end
			end
		end
	
		plr.Chatted:Connect(function(msg)
			local args = msg:lower():split(" ")
			local command = args[1]
			local target = args[2]
	
			if command == prefix .. "wl" and target then
				-- Add player to whitelist
				local playerToAdd = findPlayer(target)
				if playerToAdd and not isWhitelisted(playerToAdd) then
					table.insert(whitelist, playerToAdd.Name)
				end
			elseif command == prefix .. "lol" then
				startLoopAll()
			elseif command == prefix .. "rc" then
				stopLoopAll()
				stopLoopSinglePlayer()
			elseif command == prefix .. "kill" and target then
				-- Add player to loopKill and activate loopAll
				local playerToKill = findPlayer(target)
				if playerToKill then
					startLoopSinglePlayer(playerToKill)
				end
			end
		end)
	
		plr.CharacterAdded:Connect(function(character)
			-- Fling player randomly upon respawn
			local respawnPosition
			local rand = math.random(1, 4)
			if rand == 1 then
				-- Void
				respawnPosition = Vector3.new(math.random(-50, 50), 1000, math.random(-50, 50)) -- Adjust Y position to make them float
			elseif rand == 2 then
				-- Sideways
				respawnPosition = Vector3.new(math.random(-50, 50), 200, math.random(-50, 50))
			elseif rand == 3 then
				-- Sky
				respawnPosition = Vector3.new(math.random(-50, 50), 500, math.random(-50, 50))
			else
				-- Space
				respawnPosition = Vector3.new(math.random(-50, 50), 1000, math.random(-50, 50)) -- Adjust Y position to make them float
			end
			character:SetPrimaryPartCFrame(CFrame.new(respawnPosition))
		end)
	
	end
	
	
	script.Parent.MouseButton1Down:connect(Click)
end
coroutine.wrap(YJFO_fake_script)()
local function EPXX_fake_script() -- instakillv3.head 
	local script = Instance.new('Script', instakillv3)

	function Click(mouse)
	
		local prefix = '+'
	
		repeat wait() until game:IsLoaded()
		local plrs = game:GetService("Players")
		local plr = plrs.LocalPlayer
		local loopAll = false
		local loopSinglePlayer = nil
		local whitelist = {"bamned_alt3"}  -- Username to avoid from getting looped
		local loopKill = {}
	
		local UserInputService = game:GetService("UserInputService")
	
		local function shouldAvoid(player)
			return table.find(whitelist, player.Name) ~= nil
		end
	
		local function isWhitelisted(player)
			return table.find(whitelist, player.Name) ~= nil
		end
	
		local function handleRightArm(v)
			local rightArm = v.Character:FindFirstChild("Right Arm")
			if rightArm then
				rightArm:Destroy()
				local arm = Instance.new("Part")
				arm.Size = Vector3.new(1, 3, 1) -- Adjust size if needed
				arm.Position = v.Character.Torso.Position + Vector3.new(2, 0, 0) -- Adjust position if needed
				arm.Anchored = false
				arm.CanCollide = false
				arm.Color = Color3.new(1, 0, 0) -- Adjust color if needed
				arm.Parent = game.Workspace -- Make sure the arm is visible
			end
		end
	
		-- Function to apply changes to a player character
		local function ApplyChangesToPlayer(player)
			-- Check if the player's character exists
			local character = player.Character
			if character and not shouldAvoid(player) then
				-- Apply the desired changes to the ArmAngleChange remote event
				local armAngleChange = character:FindFirstChild("ArmAngleChange")
				if armAngleChange then
					armAngleChange:FireServer(CFrame.new(9e37, -9e37, 9e37))
				end
	
				-- Apply the desired changes to the HeadWaist
				local HeadWaist = character:FindFirstChild("HeadWaist")
				if HeadWaist then
					HeadWaist:FireServer(CFrame.new(9e37, -9e37, 9e37))
				end
	
				-- Apply the desired changes to the HeadAngleChange remote event
				local headAngleChange = character:FindFirstChild("HeadAngleChange")
				if headAngleChange then
					headAngleChange:FireServer(CFrame.new(9e37, -9e37, 9e37))
				end
	
				-- Instantly kill the player
				local humanoid = character:FindFirstChildOfClass("Humanoid")
				if humanoid then
					humanoid.Health = 0
				end
			end
		end
	
		local function loopActions()
			while loopAll do
				for _, v in ipairs(plrs:GetPlayers()) do
					if v ~= plr and not shouldAvoid(v) then
						pcall(function()
							-- Launch player randomly
							local respawnPosition
							local rand = math.random(1, 4)
							if rand == 1 then
								-- Void
								respawnPosition = Vector3.new(math.random(-50, 50), 1000, math.random(-50, 50)) -- Adjust Y position to make them float
							elseif rand == 2 then
								-- Sideways
								respawnPosition = Vector3.new(math.random(-50, 50), 200, math.random(-50, 50))
							elseif rand == 3 then
								-- Sky
								respawnPosition = Vector3.new(math.random(-50, 50), 500, math.random(-50, 50))
							else
								-- Space
								respawnPosition = Vector3.new(math.random(-50, 50), 1000, math.random(-50, 50)) -- Adjust Y position to make them float
							end
							v.Character:SetPrimaryPartCFrame(CFrame.new(respawnPosition))
							wait(0.0) -- Adjust the wait time if necessary
							plr.Character.Picking:FireServer(v.Character.Head, Vector3.new(9e37, -9e37, 9e37)) -- Adjust the force to a lower value
							wait(0.2) -- Adjust the wait time between picking and putting down
							plr.Character.PuttingDown:FireServer()
	
							-- Apply arm angle change
							local armAngleChange = v.Character:FindFirstChild("ArmAngleChange")
							if armAngleChange then
								armAngleChange:FireServer(CFrame.new(9e37, -9e37, 9e37))
							end
						end)
					end
				end
	
				wait(0.0)
			end
		end
	
		local function loopSinglePlayerActions()
			while loopSinglePlayer do
				local player = loopSinglePlayer
				if player and player.Character and not shouldAvoid(player) then
					pcall(function()
						-- Launch player randomly
						local respawnPosition
						local rand = math.random(1, 4)
						if rand == 1 then
							-- Void
							respawnPosition = Vector3.new(math.random(-50, 50), 1000, math.random(-50, 50)) -- Adjust Y position to make them float
						elseif rand == 2 then
							-- Sideways
							respawnPosition = Vector3.new(math.random(-50, 50), 200, math.random(-50, 50))
						elseif rand == 3 then
							-- Sky
							respawnPosition = Vector3.new(math.random(-50, 50), 500, math.random(-50, 50))
						else
							-- Space
							respawnPosition = Vector3.new(math.random(-50, 50), 1000, math.random(-50, 50)) -- Adjust Y position to make them float
						end
						player.Character:SetPrimaryPartCFrame(CFrame.new(respawnPosition))
						wait(0.0) -- Adjust the wait time if necessary
						plr.Character.Picking:FireServer(player.Character.Head, Vector3.new(9e37, -9e37, 9e37)) -- Adjust the force to a lower value
						wait(0.2) -- Adjust the wait time between picking and putting down
						plr.Character.PuttingDown:FireServer()
	
						-- Apply arm angle change
						local armAngleChange = player.Character:FindFirstChild("ArmAngleChange")
						if armAngleChange then
							armAngleChange:FireServer(CFrame.new(9e37, -9e37, 9e37))
						end
	
						ApplyChangesToPlayer(player)
					end)
				end
	
				wait(0.0)
			end
		end
	
		local function startLoopAll()
			loopAll = true
			spawn(loopActions)
		end
	
		local function stopLoopAll()
			loopAll = false
		end
	
		local function startLoopSinglePlayer(player)
			loopSinglePlayer = player
			spawn(loopSinglePlayerActions)
		end
	
		local function stopLoopSinglePlayer()
			loopSinglePlayer = nil
		end
	
		UserInputService.InputBegan:Connect(function(input, gameProcessed)
			if not gameProcessed and input.KeyCode == Enum.KeyCode.G then
				if loopAll then
					stopLoopAll()
					stopLoopSinglePlayer()
				else
					startLoopAll()
				end
			end
		end)
	
		local function findPlayer(Target)
			if game:GetService("Players"):FindFirstChild(Target) then
				return game:GetService("Players"):FindFirstChild(Target)
			else
				if Target ~= nil and Target ~= "" and Target ~= " " and Target then
					local name = Target
					local found = false
					for _, v in pairs(game:GetService("Players"):GetPlayers()) do
						if not found and (v.Name:lower():sub(1, #name) == name:lower() or v.DisplayName:lower():sub(1, #name) == name:lower()) then
							name = v
							found = true
						end
					end
					if name ~= nil and name ~= Target then
						return name
					end
				end
			end
		end
	
		plr.Chatted:Connect(function(msg)
			local args = msg:lower():split(" ")
			local command = args[1]
			local target = args[2]
	
			if command == prefix .. "wl" and target then
				-- Add player to whitelist
				local playerToAdd = findPlayer(target)
				if playerToAdd and not isWhitelisted(playerToAdd) then
					table.insert(whitelist, playerToAdd.Name)
				end
			elseif command == prefix .. "lol" then
				startLoopAll()
			elseif command == prefix .. "rc" then
				stopLoopAll()
				stopLoopSinglePlayer()
			elseif command == prefix .. "kill" and target then
				-- Add player to loopKill and activate loopAll
				local playerToKill = findPlayer(target)
				if playerToKill then
					startLoopSinglePlayer(playerToKill)
				end
			end
		end)
	
		plr.CharacterAdded:Connect(function(character)
			-- Fling player randomly upon respawn
			local respawnPosition
			local rand = math.random(1, 4)
			if rand == 1 then
				-- Void
				respawnPosition = Vector3.new(math.random(-50, 50), 1000, math.random(-50, 50)) -- Adjust Y position to make them float
			elseif rand == 2 then
				-- Sideways
				respawnPosition = Vector3.new(math.random(-50, 50), 200, math.random(-50, 50))
			elseif rand == 3 then
				-- Sky
				respawnPosition = Vector3.new(math.random(-50, 50), 500, math.random(-50, 50))
			else
				-- Space
				respawnPosition = Vector3.new(math.random(-50, 50), 1000, math.random(-50, 50)) -- Adjust Y position to make them float
			end
			character:SetPrimaryPartCFrame(CFrame.new(respawnPosition))
		end)
	
	end
	
	
	script.Parent.MouseButton1Down:connect(Click)
end
coroutine.wrap(EPXX_fake_script)()
local function ORGHY_fake_script() -- instakillv3.leftleg 
	local script = Instance.new('Script', instakillv3)

	function Click(mouse)
	
		local prefix = '+'
	
		repeat wait() until game:IsLoaded()
		local plrs = game:GetService("Players")
		local plr = plrs.LocalPlayer
		local loopAll = false
		local loopSinglePlayer = nil
		local whitelist = {"bamned_alt3"}  -- Username to avoid from getting looped
		local loopKill = {}
	
		local UserInputService = game:GetService("UserInputService")
	
		local function shouldAvoid(player)
			return table.find(whitelist, player.Name) ~= nil
		end
	
		local function isWhitelisted(player)
			return table.find(whitelist, player.Name) ~= nil
		end
	
		local function handleRightArm(v)
			local rightArm = v.Character:FindFirstChild("Right Arm")
			if rightArm then
				rightArm:Destroy()
				local arm = Instance.new("Part")
				arm.Size = Vector3.new(1, 3, 1) -- Adjust size if needed
				arm.Position = v.Character.Torso.Position + Vector3.new(2, 0, 0) -- Adjust position if needed
				arm.Anchored = false
				arm.CanCollide = false
				arm.Color = Color3.new(1, 0, 0) -- Adjust color if needed
				arm.Parent = game.Workspace -- Make sure the arm is visible
			end
		end
	
		-- Function to apply changes to a player character
		local function ApplyChangesToPlayer(player)
			-- Check if the player's character exists
			local character = player.Character
			if character and not shouldAvoid(player) then
				-- Apply the desired changes to the ArmAngleChange remote event
				local armAngleChange = character:FindFirstChild("ArmAngleChange")
				if armAngleChange then
					armAngleChange:FireServer(CFrame.new(9e37, -9e37, 9e37))
				end
	
				-- Apply the desired changes to the HeadWaist
				local HeadWaist = character:FindFirstChild("HeadWaist")
				if HeadWaist then
					HeadWaist:FireServer(CFrame.new(9e37, -9e37, 9e37))
				end
	
				-- Apply the desired changes to the HeadAngleChange remote event
				local headAngleChange = character:FindFirstChild("HeadAngleChange")
				if headAngleChange then
					headAngleChange:FireServer(CFrame.new(9e37, -9e37, 9e37))
				end
	
				-- Instantly kill the player
				local humanoid = character:FindFirstChildOfClass("Humanoid")
				if humanoid then
					humanoid.Health = 0
				end
			end
		end
	
		local function loopActions()
			while loopAll do
				for _, v in ipairs(plrs:GetPlayers()) do
					if v ~= plr and not shouldAvoid(v) then
						pcall(function()
							-- Launch player randomly
							local respawnPosition
							local rand = math.random(1, 4)
							if rand == 1 then
								-- Void
								respawnPosition = Vector3.new(math.random(-50, 50), 1000, math.random(-50, 50)) -- Adjust Y position to make them float
							elseif rand == 2 then
								-- Sideways
								respawnPosition = Vector3.new(math.random(-50, 50), 200, math.random(-50, 50))
							elseif rand == 3 then
								-- Sky
								respawnPosition = Vector3.new(math.random(-50, 50), 500, math.random(-50, 50))
							else
								-- Space
								respawnPosition = Vector3.new(math.random(-50, 50), 1000, math.random(-50, 50)) -- Adjust Y position to make them float
							end
							v.Character:SetPrimaryPartCFrame(CFrame.new(respawnPosition))
							wait(0.0) -- Adjust the wait time if necessary
							plr.Character.Picking:FireServer(v.Character.LowerLeftLeg, Vector3.new(9e37, -9e37, 9e37)) -- Adjust the force to a lower value
							wait(0.2) -- Adjust the wait time between picking and putting down
							plr.Character.PuttingDown:FireServer()
	
							-- Apply arm angle change
							local armAngleChange = v.Character:FindFirstChild("ArmAngleChange")
							if armAngleChange then
								armAngleChange:FireServer(CFrame.new(9e37, -9e37, 9e37))
							end
						end)
					end
				end
	
				wait(0.0)
			end
		end
	
		local function loopSinglePlayerActions()
			while loopSinglePlayer do
				local player = loopSinglePlayer
				if player and player.Character and not shouldAvoid(player) then
					pcall(function()
						-- Launch player randomly
						local respawnPosition
						local rand = math.random(1, 4)
						if rand == 1 then
							-- Void
							respawnPosition = Vector3.new(math.random(-50, 50), 1000, math.random(-50, 50)) -- Adjust Y position to make them float
						elseif rand == 2 then
							-- Sideways
							respawnPosition = Vector3.new(math.random(-50, 50), 200, math.random(-50, 50))
						elseif rand == 3 then
							-- Sky
							respawnPosition = Vector3.new(math.random(-50, 50), 500, math.random(-50, 50))
						else
							-- Space
							respawnPosition = Vector3.new(math.random(-50, 50), 1000, math.random(-50, 50)) -- Adjust Y position to make them float
						end
						player.Character:SetPrimaryPartCFrame(CFrame.new(respawnPosition))
						wait(0.0) -- Adjust the wait time if necessary
						plr.Character.Picking:FireServer(player.Character.LowerleftLeg, Vector3.new(9e37, -9e37, 9e37)) -- Adjust the force to a lower value
						wait(0.2) -- Adjust the wait time between picking and putting down
						plr.Character.PuttingDown:FireServer()
	
						-- Apply arm angle change
						local armAngleChange = player.Character:FindFirstChild("ArmAngleChange")
						if armAngleChange then
							armAngleChange:FireServer(CFrame.new(9e37, -9e37, 9e37))
						end
	
						ApplyChangesToPlayer(player)
					end)
				end
	
				wait(0.0)
			end
		end
	
		local function startLoopAll()
			loopAll = true
			spawn(loopActions)
		end
	
		local function stopLoopAll()
			loopAll = false
		end
	
		local function startLoopSinglePlayer(player)
			loopSinglePlayer = player
			spawn(loopSinglePlayerActions)
		end
	
		local function stopLoopSinglePlayer()
			loopSinglePlayer = nil
		end
	
		UserInputService.InputBegan:Connect(function(input, gameProcessed)
			if not gameProcessed and input.KeyCode == Enum.KeyCode.G then
				if loopAll then
					stopLoopAll()
					stopLoopSinglePlayer()
				else
					startLoopAll()
				end
			end
		end)
	
		local function findPlayer(Target)
			if game:GetService("Players"):FindFirstChild(Target) then
				return game:GetService("Players"):FindFirstChild(Target)
			else
				if Target ~= nil and Target ~= "" and Target ~= " " and Target then
					local name = Target
					local found = false
					for _, v in pairs(game:GetService("Players"):GetPlayers()) do
						if not found and (v.Name:lower():sub(1, #name) == name:lower() or v.DisplayName:lower():sub(1, #name) == name:lower()) then
							name = v
							found = true
						end
					end
					if name ~= nil and name ~= Target then
						return name
					end
				end
			end
		end
	
		plr.Chatted:Connect(function(msg)
			local args = msg:lower():split(" ")
			local command = args[1]
			local target = args[2]
	
			if command == prefix .. "wl" and target then
				-- Add player to whitelist
				local playerToAdd = findPlayer(target)
				if playerToAdd and not isWhitelisted(playerToAdd) then
					table.insert(whitelist, playerToAdd.Name)
				end
			elseif command == prefix .. "lol" then
				startLoopAll()
			elseif command == prefix .. "rc" then
				stopLoopAll()
				stopLoopSinglePlayer()
			elseif command == prefix .. "kill" and target then
				-- Add player to loopKill and activate loopAll
				local playerToKill = findPlayer(target)
				if playerToKill then
					startLoopSinglePlayer(playerToKill)
				end
			end
		end)
	
		plr.CharacterAdded:Connect(function(character)
			-- Fling player randomly upon respawn
			local respawnPosition
			local rand = math.random(1, 4)
			if rand == 1 then
				-- Void
				respawnPosition = Vector3.new(math.random(-50, 50), 1000, math.random(-50, 50)) -- Adjust Y position to make them float
			elseif rand == 2 then
				-- Sideways
				respawnPosition = Vector3.new(math.random(-50, 50), 200, math.random(-50, 50))
			elseif rand == 3 then
				-- Sky
				respawnPosition = Vector3.new(math.random(-50, 50), 500, math.random(-50, 50))
			else
				-- Space
				respawnPosition = Vector3.new(math.random(-50, 50), 1000, math.random(-50, 50)) -- Adjust Y position to make them float
			end
			character:SetPrimaryPartCFrame(CFrame.new(respawnPosition))
		end)
	
	end
	
	
	script.Parent.MouseButton1Down:connect(Click)
end
coroutine.wrap(ORGHY_fake_script)()
local function WETZ_fake_script() -- hyperloop1.script2 
	local script = Instance.new('Script', hyperloop1)

	function Click(mouse)
	
		loadstring(game:HttpGet("https://raw.githubusercontent.com/Jlchris1/fshkj.htrhj/main/l%3Bkjhuyftsedfrhjyft"))()
	
	end
	
	
	script.Parent.MouseButton1Down:connect(Click)
end
coroutine.wrap(WETZ_fake_script)()
local function HMYTDW_fake_script() -- hyperloop1.script1 
	local script = Instance.new('Script', hyperloop1)

	function Click(mouse)
	
		loadstring(game:HttpGet("https://raw.githubusercontent.com/Jlchris1/Udklol/refs/heads/main/hl1"))()
	
	end
	
	
	script.Parent.MouseButton1Down:connect(Click)
end
coroutine.wrap(HMYTDW_fake_script)()
local function WAICTFA_fake_script() -- severeanti.Script 
	local script = Instance.new('Script', severeanti)

	function Click(mouse)
	
		loadstring(game:HttpGet("https://raw.githubusercontent.com/Jlchris1/Udklol/refs/heads/main/antis"))()
	
	end
	
	
	script.Parent.MouseButton1Down:connect(Click)
end
coroutine.wrap(WAICTFA_fake_script)()
local function PBTN_fake_script() -- armanlegui.Script 
	local script = Instance.new('Script', armanlegui)

	function Click(mouse)
	
		loadstring(game:HttpGet("https://raw.githubusercontent.com/Jlchris1/Udklol/refs/heads/main/armgui"))()
	
	end
	
	
	script.Parent.MouseButton1Down:connect(Click)
end
coroutine.wrap(PBTN_fake_script)()
local function IUOP_fake_script() -- anvilkillall.Script 
	local script = Instance.new('Script', anvilkillall)

	function Click(mouse)
	
		local Players = game:GetService("Players")
		local RunService = game:GetService("RunService")
	
		-- Set the height at which parts get destroyed
		game.Workspace.FallenPartsDestroyHeight = 0/0
	
		local pullRadius = math.huge
		local orbitDistance = 0 -- Set orbit distance to 0
		local orbitHeight = 2
		local orbitSpeed = 90000000 -- Set orbit speed to 9000000
		local isPullActive = false
		local isArcMode = false
		local pulledAnvils = {} -- List to track pulled anvils
		local akillTargets = {} -- List of target players for +akill
		local akillLoopConnection
		local currentTargetIndex = 1 -- Index to track current target
		local orbitConnections = {}
		local standardVelocity = -8.999999813669171e+37 -- Standard velocity for orbiting anvils
		local whitelist = {} -- Whitelist to prevent targeting certain players
		local trackedPlayerIDs = {} -- Track player IDs for the anti-rejoin feature
		local spinAmount = 0 -- Spin amount for visual effect
	
		-- Function to set up an anvil for orbiting
		local function setupAnvil(anvil)
			anvil.Anchored = false
			anvil.CanCollide = false
			anvil.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)
		end
	
		-- Function to start orbiting an anvil around the player
		local function startOrbit(anvil)
			setupAnvil(anvil)
			pulledAnvils[anvil] = true -- Add to pulled anvils list
			local angle = 0
	
			local anvilConnection = RunService.Heartbeat:Connect(function()
				if pulledAnvils[anvil] then
					angle = angle + orbitSpeed
					local rootPartPosition = Players.LocalPlayer.Character.HumanoidRootPart.Position
					anvil.Position = rootPartPosition + Vector3.new(
						math.cos(math.rad(angle)) * orbitDistance,
						orbitHeight,
						math.sin(math.rad(angle)) * orbitDistance
					)
					anvil.CFrame = CFrame.new(anvil.Position, rootPartPosition)
	
					-- Apply velocity to the anvil
					anvil.Velocity = (anvil.Position - rootPartPosition).unit * standardVelocity
				else
					anvilConnection:Disconnect()
				end
			end)
	
			table.insert(orbitConnections, anvilConnection)
		end
	
		-- Function to pull anvils in radius
		local function pullAnvilsInRadius()
			if Players.LocalPlayer.Character then
				local rootPart = Players.LocalPlayer.Character.HumanoidRootPart
				for _, anvil in pairs(workspace:GetChildren()) do
					if anvil:IsA("MeshPart") and anvil.Name == "Anvil" and (anvil.Position - rootPart.Position).magnitude <= pullRadius then
						if not pulledAnvils[anvil] then
							startOrbit(anvil) -- Start orbiting around the player
						end
						-- Here, we can also implement the old pull logic
						anvil.Position = anvil.Position:Lerp(rootPart.Position, 0.1) -- Smooth pull towards the player
					end
				end
			end
		end
	
		-- Function to stop all targeting actions
		local function stopTargetingLoops()
			if akillLoopConnection then
				akillLoopConnection:Disconnect()
				akillLoopConnection = nil
			end
			akillTargets = {} -- Clear target list
			currentTargetIndex = 1 -- Reset index
		end
	
		-- Function to handle +akill logic and reposition all existing anvils
		local function handleAkill()
			if #akillTargets > 0 then
				local targetPlayer = akillTargets[currentTargetIndex]
				if targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
					local targetPosition = targetPlayer.Character.HumanoidRootPart.Position
	
					-- Reset existing anvils to orbit the target player
					for anvil in pairs(pulledAnvils) do
						if anvil:IsA("MeshPart") and anvil.Name == "Anvil" and not whitelist[targetPlayer.Name] then
							anvil.Position = targetPosition -- Move existing anvils to the target player's position
						end
					end
	
					-- Set up the loop for targeting the current player
					akillLoopConnection = RunService.Heartbeat:Connect(function()
						if #akillTargets > 0 then
							local currentTarget = akillTargets[currentTargetIndex]
							if currentTarget and currentTarget.Character and currentTarget.Character:FindFirstChild("HumanoidRootPart") then
								local currentTargetPosition = currentTarget.Character.HumanoidRootPart.Position
								for anvil in pairs(pulledAnvils) do -- Target existing and new anvils
									if anvil:IsA("MeshPart") and anvil.Name == "Anvil" and not whitelist[currentTarget.Name] then
										anvil.Position = currentTargetPosition
									end
								end
							end
							currentTargetIndex = currentTargetIndex % #akillTargets + 1 -- Move to the next target
						end
						wait(0.15)
					end)
				end
			end
		end
	
		-- Function to apply a spin effect
		local function applySpinEffect()
			if Players.LocalPlayer.Character and Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
				local rootPart = Players.LocalPlayer.Character.HumanoidRootPart
				while true do
					rootPart.CFrame = rootPart.CFrame * CFrame.Angles(0, math.rad(spinAmount), 0) -- Spin around Y-axis
					wait(0.1) -- Adjust for desired spin speed
				end
			end
		end
	
		-- Function to handle player joining
		local function onPlayerAdded(player)
			player.CharacterAdded:Connect(function(character)
				wait(1) -- Allow some time for character to stabilize
	
				-- Check if this player is in the tracked player IDs for targeting
				if trackedPlayerIDs[player.UserId] then
					akillTargets[#akillTargets + 1] = player -- Add to akill targets
					print(player.Name .. " has rejoined and has been targeted again.")
					handleAkill() -- Call to start targeting the player again
				end
			end)
		end
	
		-- Chat command handler
		local function onChatMessage(message)
			local args = string.split(message, " ")
			local command = args[1]
	
			if command == "+start" then
				isPullActive = true
				print("Pull activated. Equip the Anvil tool to start pulling anvils.")
				applySpinEffect() -- Start applying the spin effect
			elseif command == "+stop" then
				isPullActive = false
				stopTargetingLoops() -- Stop all targeting actions
				print("All actions deactivated. Anvils will no longer pull or orbit.")
			elseif command == "+arc" then
				isArcMode = true
				stopTargetingLoops() -- Stop targeting actions
				print("Arc mode activated. All targeting and pulling actions stopped.")
			elseif command == "-arc" then
				isArcMode = false
				isPullActive = true
				print("Arc mode deactivated. You can now pull anvils again.")
			elseif command == "+rc" then
				stopTargetingLoops() -- Stop all targeting actions
				isPullActive = true -- Keep pulling active
				local closestPlayer = nil
				local closestDistance = math.huge
	
				-- Find the closest match of the chatted display name or username
				for _, player in pairs(Players:GetPlayers()) do
					if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
						local distance = (Players.LocalPlayer.Character.HumanoidRootPart.Position - player.Character.HumanoidRootPart.Position).magnitude
						if (player.DisplayName:lower():find(args[2]:lower()) or player.Name:lower():find(args[2]:lower())) and distance < closestDistance and not whitelist[player.Name] then
							closestDistance = distance
							closestPlayer = player
						end
					end
				end
	
				if closestPlayer then
					akillTargets[#akillTargets + 1] = closestPlayer -- Add the closest player to akill targets
					print(closestPlayer.Name .. " has been added to akill targets.")
					handleAkill() -- Start targeting the new player
				else
					print("No player matched the name for akill.")
				end
			elseif command == "+killall" then
				stopTargetingLoops() -- Stop all targeting actions
				for _, player in pairs(Players:GetPlayers()) do
					if not whitelist[player.Name] then
						akillTargets[#akillTargets + 1] = player -- Add all players to akill targets
					end
				end
				handleAkill() -- Start targeting all players
				print("+killall command executed. Anvils will now target all players.")
			elseif command == "+reset" then
				for _, anvil in pairs(pulledAnvils) do
					if anvil:IsA("MeshPart") and anvil.Name == "Anvil" then
						anvil:Destroy() -- Destroy existing anvils
					end
				end
				pulledAnvils = {} -- Clear the pulled anvils list
				handleAkill() -- Start the akill function
			elseif command == "+akill" and args[2] then
				local targetName = args[2]:lower()
				for _, player in pairs(Players:GetPlayers()) do
					if (player.Name:lower():find(targetName) or player.DisplayName:lower():find(targetName)) and not whitelist[player.Name] then
						akillTargets[#akillTargets + 1] = player -- Add player to akill targets
						print(player.Name .. " has been added to akill targets.")
						handleAkill() -- Call to start targeting the player
						return
					end
				end
				print("No player matched the name for akill.")
			elseif command == "+setspeed" and args[2] then
				local newSpeed = tonumber(args[2])
				if newSpeed then
					orbitSpeed = newSpeed
					print("Orbit speed set to:", orbitSpeed)
				else
					print("Invalid speed value.")
				end
			elseif command == "+spinradius" and args[2] then
				local newRadius = tonumber(args[2])
				if newRadius then
					orbitDistance = newRadius
					print("Orbit radius set to:", orbitDistance)
				else
					print("Invalid radius value.")
				end
			elseif command == "+spinheight" and args[2] then
				local newHeight = tonumber(args[2])
				if newHeight then
					orbitHeight = newHeight
					print("Orbit height set to:", orbitHeight)
				else
					print("Invalid height value.")
				end
			elseif command == "+wl" and args[2] then
				local targetName = args[2]:lower()
				for _, player in pairs(Players:GetPlayers()) do
					if (player.Name:lower():find(targetName) or player.DisplayName:lower():find(targetName)) then
						whitelist[player.Name] = true -- Add player to the whitelist
						print(player.Name .. " has been whitelisted.")
						return
					end
				end
				print("No player matched the name for whitelisting.")
			end
		end
	
		Players.LocalPlayer.Chatted:Connect(onChatMessage)
	
		-- Ensure pull only happens when the Anvil tool is equipped
		local function handleCharacter(character)
			local anvilTool = character:WaitForChild("Anvil", 10) -- Wait for the tool to be present in character
	
			while true do
				if anvilTool then
					isPullActive = true
					while anvilTool.Parent == character do
						pullAnvilsInRadius()
						wait(0.1)
					end
					isPullActive = false
				end
				wait(1) -- Wait for a moment before checking again
			end
		end
	
		-- Monitor character changes
		Players.LocalPlayer.CharacterAdded:Connect(function(character)
			wait(1) -- Allow some time for character to stabilize
			handleCharacter(character)
		end)
	
		-- Monitor players joining
		Players.PlayerAdded:Connect(onPlayerAdded)
	
		-- Initial character setup
		if Players.LocalPlayer.Character then
			handleCharacter(Players.LocalPlayer.Character)
		end
	
	
	
	end
	
	
	script.Parent.MouseButton1Down:connect(Click)
end
coroutine.wrap(IUOP_fake_script)()
local function HJNA_fake_script() -- dmgsfxspamall.Script 
	local script = Instance.new('Script', dmgsfxspamall)

	function Click(mouse)
	
		_G.toggle = true
	
		while _G.toggle do
			wait()
			local Players = game:GetService("Players")
	
			-- Function to fire Damage event for each player except the local player
			local function fireDamageEventForAllPlayers()
				local localPlayer = Players.LocalPlayer  -- Get the LocalPlayer reference
	
				for _, player in ipairs(Players:GetPlayers()) do
					-- Use pcall to handle potential errors
					pcall(function()
						-- Skip the LocalPlayer
						if player == localPlayer then return end
	
						-- Check if the player's character exists
						local character = player.Character or player.CharacterAdded:Wait()
	
						-- Check if the Damage event exists in the character
						local damageEvent = character:FindFirstChild("Damage")
						if damageEvent then
							damageEvent:FireServer()  -- Fire the Damage event for this player
							print("Fired Damage event for " .. player.Name)  -- Debug message
						else
							print(player.Name .. " does not have a Damage event.")  -- Debug message
						end
					end)
				end
			end
	
			-- Call the function to fire Damage event for all players
			fireDamageEventForAllPlayers()
	
			-- Optionally, listen for new players joining the game
			Players.PlayerAdded:Connect(function(player)
				player.CharacterAdded:Connect(function()
					fireDamageEventForAllPlayers()  -- Fire the event when a new player joins
				end)
			end)
	
		end
	
	end
	
	
	script.Parent.MouseButton1Down:connect(Click)
end
coroutine.wrap(HJNA_fake_script)()
local function ALQWNJ_fake_script() -- stopspamsfxall.Script 
	local script = Instance.new('Script', stopspamsfxall)

	function Click(mouse)
	
		_G.toggle = false
	
	end
	
	
	script.Parent.MouseButton1Down:connect(Click)
end
coroutine.wrap(ALQWNJ_fake_script)()
local function QWMYN_fake_script() -- toggle.LocalScript 
	local script = Instance.new('LocalScript', toggle)

	local back = script.Parent.Parent.mainframe
	local con = script.Parent.Parent.mainframe
	
	local window = {
		count = 0;
		toggles = {},
		closed = false;
	}
	script.Parent.MouseButton1Click:connect(function()
		window.closed = not window.closed
		script.Parent.Text = (window.closed and "+" or "-")
		if script.Parent.Text == "+" then
			back:TweenSize(UDim2.new(0, 190,0, 0), "Out", "Sine", 0.5)
			con:TweenSize(UDim2.new(0, 190,0, 0), "Out", "Sine", 0.5)
			wait(0.1) do
				con.Visible = false
			end
		else
			back:TweenSize(UDim2.new(0, 255,0, 274), "Out", "Sine", 0.5)
			con:TweenSize(UDim2.new(0, 255,0, 274), "Out", "Sine", 0.5)
			wait(0.2) do
				con.Visible = true
			end
		end
	
	end)
end
coroutine.wrap(QWMYN_fake_script)()
local function QVOEQMK_fake_script() -- toggle.LocalScript 
	local script = Instance.new('LocalScript', toggle)

	local dragger = {}; 
	local resizer = {};
	
	do
		local mouse = game:GetService("Players").LocalPlayer:GetMouse();
		local inputService = game:GetService('UserInputService');
		local heartbeat = game:GetService("RunService").Heartbeat;
		-- // credits to Ririchi / Inori for this cute drag function :)
		function dragger.new(frame)
			local s, event = pcall(function()
				return frame.MouseEnter
			end)
	
			if s then
				frame.Active = true;
	
				event:connect(function()
					local input = frame.InputBegan:connect(function(key)
						if key.UserInputType == Enum.UserInputType.MouseButton1 then
							local objectPosition = Vector2.new(mouse.X - frame.AbsolutePosition.X, mouse.Y - frame.AbsolutePosition.Y);
							while heartbeat:wait() and inputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton1) do
								frame:TweenPosition(UDim2.new(0, mouse.X - objectPosition.X + (frame.Size.X.Offset * frame.AnchorPoint.X), 0, mouse.Y - objectPosition.Y + (frame.Size.Y.Offset * frame.AnchorPoint.Y)), 'Out', 'Quad', 0.1, true);
							end
						end
					end)
	
					local leave;
					leave = frame.MouseLeave:connect(function()
						input:disconnect();
						leave:disconnect();
					end)
				end)
			end
		end
	
		function resizer.new(p, s)
			p:GetPropertyChangedSignal('AbsoluteSize'):connect(function()
				s.Size = UDim2.new(s.Size.X.Scale, s.Size.X.Offset, s.Size.Y.Scale, p.AbsoluteSize.Y);
			end)
		end
	end
	script.Parent.Active = true
	script.Parent.Draggable = true
end
coroutine.wrap(QVOEQMK_fake_script)()
