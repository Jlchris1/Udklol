-- Control NPC LocalScript (heightened local player, mobile support, no NPC touching)
-- Place in StarterPlayer > StarterPlayerScripts

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local StarterGui = game:GetService("StarterGui")
local Workspace = game:GetService("Workspace")
local PhysicsService = game:GetService("PhysicsService")
local ContextActionService = game:GetService("ContextActionService")

local player = Players.LocalPlayer
local camera = Workspace.CurrentCamera

-- CONFIG
local HAIR_GAP = 0.12         -- distance (studs) between NPC bottom (feet) and the local player's top (head/hair). Lower = more likely to touch/clip.
local MIN_CLEARANCE = 1.6     -- used to avoid hugging thin parts (kept from original logic)
local WALK_THRESHOLD = 0.02
local MOVE_DISTANCE = 100
local FIXED_YAW_RAD = math.rad(90)

-- UI (responsive for mobile)
local gui = Instance.new("ScreenGui")
gui.Name = "ControlNPCGui"
gui.ResetOnSpawn = false
gui.Parent = player:WaitForChild("PlayerGui")
gui.IgnoreGuiInset = true

local isTouch = UserInputService.TouchEnabled

local frame = Instance.new("Frame", gui)
frame.BackgroundColor3 = Color3.fromRGB(30,30,30)
frame.BorderSizePixel = 0
frame.AnchorPoint = Vector2.new(0,0)

if isTouch then
    frame.Size = UDim2.new(0, 340, 0, 200)
    frame.Position = UDim2.new(0, 8, 0, 8)
else
    frame.Size = UDim2.new(0, 260, 0, 140)
    frame.Position = UDim2.new(0, 10, 0, 10)
end

local title = Instance.new("TextLabel", frame)
title.Size = UDim2.new(1, 0, 0, 28)
title.BackgroundTransparency = 1
title.Text = "NPC Control"
title.TextColor3 = Color3.fromRGB(255,255,255)
title.Font = Enum.Font.SourceSansBold
title.TextSize = (isTouch and 18 or 16)

local toggleBtn = Instance.new("TextButton", frame)
toggleBtn.Size = UDim2.new(1, -12, 0, (isTouch and 44 or 28))
toggleBtn.Position = UDim2.new(0, 6, 0, 34)
toggleBtn.Text = "Toggle Control: OFF"
toggleBtn.Font = Enum.Font.SourceSans
toggleBtn.TextSize = (isTouch and 18 or 14)

local walkToggle = Instance.new("TextButton", frame)
walkToggle.Size = UDim2.new(0.48, -6, 0, (isTouch and 36 or 22))
walkToggle.Position = UDim2.new(0, 6, 0, (isTouch and 84 or 66))
walkToggle.Text = "WalkTo: On"
walkToggle.Font = Enum.Font.SourceSans
walkToggle.TextSize = (isTouch and 16 or 13)

local killBtn = Instance.new("TextButton", frame)
killBtn.Size = UDim2.new(0.48, -6, 0, (isTouch and 36 or 22))
killBtn.Position = UDim2.new(0.52, 0, 0, (isTouch and 84 or 66))
killBtn.Text = "Kill NPC"
killBtn.Font = Enum.Font.SourceSans
killBtn.TextSize = (isTouch and 16 or 13)

local speedLabel = Instance.new("TextLabel", frame)
speedLabel.Size = UDim2.new(0.5, -6, 0, 22)
speedLabel.Position = UDim2.new(0, 6, 0, (isTouch and 130 or 88))
speedLabel.Text = "NPC Speed:"
speedLabel.Font = Enum.Font.SourceSans
speedLabel.TextSize = (isTouch and 15 or 13)
speedLabel.TextColor3 = Color3.new(1,1,1)
speedLabel.BackgroundTransparency = 1

local speedBox = Instance.new("TextBox", frame)
speedBox.Size = UDim2.new(0.5, -6, 0, 22)
speedBox.Position = UDim2.new(0.5, 0, 0, (isTouch and 130 or 88))
speedBox.Text = "16"
speedBox.Font = Enum.Font.SourceSans
speedBox.TextSize = (isTouch and 15 or 13)
speedBox.ClearTextOnFocus = false

local jumpLabel = Instance.new("TextLabel", frame)
jumpLabel.Size = UDim2.new(0.5, -6, 0, 22)
jumpLabel.Position = UDim2.new(0, 6, 0, (isTouch and 160 or 110))
jumpLabel.Text = "NPC JumpPower:"
jumpLabel.Font = Enum.Font.SourceSans
jumpLabel.TextSize = (isTouch and 15 or 13)
jumpLabel.TextColor3 = Color3.new(1,1,1)
jumpLabel.BackgroundTransparency = 1

local jumpBox = Instance.new("TextBox", frame)
jumpBox.Size = UDim2.new(0.5, -6, 0, 22)
jumpBox.Position = UDim2.new(0.5, 0, 0, (isTouch and 160 or 110))
jumpBox.Text = "50"
jumpBox.Font = Enum.Font.SourceSans
jumpBox.TextSize = (isTouch and 15 or 13)
jumpBox.ClearTextOnFocus = false

-- State
local active = false
local controlledNPC = nil
local npcHumanoid = nil
local npcRoot = nil
local heartbeatConn = nil
local jumpConn = nil
local charAddedConn = nil
local playerDiedConn = nil
local npcDiedConn = nil

local walkEnabled = true
local npcOriginalWalkSpeed = nil

-- Track changed parts for cleanup
local changedNPCParts = {}
local changedPlayerParts = {}

-- Store HRP anchored state and original anchoring so we can restore
local anchoredHRP = nil
local originalHRPAnchored = nil

-- Helpers
local function modelHeight(model)
    if not model then return 5 end
    local ok, size = pcall(function() return model:GetExtentsSize() end)
    if ok and size then return size.Y end
    return 5
end

local function findNearestNPC()
    local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
    if not hrp then return nil end
    local myPos = hrp.Position
    local nearest, nd = nil, math.huge
    for _,m in ipairs(workspace:GetDescendants()) do
        if m:IsA("Model") then
            local hum = m:FindFirstChildOfClass("Humanoid")
            local root = m:FindFirstChild("HumanoidRootPart") or m.PrimaryPart
            if hum and root and hum.Health > 0 and Players:GetPlayerFromCharacter(m) == nil then
                local d = (root.Position - myPos).Magnitude
                if d < nd then nd = d nearest = m end
            end
        end
    end
    return nearest
end

local function safeSetPartPropsAsNoCollision(part)
    if not part then return end
    pcall(function()
        table.insert(changedNPCParts, part)
        part.CanCollide = false
        if pcall(function() return part.CanTouch end) then
            pcall(function() part.CanTouch = false end)
        end
        pcall(function() part.Massless = true end)
    end)
end

local function neutralizeNPC(model)
    if not model then return end
    for _,desc in ipairs(model:GetDescendants()) do
        if desc:IsA("Script") or desc:IsA("LocalScript") or desc:IsA("ModuleScript") then
            pcall(function() desc:Destroy() end)
        end
        if desc:IsA("BasePart") then
            safeSetPartPropsAsNoCollision(desc)
            pcall(function()
                if pcall(function() PhysicsService:GetCollisionGroups() end) then
                    pcall(function() PhysicsService:CreateCollisionGroup("ControlNPC_NoPlayer") end)
                    pcall(function() PhysicsService:CreateCollisionGroup("ControlNPC_PlayersGroup") end)
                    pcall(function() PhysicsService:CollisionGroupSetCollidable("ControlNPC_NoPlayer", "ControlNPC_PlayersGroup", false) end)
                    pcall(function() PhysicsService:SetPartCollisionGroup(desc, "ControlNPC_NoPlayer") end)
                end
            end)
        end
    end
end

local function assignCollisionGroupToModel(model, groupName)
    if not model then return end
    for _,desc in ipairs(model:GetDescendants()) do
        if desc:IsA("BasePart") then
            pcall(function()
                PhysicsService:SetPartCollisionGroup(desc, groupName)
            end)
        end
    end
end

local function assignPlayerPartsToPlayersGroup()
    local char = player.Character
    if not char then return end
    for _,desc in ipairs(char:GetDescendants()) do
        if desc:IsA("BasePart") then
            pcall(function()
                table.insert(changedPlayerParts, desc)
                if pcall(function() PhysicsService:GetCollisionGroups() end) then
                    pcall(function() PhysicsService:SetPartCollisionGroup(desc, "ControlNPC_PlayersGroup") end)
                end
            end)
        end
    end
end

local function revertCollisionGroups()
    for _,part in ipairs(changedNPCParts) do
        pcall(function()
            if part and part.Parent then
                part.CanCollide = false
                if pcall(function() return part.CanTouch end) then
                    pcall(function() part.CanTouch = true end)
                end
                pcall(function() PhysicsService:SetPartCollisionGroup(part, "Default") end)
            end
        end)
    end
    changedNPCParts = {}

    for _,part in ipairs(changedPlayerParts) do
        pcall(function()
            if part and part.Parent then
                pcall(function() PhysicsService:SetPartCollisionGroup(part, "Default") end)
            end
        end)
    end
    changedPlayerParts = {}
end

local function restoreCamera()
    camera.CameraType = Enum.CameraType.Custom
    pcall(function()
        if player.Character then
            local hum = player.Character:FindFirstChildWhichIsA("Humanoid")
            if hum then camera.CameraSubject = hum end
        end
    end)
end

-- ground detection ignoring player and NPC
local function getGroundYAtPosition(xzPosition)
    local origin = Vector3.new(xzPosition.X, 5000, xzPosition.Z)
    local direction = Vector3.new(0, -10000, 0)
    local rayParams = RaycastParams.new()
    rayParams.FilterType = Enum.RaycastFilterType.Blacklist
    local blacklist = {}
    if controlledNPC then table.insert(blacklist, controlledNPC) end
    if player and player.Character then table.insert(blacklist, player.Character) end
    rayParams.FilterDescendantsInstances = blacklist
    local result = Workspace:Raycast(origin, direction, rayParams)
    if result and result.Position and result.Instance then
        return result.Position.Y, result.Instance
    else
        return nil, nil
    end
end

-- track ground info
local lastNPCGroundPart = nil
local lastPlayerGroundPart = nil
local lastPlayerGroundY = nil

-- Prevent local player from jumping / peeking and compute desired finalY so hair touches feet
local function immediateClampUnderNPC()
    local myChar = player.Character
    local myHum = myChar and myChar:FindFirstChildWhichIsA("Humanoid")
    local myHRP = myChar and myChar:FindFirstChild("HumanoidRootPart")
    if not (myChar and myHum and myHRP and controlledNPC and npcRoot) then return end

    local extY = modelHeight(controlledNPC)
    local bottomY = npcRoot.Position.Y - (extY / 2) -- NPC bottom (approx feet)
    local playerH = modelHeight(myChar)
    local desiredHRPY = bottomY - HAIR_GAP - (playerH * 0.5) -- position HRP so top of player's model is ~HAIR_GAP below feet

    -- ground under player (update last known)
    local groundY, groundPart = getGroundYAtPosition(Vector3.new(myHRP.Position.X, 0, myHRP.Position.Z))
    if groundPart ~= nil then
        lastPlayerGroundPart = groundPart
        lastPlayerGroundY = groundY
    end

    -- nominal target is desiredHRPY; keep existing clearance logic (fallbacks)
    local finalY = desiredHRPY
    if lastPlayerGroundY then
        finalY = math.min(finalY, lastPlayerGroundY - MIN_CLEARANCE)
    elseif groundY then
        finalY = math.min(finalY, groundY - MIN_CLEARANCE)
        lastPlayerGroundPart = groundPart
        lastPlayerGroundY = groundY
    else
        finalY = bottomY - 8
    end

    pcall(function()
        myHRP.Velocity = Vector3.new(0,0,0)
        myHRP.RotVelocity = Vector3.new(0,0,0)
        myHRP.AssemblyLinearVelocity = Vector3.new(0,0,0)
        myHRP.CFrame = CFrame.new(Vector3.new(npcRoot.Position.X, finalY, npcRoot.Position.Z)) * CFrame.Angles(0, FIXED_YAW_RAD, 0)
    end)

    -- clamp other parts under finalY
    for _,desc in ipairs(myChar:GetDescendants()) do
        if desc:IsA("BasePart") and desc.Name ~= "HumanoidRootPart" then
            local topY = desc.Position.Y + (desc.Size.Y * 0.5)
            if topY > finalY then
                local delta = topY - finalY
                pcall(function()
                    desc.CFrame = desc.CFrame - Vector3.new(0, delta, 0)
                    desc.Velocity = Vector3.new(0,0,0)
                    desc.RotVelocity = Vector3.new(0,0,0)
                end)
            end
        end
    end

    -- cancel local jump
    pcall(function()
        myHum.Jump = false
        myHum.JumpPower = 0
    end)
end

-- Jump handler: trigger NPC jump and immediately clamp local player (prevents peek)
local function onJumpRequest()
    if active and npcHumanoid then
        pcall(function() npcHumanoid.Jump = true end)
        immediateClampUnderNPC()
    end
end

-- Clamp other parts below clampY (skip HRP)
local function clampCharacterPartsBelow(character, clampY)
    if not character then return end
    for _,desc in ipairs(character:GetDescendants()) do
        if desc:IsA("BasePart") and desc.Name ~= "HumanoidRootPart" then
            local topY = desc.Position.Y + (desc.Size.Y * 0.5)
            if topY > clampY then
                local delta = topY - clampY
                pcall(function()
                    desc.CFrame = desc.CFrame - Vector3.new(0, delta, 0)
                    desc.Velocity = Vector3.new(0,0,0)
                    desc.RotVelocity = Vector3.new(0,0,0)
                end)
            end
        end
    end
end

-- Heartbeat: follow under NPC while obeying plank mode and heightening
local function heartbeat(dt)
    if not active then return end
    if not controlledNPC or not controlledNPC.Parent then cleanup(); return end
    if not npcHumanoid or npcHumanoid.Health <= 0 then cleanup(); return end

    local myChar = player.Character
    if not myChar or not myChar.Parent then
        if npcHumanoid and npcHumanoid.Health > 0 then pcall(function() npcHumanoid.Health = 0 end) end
        cleanup()
        return
    end

    local myHum = myChar:FindFirstChildWhichIsA("Humanoid")
    local myHRP = myChar:FindFirstChild("HumanoidRootPart")
    if not myHum or not myHRP then return end

    -- camera follows NPC while controlling
    if npcHumanoid then
        camera.CameraType = Enum.CameraType.Custom
        pcall(function() camera.CameraSubject = npcHumanoid end)
    end

    if npcRoot and npcRoot.Parent then
        local extY = modelHeight(controlledNPC)
        local bottomY = npcRoot.Position.Y - (extY / 2)

        -- update ground under player
        local groundY, groundPart = getGroundYAtPosition(Vector3.new(myHRP.Position.X, 0, myHRP.Position.Z))
        if groundPart ~= nil then
            lastPlayerGroundPart = groundPart
            lastPlayerGroundY = groundY
        end

        -- compute desired HRP Y so player's head/hair gets close under feet
        local playerH = modelHeight(myChar)
        local desiredHRPY = bottomY - HAIR_GAP - (playerH * 0.5)
        local nominalTargetY = desiredHRPY

        -- ground under NPC
        local npcGroundY, npcGroundPart = getGroundYAtPosition(Vector3.new(npcRoot.Position.X, 0, npcRoot.Position.Z))
        local prevNPCGroundPart = lastNPCGroundPart
        if npcGroundPart ~= lastNPCGroundPart then
            lastNPCGroundPart = npcGroundPart
        end

        -- choose finalY, keep MIN_CLEARANCE behavior as fallback
        local finalY = nominalTargetY
        if lastPlayerGroundY then
            finalY = math.min(finalY, lastPlayerGroundY - MIN_CLEARANCE)
        elseif groundY then
            finalY = math.min(finalY, groundY - MIN_CLEARANCE)
            lastPlayerGroundPart = groundPart
            lastPlayerGroundY = groundY
        else
            finalY = bottomY - 8
        end

        -- detect NPC leaving platform case
        if npcGroundPart == nil and prevNPCGroundPart ~= nil then
            finalY = bottomY - 8
            lastPlayerGroundPart = nil
            lastPlayerGroundY = nil
        end

        local targetPos = Vector3.new(npcRoot.Position.X, finalY, npcRoot.Position.Z)
        local currentPos = myHRP.Position
        local useInstant = (math.abs(currentPos.Y - targetPos.Y) > 2) and (targetPos.Y <= bottomY - 7.5)

        pcall(function()
            myHRP.Velocity = Vector3.new(0,0,0)
            myHRP.RotVelocity = Vector3.new(0,0,0)
            myHRP.AssemblyLinearVelocity = Vector3.new(0,0,0)
            if useInstant then
                myHRP.CFrame = CFrame.new(targetPos) * CFrame.Angles(0, FIXED_YAW_RAD, 0)
            else
                local smoothed = currentPos:Lerp(targetPos, math.clamp(8 * dt, 0, 1))
                myHRP.CFrame = CFrame.new(smoothed) * CFrame.Angles(0, FIXED_YAW_RAD, 0)
            end
        end)

        -- clamp other parts
        clampCharacterPartsBelow(myChar, finalY)

        -- plank mode on
        pcall(function() myHum.PlatformStand = true end)

        -- ensure HRP anchored (prevent falling due to physics) - reapply to be safe
        if anchoredHRP and anchoredHRP.Parent then
            pcall(function() anchoredHRP.Anchored = true end)
            pcall(function() anchoredHRP.Velocity = Vector3.new(0,0,0); anchoredHRP.AssemblyLinearVelocity = Vector3.new(0,0,0) end)
        end
    end

    -- WalkTo & speed logic
    if npcHumanoid and npcRoot and npcHumanoid.Health > 0 then
        local myHum = player.Character and player.Character:FindFirstChildWhichIsA("Humanoid")
        local md = myHum and myHum.MoveDirection or Vector3.new(0,0,0)
        local desiredSpeed = tonumber(speedBox.Text) or 16

        if md and md.Magnitude > WALK_THRESHOLD and walkEnabled then
            pcall(function() npcHumanoid.WalkSpeed = desiredSpeed end)

            local dirFlat = Vector3.new(md.X, 0, md.Z)
            if dirFlat.Magnitude < 1e-4 then
                dirFlat = Vector3.new(npcRoot.CFrame.LookVector.X, 0, npcRoot.CFrame.LookVector.Z)
            end
            dirFlat = dirFlat.Unit
            local destination = npcRoot.Position + dirFlat * MOVE_DISTANCE
            pcall(function() npcHumanoid:MoveTo(destination) end)
        else
            pcall(function()
                npcHumanoid:MoveTo(npcRoot.Position)
                npcHumanoid.WalkSpeed = 0
            end)
        end
    end

    -- NPC JumpPower
    if npcHumanoid then
        local jp = tonumber(jumpBox.Text)
        if jp and jp > 0 then pcall(function() npcHumanoid.JumpPower = jp end) end
    end
end

-- teleport local player above a world position
local function teleportPlayerAbove(pos, height)
    height = height or 10
    local myChar = player.Character
    if not myChar then return end
    local myHRP = myChar:FindFirstChild("HumanoidRootPart")
    if not myHRP then return end
    pcall(function()
        myHRP.CFrame = CFrame.new(pos + Vector3.new(0, height, 0)) * CFrame.Angles(0, FIXED_YAW_RAD, 0)
        pcall(function() myHRP.Velocity = Vector3.new(0,0,0); myHRP.AssemblyLinearVelocity = Vector3.new(0,0,0) end)
    end)
end

-- Enable control
local function enableControl()
    if active then return end
    local char = player.Character
    if not char then StarterGui:SetCore("ChatMakeSystemMessage", {Text = "No character found."}); return end

    local npc = findNearestNPC()
    if not npc then StarterGui:SetCore("ChatMakeSystemMessage", {Text = "No NPC found nearby."}); return end

    local hum = npc:FindFirstChildOfClass("Humanoid")
    local hrp = npc:FindFirstChild("HumanoidRootPart") or npc.PrimaryPart
    if not hum or not hrp then StarterGui:SetCore("ChatMakeSystemMessage", {Text = "Nearest NPC missing Humanoid/RootPart."}); return end

    controlledNPC = npc
    npcHumanoid = hum
    npcRoot = hrp
    active = true
    toggleBtn.Text = "Toggle Control: ON"
    walkEnabled = true
    walkToggle.Text = "WalkTo: On"

    npcOriginalWalkSpeed = nil
    pcall(function() npcOriginalWalkSpeed = npcHumanoid.WalkSpeed end)

    neutralizeNPC(controlledNPC)

    -- collision groups fallback/assignment
    pcall(function()
        if pcall(function() PhysicsService:GetCollisionGroups() end) then
            pcall(function() PhysicsService:CreateCollisionGroup("ControlNPC_NoPlayer") end)
            pcall(function() PhysicsService:CreateCollisionGroup("ControlNPC_PlayersGroup") end)
            pcall(function() PhysicsService:CollisionGroupSetCollidable("ControlNPC_NoPlayer", "ControlNPC_PlayersGroup", false) end)
            assignCollisionGroupToModel(controlledNPC, "ControlNPC_NoPlayer")
            assignPlayerPartsToPlayersGroup()
        end
    end)

    camera.CameraType = Enum.CameraType.Custom
    pcall(function() camera.CameraSubject = npcHumanoid end)

    if not heartbeatConn then heartbeatConn = RunService.Heartbeat:Connect(heartbeat) end
    if not jumpConn then jumpConn = UserInputService.JumpRequest:Connect(onJumpRequest) end

    -- store and zero local player's JumpPower to avoid peek
    local myChar = player.Character
    if myChar then
        local myHum = myChar:FindFirstChildWhichIsA("Humanoid")
        if myHum then
            pcall(function()
                myOriginalJumpPower = myHum.JumpPower
                myHum.JumpPower = 0
            end)
        end
        -- anchor HRP to prevent falling and store original anchored state
        local myHRP = myChar:FindFirstChild("HumanoidRootPart")
        if myHRP then
            anchoredHRP = myHRP
            pcall(function() originalHRPAnchored = myHRP.Anchored end)
            pcall(function() myHRP.Anchored = true end)
            pcall(function() myHRP.Velocity = Vector3.new(0,0,0); myHRP.AssemblyLinearVelocity = Vector3.new(0,0,0) end)
        end
    end

    -- Mobile: optionally bind a large action button to toggle control quickly (example)
    if isTouch then
        -- bind a simple touch action to toggle control by holding 'TWO_FINGER_TAP' as an example keybind
        -- If you want a custom on-screen button for this, we already have large GUI buttons above.
        local function dummyAction(actionName, inputState, inputObject)
            if inputState == Enum.UserInputState.End then
                -- nothing for now; leaving placeholder so ContextAction is available for mobile tweaks
            end
            return Enum.ContextActionResult.Sink
        end
        pcall(function() ContextActionService:BindAction("ControlNPC_Touch", dummyAction, false, Enum.KeyCode.ButtonR3) end)
    end

    -- attach player death
    local function attachPlayerSignals()
        local myChar = player.Character
        if not myChar then return end
        local myHum = myChar:FindFirstChildWhichIsA("Humanoid")
        if myHum then
            if playerDiedConn then playerDiedConn:Disconnect(); playerDiedConn = nil end
            playerDiedConn = myHum.Died:Connect(function()
                if npcHumanoid and npcHumanoid.Health > 0 then pcall(function() npcHumanoid.Health = 0 end) end
                cleanup()
            end)
        end
    end
    attachPlayerSignals()
    if not charAddedConn then
        charAddedConn = player.CharacterAdded:Connect(function()
            task.wait(0.1)
            attachPlayerSignals()
        end)
    end

    -- npc death handler: teleport player above death location then cleanup
    if npcHumanoid then
        if npcDiedConn then npcDiedConn:Disconnect(); npcDiedConn = nil end
        npcDiedConn = npcHumanoid.Died:Connect(function()
            local deathPos
            pcall(function() deathPos = npcRoot and npcRoot.Position or controlledNPC.PrimaryPart and controlledNPC.PrimaryPart.Position end)
            if deathPos then teleportPlayerAbove(deathPos, 10) end
            cleanup()
        end)
    end
end

-- Disable control: teleport player above npc last location then cleanup
local function disableControl()
    if controlledNPC and npcRoot then
        local pos
        pcall(function() pos = npcRoot.Position end)
        if not pos and controlledNPC and controlledNPC.PrimaryPart then pcall(function() pos = controlledNPC.PrimaryPart.Position end) end
        if pos then teleportPlayerAbove(pos, 10) end
    end
    cleanup()
end

-- cleanup and restore
local myOriginalJumpPower = nil
function cleanup()
    active = false
    walkEnabled = false

    if npcHumanoid and npcOriginalWalkSpeed then
        pcall(function() npcHumanoid.WalkSpeed = npcOriginalWalkSpeed end)
    end

    if heartbeatConn then heartbeatConn:Disconnect() heartbeatConn = nil end
    if jumpConn then jumpConn:Disconnect() jumpConn = nil end
    if charAddedConn then charAddedConn:Disconnect() charAddedConn = nil end
    if playerDiedConn then playerDiedConn:Disconnect() playerDiedConn = nil end
    if npcDiedConn then npcDiedConn:Disconnect() npcDiedConn = nil end

    local myChar = player.Character
    if myChar then
        local myHum = myChar:FindFirstChildWhichIsA("Humanoid")
        if myHum then
            pcall(function()
                myHum.PlatformStand = false
                if myOriginalJumpPower then myHum.JumpPower = myOriginalJumpPower end
            end)
        end
        -- restore HRP anchored state if we changed it
        if anchoredHRP and anchoredHRP.Parent then
            pcall(function() anchoredHRP.Anchored = originalHRPAnchored end)
        end
        anchoredHRP = nil
        originalHRPAnchored = nil
    end

    restoreCamera()

    -- revert any collision group changes
    pcall(function() revertCollisionGroups() end)

    controlledNPC = nil
    npcHumanoid = nil
    npcRoot = nil
    npcOriginalWalkSpeed = nil

    toggleBtn.Text = "Toggle Control: OFF"
    walkToggle.Text = "WalkTo: Off"
end

local function killControlledNPC()
    if npcHumanoid then pcall(function() npcHumanoid.Health = 0 end) end
end

-- GUI bindings
toggleBtn.MouseButton1Click:Connect(function()
    if active then disableControl() else enableControl() end
end)

walkToggle.MouseButton1Click:Connect(function()
    walkEnabled = not walkEnabled
    walkToggle.Text = "WalkTo: " .. (walkEnabled and "On" or "Off")
    if not walkEnabled and npcHumanoid and npcRoot then
        pcall(function()
            npcHumanoid:MoveTo(npcRoot.Position)
            npcHumanoid.WalkSpeed = 0
        end)
    end
end)

killBtn.MouseButton1Click:Connect(function() killControlledNPC() end)

-- Cleanup on script removal
script.AncestryChanged:Connect(function(_, parent)
    if not parent then cleanup() end
end)

StarterGui:SetCore("ChatMakeSystemMessage", {Text = "[ControlNPC] Ready. Toggle control near an NPC."})
