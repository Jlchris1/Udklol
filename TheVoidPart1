-- True Void — Part One (forcefield non-lethal fling + fear 70/30)
-- Place this LocalScript into StarterPlayer -> StarterPlayerScripts

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")

local player = Players.LocalPlayer
if not player then return end

-- ====== CONFIG ======
local EXTREME_POS = Vector3.new(9e37, 9e37, 9e37)
local PRESENCE_RADIUS = 20
local FORCEFIELD_RADIUS = 35 -- radius in studs
local FORCEFIELD_CHECK_INTERVAL = 0.18
local PRESENCE_CHECK_INTERVAL = 0.5
local TIME_DELATION_INTERVAL = 1

local FORCEFIELD_BASE_VEL = 60 -- base velocity applied
local FORCEFIELD_UPWARD_BONUS = 8 -- slight upward component
local FORCEFIELD_COOLDOWN = 0.6 -- seconds before same NPC can be processed again

local BG_COLOR = Color3.fromRGB(0,0,0)
local TEXT_COLOR = Color3.fromRGB(120, 50, 130) -- dark purple

-- Attempt to set FallenPartsDestroyHeight to NaN (graceful)
pcall(function() Workspace.FallenPartsDestroyHeight = 0/0 end)

-- ====== UTILITIES ======
local function isNPC(model)
    if not model or not model:IsA("Model") then return false end
    local hum = model:FindFirstChildOfClass("Humanoid")
    if not hum then return false end
    return not Players:GetPlayerFromCharacter(model)
end

local function findHumanoidFromDescendant(desc)
    local node = desc
    for i=1,10 do
        if not node then break end
        local h = node:FindFirstChildOfClass("Humanoid")
        if h then return h, node end
        node = node.Parent
    end
    return nil, nil
end

local function getModelRoot(model)
    if not model then return nil end
    return model:FindFirstChild("HumanoidRootPart") or model:FindFirstChild("UpperTorso") or model:FindFirstChild("Torso")
end

local function getAllNPCHumanoids()
    local out = {}
    for _,h in ipairs(Workspace:GetDescendants()) do
        if h:IsA("Humanoid") then
            local model = h.Parent
            if model and isNPC(model) then
                table.insert(out, {hum = h, model = model, hrp = getModelRoot(model)})
            end
        end
    end
    return out
end

local function teleportModelToExtreme(model)
    if not model then return end
    for _,part in ipairs(model:GetDescendants()) do
        if part:IsA("BasePart") then
            pcall(function() part.CFrame = CFrame.new(EXTREME_POS) end)
        end
    end
end

local function anchorModelParts(model)
    if not model then return end
    for _,part in ipairs(model:GetDescendants()) do
        if part:IsA("BasePart") then
            pcall(function()
                part.Anchored = true
                part.CanCollide = false
            end)
        end
    end
end

local function waitUntilAtExtreme(part, timeout)
    timeout = timeout or 5
    local t = 0
    while t < timeout do
        if not part or not part.Parent then return false end
        local ok, pos = pcall(function() return part.Position end)
        if ok and pos and pos.Magnitude > 1e30 then
            return true
        end
        t = t + RunService.Heartbeat:Wait()
    end
    return false
end

local function getModelHorizontalExtent(model)
    if not model then return 1 end
    local ok, size = pcall(function() return model:GetExtentsSize() end)
    if ok and typeof(size) == "Vector3" then
        return math.max(0.1, math.max(size.X, size.Z))
    end
    -- fallback bounding box over parts
    local minP, maxP
    for _,p in ipairs(model:GetDescendants()) do
        if p:IsA("BasePart") then
            local half = p.Size * 0.5
            local pMin = p.Position - half
            local pMax = p.Position + half
            if not minP then minP = pMin; maxP = pMax
            else
                minP = Vector3.new(math.min(minP.X, pMin.X), math.min(minP.Y, pMin.Y), math.min(minP.Z, pMin.Z))
                maxP = Vector3.new(math.max(maxP.X, pMax.X), math.max(maxP.Y, pMax.Y), math.max(maxP.Z, pMax.Z))
            end
        end
    end
    if minP and maxP then
        local ext = maxP - minP
        return math.max(0.1, math.max(ext.X, ext.Z))
    end
    return 1
end

local function getPlayerCenterPosition()
    local char = player.Character
    local root = char and (char:FindFirstChild("HumanoidRootPart") or char:FindFirstChild("UpperTorso") or char:FindFirstChild("Torso"))
    if root and root.Parent then return root.Position end
    if Workspace.CurrentCamera then return Workspace.CurrentCamera.CFrame.Position end
    return Vector3.new(0,0,0)
end

-- ====== DIALOGUE TYPING (fixed) ======
--// Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local localPlayer = Players.LocalPlayer

-- --------------------------------------------------------------------
-- Dialogue typing (MOBILE SAFE)
-- --------------------------------------------------------------------
local function typeDialog(lines, perCharDelay)
    perCharDelay = perCharDelay or 0.03

    -- Remove old GUI if it exists (prevents respawn duplicates)
    local playerGui = localPlayer:WaitForChild("PlayerGui")
    local old = playerGui:FindFirstChild("VoidDialogGUI")
    if old then old:Destroy() end

    -- Create GUI
    local sg = Instance.new("ScreenGui")
    sg.Name = "VoidDialogGUI"
    sg.IgnoreGuiInset = true
    sg.ResetOnSpawn = false
    sg.Parent = playerGui

    -- Detect screen size for mobile scaling
    local screenSize = workspace.CurrentCamera.ViewportSize
    local isMobile = screenSize.X < 900

    -- Frame
    local frame = Instance.new("Frame")
    frame.AnchorPoint = Vector2.new(0.5, 1)
    frame.Position = UDim2.new(0.5, 0, 0.92, 0)
    frame.Size = isMobile
        and UDim2.new(0.9, 0, 0.18, 0)
        or UDim2.new(0.6, 0, 0.15, 0)
    frame.BackgroundTransparency = 1
    frame.Parent = sg

    -- Text label
    local label = Instance.new("TextLabel")
    label.Size = UDim2.new(1, 0, 1, 0)
    label.BackgroundTransparency = 1
    label.TextWrapped = true
    label.TextScaled = false
    label.RichText = false
    label.Font = Enum.Font.SourceSansBold
    label.TextColor3 = Color3.fromRGB(200,200,220)
    label.TextXAlignment = Enum.TextXAlignment.Center
    label.TextYAlignment = Enum.TextYAlignment.Center
    label.Text = ""
    label.Parent = frame

    -- Mobile-friendly text size
    label.TextSize = isMobile and 20 or 28

    -- Typewriter function using Heartbeat (more reliable than wait)
    local function typeLine(text)
        label.Text = ""

        local output = ""
        for _, char in utf8.codes(text) do
            output ..= utf8.char(char)
            label.Text = output
            RunService.Heartbeat:Wait() -- smoother than wait()
            task.wait(perCharDelay)
        end
    end

    -- Play lines sequentially
    for i, line in ipairs(lines) do
        typeLine(line)

        if i < #lines then
            task.wait(1) -- pause before next line
        end
    end

    -- Auto remove
    task.delay(8, function()
        if sg then sg:Destroy() end
    end)
end

-- --------------------------------------------------------------------
-- START DIALOGUE
-- --------------------------------------------------------------------
--// Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local localPlayer = Players.LocalPlayer

-- --------------------------------------------------------------------
-- Dialogue typing (MOBILE SAFE)
-- --------------------------------------------------------------------
local function typeDialog(lines, perCharDelay)
    perCharDelay = perCharDelay or 0.03

    -- Remove old GUI if it exists (prevents respawn duplicates)
    local playerGui = localPlayer:WaitForChild("PlayerGui")
    local old = playerGui:FindFirstChild("VoidDialogGUI")
    if old then old:Destroy() end

    -- Create GUI
    local sg = Instance.new("ScreenGui")
    sg.Name = "VoidDialogGUI"
    sg.IgnoreGuiInset = true
    sg.ResetOnSpawn = false
    sg.Parent = playerGui

    -- Detect screen size for mobile scaling
    local screenSize = workspace.CurrentCamera.ViewportSize
    local isMobile = screenSize.X < 900

    -- Frame
    local frame = Instance.new("Frame")
    frame.AnchorPoint = Vector2.new(0.5, 1)
    frame.Position = UDim2.new(0.5, 0, 0.92, 0)
    frame.Size = isMobile
        and UDim2.new(0.9, 0, 0.18, 0)
        or UDim2.new(0.6, 0, 0.15, 0)
    frame.BackgroundTransparency = 1
    frame.Parent = sg

    -- Text label
    local label = Instance.new("TextLabel")
    label.Size = UDim2.new(1, 0, 1, 0)
    label.BackgroundTransparency = 1
    label.TextWrapped = true
    label.TextScaled = false
    label.RichText = false
    label.Font = Enum.Font.SourceSansBold
    label.TextColor3 = Color3.fromRGB(200,200,220)
    label.TextXAlignment = Enum.TextXAlignment.Center
    label.TextYAlignment = Enum.TextYAlignment.Center
    label.Text = ""
    label.Parent = frame

    -- Mobile-friendly text size
    label.TextSize = isMobile and 20 or 28

    -- Typewriter function using Heartbeat (more reliable than wait)
    local function typeLine(text)
        label.Text = ""

        local output = ""
        for _, char in utf8.codes(text) do
            output ..= utf8.char(char)
            label.Text = output
            RunService.Heartbeat:Wait() -- smoother than wait()
            task.wait(perCharDelay)
        end
    end

    -- Play lines sequentially
    for i, line in ipairs(lines) do
        typeLine(line)

        if i < #lines then
            task.wait(1) -- pause before next line
        end
    end

    -- Auto remove
    task.delay(8, function()
        if sg then sg:Destroy() end
    end)
end

-- --------------------------------------------------------------------
-- START DIALOGUE
-- --------------------------------------------------------------------
local D1 = "Ï̷̺̓s̸̞̮͗̒ ̸̺̗͐̽í̶̡̒t̴̙́ ̸͙̆̕r̵͙̈͛͜e̵͖͕̓a̸̦͋͝l̶̢͓̋l̶̗͗y̴̛̯̼ ̷͎͕͒w̴̩͙̎̈o̵͕̎̈ṛ̵̨̈́̌t̸͚͉͂́h̴̛̫ ̶̺̞̿͝f̶̨̙͛î̸̭g̴̜̗̎h̶̞̜̓t̴̩̂ị̶̘́̉ṉ̶̾͠g̸̣͝?̶̺̽̀"
local D2 = "O̵̺͌r̸̻̈́ ̴̮̈́á̷̹r̷̺͒̆e̸̞͓̓̈ ̸̙͈̋̄ÿ̷̪o̵̧͈͗u̸̹͑ ̸̮͍̇r̸͚͊e̸̢̪͊a̶̻̓ḻ̴̽͑l̸̥̠̕y̶̦͉͒͗ ̴̛̳̲̄t̷̖̉̓h̷̠́a̶̩͕͝͝t̶̢̝̎ ̶̧̲̇d̷̖̱̉e̴̮̓̀s̷͕͑p̵̝̲͝è̸̻͕̿r̷̭͛a̶̳͍͋̕t̵̤̓ḙ̶͂̋ ̴͚̜̇͝t̵͎̑õ̵̖ ̵̲͒ͅl̴͎̓̚i̷̪̿v̷̡͓͝ȩ̴͝ ̴̗͖̇ä̴̭̱́̚ ̸̖̈́l̴̙̈͜ï̵͚̟f̸͓͑́e̵̲̙̒ ̵͕͋t̴̞̗̀h̵͓̥̓̈́a̴̼͂̌t̵͙͇̆́ ̴̝͚́̐w̸̱̔ạ̷̟̓̍s̵̪̋̀ ̴͕̃̌d̸̼̔̌e̶̲̔͝s̸̼̹̈́ţ̵͔̚í̷̘̖ǹ̶͍͠e̶̤͋̀ḋ̴̢̝ ̶͙̽t̷͔̏͝o̴̧͎̾ ̴͍̔d̵̺͕̔ȋ̵̘̘̿e̵͔͚̊̍ ̶̜̒ì̴̫͌n̷̻̦̒̓ ̴̞̩̃̚t̶͎̟̔̆ḧ̴̥́͌ͅe̵̛͔ ̵̻͑͘é̶̗ǹ̷̡͍d̸̨͆̇ ̷̗́ặ̶̡ņ̴̓́ÿ̶͎̞́̓w̶͔͛a̴̠̣͆͗ý̵͎͝s̸̘̰̎."

task.spawn(function()
    typeDialog({D1, D2}, 0.02)
end)

-- ====== ERASE TOOL (fixed wiring + persistence) ======
local function giveTool(name)
    local bp = player:FindFirstChildOfClass("Backpack")
    if not bp then return end
    local existing = bp:FindFirstChild(name) or (player.Character and player.Character:FindFirstChild(name))
    if existing and existing:IsA("Tool") then return existing end
    local tool = Instance.new("Tool")
    tool.Name = name
    tool.RequiresHandle = false
    tool.CanBeDropped = false
    tool.Parent = bp
    return tool
end

-- persistent toggle state that survives equip/respawn
local trueErasureState = false

local function createEraseGUI()
    if not player then return nil, nil end
    local playerGui = player:FindFirstChildOfClass("PlayerGui") or player:WaitForChild("PlayerGui")

    local sg = playerGui:FindFirstChild("TrueVoid_Erase_GUI")
    if not sg then
        sg = Instance.new("ScreenGui")
        sg.Name = "TrueVoid_Erase_GUI"
        sg.ResetOnSpawn = false
        sg.Parent = playerGui

        local frame = Instance.new("Frame", sg)
        frame.Name = "Root"
        frame.Size = UDim2.new(0,200,0,40)
        frame.Position = UDim2.new(1, -220, 0, 10)
        frame.BackgroundTransparency = 0.15
        frame.BackgroundColor3 = BG_COLOR
        frame.BorderSizePixel = 0

        local toggle = Instance.new("TextButton", frame)
        toggle.Name = "TrueToggle"
        toggle.Size = UDim2.new(0,180,0,28)
        toggle.Position = UDim2.new(0,10,0,6)
        toggle.Text = (trueErasureState and "True Erasure: On" or "True Erasure: Off")
        toggle.TextColor3 = TEXT_COLOR
        toggle.BackgroundColor3 = Color3.fromRGB(18,18,18)
        toggle.Font = Enum.Font.SourceSansBold
        toggle.TextSize = 16
        toggle.BorderSizePixel = 0
    else
        if sg.Parent ~= playerGui then sg.Parent = playerGui end
        local toggle = sg:FindFirstChild("TrueToggle", true) or sg:FindFirstChild("TrueToggle")
        if toggle and toggle:IsA("TextButton") then
            toggle.Text = (trueErasureState and "True Erasure: On" or "True Erasure: Off")
        end
    end

    local toggle = sg:FindFirstChild("TrueToggle", true) or sg:FindFirstChild("TrueToggle")
    return sg, toggle
end

local function createHandleOnTool(tool)
    if not tool or not tool:IsA("Tool") then return end
    if tool:FindFirstChild("Handle") then pcall(function() tool.Handle:Destroy() end) end
    local h = Instance.new("Part")
    h.Name = "Handle"
    h.Size = Vector3.new(1,1,1)
    h.Transparency = 0.5
    h.CanCollide = false
    h.Parent = tool
    return h
end

local function wireEraseTool(tool)
    if not tool or not tool:IsA("Tool") then return end
    if tool:FindFirstChild("__TrueVoidWired") then return end
    local marker = Instance.new("BoolValue")
    marker.Name = "__TrueVoidWired"
    marker.Value = true
    marker.Parent = tool

    local equippedConn
    equippedConn = tool.Equipped:Connect(function()
        local sg, toggle = createEraseGUI()
        if sg then sg.Enabled = true end

        -- use player's mouse rather than captured mouse param (more stable)
        local mouse = player and player:GetMouse()
        local trueErasure = trueErasureState

        if toggle and toggle:IsA("TextButton") then
            toggle.Text = (trueErasure and "True Erasure: On" or "True Erasure: Off")
        end

        local togConn
        if toggle then
            togConn = toggle.MouseButton1Click:Connect(function()
                trueErasureState = not trueErasureState
                trueErasure = trueErasureState
                toggle.Text = (trueErasure and "True Erasure: On" or "True Erasure: Off")
            end)
        end

        local clickConn
        if mouse then
            clickConn = mouse.Button1Down:Connect(function()
                local target = mouse.Target
                if not target then return end
                local hum, model = findHumanoidFromDescendant(target)
                if not hum or not model or not isNPC(model) then
                    local hitPos = mouse.Hit and mouse.Hit.p
                    if hitPos then
                        local best, bestDist = nil, math.huge
                        for _,desc in ipairs(Workspace:GetDescendants()) do
                            if desc:IsA("Humanoid") then
                                local mm = desc.Parent
                                if mm and isNPC(mm) then
                                    local hrp = getModelRoot(mm)
                                    if hrp then
                                        local d = (hrp.Position - hitPos).Magnitude
                                        if d < bestDist and d <= 12 then best = mm; bestDist = d end
                                    end
                                end
                            end
                        end
                        if best then hum = best:FindFirstChildOfClass("Humanoid"); model = best end
                    end
                end
                if not hum or not model then return end

                local h = createHandleOnTool(tool)

                if trueErasure then
                    teleportModelToExtreme(model)
                    spawn(function()
                        for _,part in ipairs(model:GetDescendants()) do
                            if part:IsA("BasePart") then
                                waitUntilAtExtreme(part, 2)
                                break
                            end
                        end
                        anchorModelParts(model)
                    end)
                    task.wait(0.5)
                    pcall(function() if h and h.Parent then h:Destroy() end end)
                else
                    task.wait(0.8)
                    pcall(function()
                        if hum and hum.Parent then
                            hum.BreakJointsOnDeath = false
                            hum.Health = 0
                        end
                    end)
                    task.wait(0.2)
                    teleportModelToExtreme(model)
                    task.wait(0.5)
                    pcall(function() if h and h.Parent then h:Destroy() end end)
                end
            end)
        end

        local unequipConn
        unequipConn = tool.Unequipped:Connect(function()
            if togConn then pcall(function() togConn:Disconnect() end) end
            if clickConn then pcall(function() clickConn:Disconnect() end) end
            if sg then sg.Enabled = false end
            pcall(function() if tool:FindFirstChild("Handle") then tool.Handle:Destroy() end end)
            if unequipConn then unequipConn:Disconnect(); unequipConn = nil end
        end)
    end)

    tool.AncestryChanged:Connect(function(_, parent)
        if not parent then
            if equippedConn then equippedConn:Disconnect(); equippedConn = nil end
        end
    end)
end

local function ensureEraseTool()
    local t = giveTool("Erase")
    if t then wireEraseTool(t) end
end

local function watchBackpack()
    local bp = player:FindFirstChildOfClass("Backpack") or player:WaitForChild("Backpack")
    if not bp then return end
    for _,child in ipairs(bp:GetChildren()) do
        if child:IsA("Tool") and child.Name == "Erase" then
            wireEraseTool(child)
        end
    end
    bp.ChildAdded:Connect(function(child)
        if child:IsA("Tool") and child.Name == "Erase" then
            wireEraseTool(child)
        end
    end)
end

-- ====== PASSIVE TOGGLES UI (unchanged layout) ======
local toggleState = {
    Forcefield = false,
    Presence = false,
    Fear = false,
    TimeDelation = false,
    Hidden = false
}

local function createPassiveUI()
    local playerGui = player:FindFirstChildOfClass("PlayerGui") or player:WaitForChild("PlayerGui")
    if playerGui:FindFirstChild("TrueVoid_Passives") then
        local existing = playerGui:FindFirstChild("TrueVoid_Passives")
        return {
            SG = existing,
            XBtn = existing:FindFirstChild("XBtn"),
            ForcefieldBtn = existing:FindFirstChild("ForcefieldBtn"),
            PresenceBtn = existing:FindFirstChild("PresenceBtn"),
            FearBtn = existing:FindFirstChild("FearBtn"),
            TimeDelationBtn = existing:FindFirstChild("TimeDelationBtn"),
        }
    end

    local sg = Instance.new("ScreenGui")
    sg.Name = "TrueVoid_Passives"; sg.ResetOnSpawn = false; sg.Parent = playerGui

    local baseX = UDim2.new(1, -240, 0, 10)
    local width = 200
    local height = 34
    local gap = 6

    local xFrame = Instance.new("Frame", sg)
    xFrame.Size = UDim2.new(0,60,0,34)
    xFrame.Position = UDim2.new(1, -70, 0, 10)
    xFrame.BackgroundTransparency = 0.15
    xFrame.BackgroundColor3 = BG_COLOR
    xFrame.BorderSizePixel = 0

    local xBtn = Instance.new("TextButton", xFrame)
    xBtn.Size = UDim2.new(1, -8, 1, -6)
    xBtn.Position = UDim2.new(0,4,0,3)
    xBtn.Text = "X"
    xBtn.TextColor3 = TEXT_COLOR
    xBtn.Font = Enum.Font.SourceSansBold
    xBtn.TextSize = 18
    xBtn.BackgroundColor3 = Color3.fromRGB(18,18,18)
    xBtn.BorderSizePixel = 0

    local function newToggle(name, posOffset, text)
        local f = Instance.new("Frame", sg)
        f.Size = UDim2.new(0,width,0,height)
        f.Position = UDim2.new(baseX.X.Scale, baseX.X.Offset, baseX.Y.Scale, baseX.Y.Offset + (height + gap) * posOffset)
        f.BackgroundTransparency = 0.15; f.BackgroundColor3 = BG_COLOR; f.BorderSizePixel = 0
        local btn = Instance.new("TextButton", f)
        btn.Size = UDim2.new(1, -8, 1, -6); btn.Position = UDim2.new(0,4,0,3)
        btn.Text = text; btn.TextColor3 = TEXT_COLOR
        btn.BackgroundColor3 = Color3.fromRGB(18,18,18); btn.Font = Enum.Font.SourceSansBold; btn.TextSize = 16; btn.BorderSizePixel = 0
        return f, btn
    end

    local ffFrame, ffBtn = newToggle("Forcefield", 0, "Forcefield: Off")
    local prFrame, prBtn = newToggle("Presence", 1, "Presence: Off")
    local feFrame, feBtn = newToggle("Fear", 2, "Fear: Off")
    local tdFrame, tdBtn = newToggle("TimeDelation", 3, "Time Delation: Off")

    xBtn.MouseButton1Click:Connect(function()
        toggleState.Hidden = not toggleState.Hidden
        if toggleState.Hidden then
            xBtn.Text = "O"
            ffFrame.Visible = false; prFrame.Visible = false; feFrame.Visible = false; tdFrame.Visible = false
        else
            xBtn.Text = "X"
            ffFrame.Visible = true; prFrame.Visible = true; feFrame.Visible = true; tdFrame.Visible = true
        end
    end)

    ffBtn.MouseButton1Click:Connect(function()
        toggleState.Forcefield = not toggleState.Forcefield
        ffBtn.Text = "Forcefield: " .. (toggleState.Forcefield and "On" or "Off")
    end)
    prBtn.MouseButton1Click:Connect(function()
        toggleState.Presence = not toggleState.Presence
        prBtn.Text = "Presence: " .. (toggleState.Presence and "On" or "Off")
    end)
    feBtn.MouseButton1Click:Connect(function()
        toggleState.Fear = not toggleState.Fear
        feBtn.Text = "Fear: " .. (toggleState.Fear and "On" or "Off")
    end)
    tdBtn.MouseButton1Click:Connect(function()
        toggleState.TimeDelation = not toggleState.TimeDelation
        tdBtn.Text = "Time Delation: " .. (toggleState.TimeDelation and "On" or "Off")
    end)

    return {
        SG = sg,
        XBtn = xBtn,
        ForcefieldBtn = ffBtn,
        PresenceBtn = prBtn,
        FearBtn = feBtn,
        TimeDelationBtn = tdBtn
    }
end

local passiveUI = createPassiveUI()

-- ====== FORCEFIELD (radius-based fling, non-lethal) ======
local lastForcefieldAt = {} -- model -> last processed timestamp

local function processForcefieldOnModel(model, centerPos)
    if not model or not model.Parent then return end
    local now = tick()
    if lastForcefieldAt[model] and now - lastForcefieldAt[model] < FORCEFIELD_COOLDOWN then return end
    lastForcefieldAt[model] = now

    local hrp = getModelRoot(model)
    if not hrp then return end
    local ok, pos = pcall(function() return hrp.Position end)
    if not ok or not pos then return end
    local dir = (pos - centerPos)
    if dir.Magnitude <= 0.001 then dir = Vector3.new(0,1,0) end

    local horizExtent = getModelHorizontalExtent(model)
    local AVERAGE_NPC_SIZE = 2.0
    local sizeScale = math.max(1, horizExtent / AVERAGE_NPC_SIZE)

    local velMag = FORCEFIELD_BASE_VEL * sizeScale
    local vel = dir.Unit * velMag + Vector3.new(0, FORCEFIELD_UPWARD_BONUS, 0)

    for _,part in ipairs(model:GetDescendants()) do
        if part:IsA("BasePart") then
            pcall(function() part.AssemblyLinearVelocity = vel end)
        end
    end
end

spawn(function()
    while true do
        if toggleState.Forcefield then
            local center = getPlayerCenterPosition()
            for _,desc in ipairs(Workspace:GetDescendants()) do
                if desc:IsA("Model") and isNPC(desc) then
                    local hrp = getModelRoot(desc)
                    if hrp and hrp.Parent then
                        local ok, pos = pcall(function() return hrp.Position end)
                        if ok and pos and (pos - center).Magnitude <= FORCEFIELD_RADIUS then
                            processForcefieldOnModel(desc, center)
                        end
                    end
                end
            end
        end
        task.wait(FORCEFIELD_CHECK_INTERVAL)
    end
end)

-- ====== PRESENCE ======
local function presenceLoop()
    while true do
        if toggleState.Presence then
            local center = getPlayerCenterPosition()
            if center then
                local records = {}
                for _,desc in ipairs(Workspace:GetDescendants()) do
                    if desc:IsA("Humanoid") then
                        local model = desc.Parent
                        if model and isNPC(model) then
                            local hrp = getModelRoot(model)
                            if hrp and (hrp.Position - center).Magnitude <= PRESENCE_RADIUS then
                                table.insert(records, {hum = desc, model = model})
                            end
                        end
                    end
                end
                for _,r in ipairs(records) do pcall(function() r.hum.BreakJointsOnDeath = false end) end
                for _,r in ipairs(records) do pcall(function() r.hum.Health = 0 end) end
                for _,r in ipairs(records) do
                    spawn(function()
                        task.wait(0.2)
                        teleportModelToExtreme(r.model)
                    end)
                end
            end
        end
        task.wait(PRESENCE_CHECK_INTERVAL)
    end
end

spawn(function() presenceLoop() end)

-- ====== FEAR ======
local fearState = {}
local FEAR_RADIUS = 200

local function applyFearHeartbeat()
    local centerPos = getPlayerCenterPosition()
    if not centerPos then return end

    local toHandle = {}
    for _,desc in ipairs(Workspace:GetDescendants()) do
        if desc:IsA("Humanoid") then
            local model = desc.Parent
            if model and isNPC(model) then
                local hrp = getModelRoot(model)
                if hrp and (hrp.Position - centerPos).Magnitude <= FEAR_RADIUS then
                    table.insert(toHandle, {hum = desc, model = model, hrp = hrp})
                end
            end
        end
    end

    for _,entry in ipairs(toHandle) do
        local model = entry.model
        local hum = entry.hum
        if not fearState[model] then
            local roll = math.random()
            if roll <= 0.7 then
                fearState[model] = { mode = "run", origWalk = hum.WalkSpeed }
            else
                fearState[model] = { mode = "freeze", origWalk = hum.WalkSpeed }
                pcall(function() if hum and hum.Parent then hum.WalkSpeed = 0 end end)
            end
        end
    end

    local currentSet = {}
    for _,e in ipairs(toHandle) do currentSet[e.model] = true end
    for model,s in pairs(fearState) do
        if model and model.Parent then
            if not currentSet[model] then
                local hum = model:FindFirstChildOfClass("Humanoid")
                if hum and s and s.origWalk then
                    pcall(function() hum.WalkSpeed = s.origWalk end)
                end
                fearState[model] = nil
            end
        else
            fearState[model] = nil
        end
    end

    for model,s in pairs(fearState) do
        if model and model.Parent and s.mode == "run" then
            local hum = model:FindFirstChildOfClass("Humanoid")
            local hrp = getModelRoot(model)
            if hum and hrp and hrp.Parent then
                local dir = (hrp.Position - centerPos)
                if dir.Magnitude <= 0.5 then
                    dir = Vector3.new(math.random()-0.5, 0, math.random()-0.5)
                end
                local target = hrp.Position + dir.Unit * 40
                pcall(function() hum:MoveTo(target) end)
            else
                fearState[model] = nil
            end
        end
    end
end

local function clearFearState()
    for model,s in pairs(fearState) do
        if model and model.Parent then
            local hum = model:FindFirstChildOfClass("Humanoid")
            if hum and s.origWalk then
                pcall(function() hum.WalkSpeed = s.origWalk end)
            end
        end
        fearState[model] = nil
    end
end

local heartbeatConn
heartbeatConn = RunService.Heartbeat:Connect(function(dt)
    if toggleState.Fear then
        applyFearHeartbeat()
    else
        if next(fearState) ~= nil then
            clearFearState()
        end
    end
end)

-- ====== TIME DELATION ======
local timeDelationRecords = {}

local function applyTimeDelationOnce()
    for _,entry in ipairs(getAllNPCHumanoids()) do
        local hum = entry.hum
        local model = entry.model
        if toggleState.TimeDelation then
            if model and not timeDelationRecords[model] then
                local origWalk = hum.WalkSpeed
                local origJump = hum.JumpPower or hum.JumpHeight or 0
                timeDelationRecords[model] = { origWalk = origWalk, origJump = origJump }
                pcall(function()
                    hum.WalkSpeed = math.max(1, origWalk * 0.15)
                    if hum.JumpPower then hum.JumpPower = (origJump and origJump * 0.15) or hum.JumpPower end
                end)
            end
        else
            if timeDelationRecords[model] then
                local rec = timeDelationRecords[model]
                pcall(function()
                    if hum and hum.Parent then
                        hum.WalkSpeed = rec.origWalk or hum.WalkSpeed
                        if hum.JumpPower then hum.JumpPower = rec.origJump or hum.JumpPower end
                    end
                end)
                timeDelationRecords[model] = nil
            end
        end
    end
end

local function clearTimeDelation()
    for model,rec in pairs(timeDelationRecords) do
        if model and model.Parent then
            local hum = model:FindFirstChildOfClass("Humanoid")
            if hum then
                pcall(function() hum.WalkSpeed = rec.origWalk or hum.WalkSpeed; if hum.JumpPower then hum.JumpPower = rec.origJump or hum.JumpPower end end)
            end
        end
        timeDelationRecords[model] = nil
    end
end

spawn(function()
    while true do
        if toggleState.TimeDelation then
            applyTimeDelationOnce()
        else
            clearTimeDelation()
        end
        task.wait(TIME_DELATION_INTERVAL)
    end
end)

-- ensure Erase on script start + backpack watcher
ensureEraseTool()
spawn(watchBackpack)

player.CharacterAdded:Connect(function()
    task.wait(0.05)
    ensureEraseTool()
    if passiveUI and passiveUI.SG then passiveUI.SG.Parent = player:FindFirstChildOfClass("PlayerGui") end
end)

print("True Void Part One (forcefield non-lethal fling, fear 70/30) loaded for", player.Name)
