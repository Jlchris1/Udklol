-- Full updated script (client) - includes FallenPartsDestroyHeight = 0/0
-- Notes:
-- * Fallen parts destroy disabled via Workspace.FallenPartsDestroyHeight = 0/0
-- * Skidding stays off when toggled off and is accurate / ping-aware
-- * Cycle behavior preserved
-- * PAA only for BH creation; chat commands removed
-- * Black hole counter HUD removed

local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")

-- Disable automatic fallen part destruction (NaN)
Workspace.FallenPartsDestroyHeight = 0/0

local localPlayer = Players.LocalPlayer

local function clamp(val, a, b)
    if val < a then return a end
    if val > b then return b end
    return val
end

-- ====== CONFIG / STATE ======
local targetAllActive = false
local targetSelectedActive = false
local primaryLoopRunning = false

local switchDelay = 0.13
local processedParts = {}
local initiallyAnchoredParts = {}
local initiallyMasslessParts = {}
local anchoredOnce = false
local unanchorTimerRunning = false
local unanchorCoroutine

local Attachment1 = nil

local extraBlackHoles = {}

-- PAA state
local PAAEnabled = false
local PAA_isUsingSelected = false
local paaConnections = {}

-- Rebalancer
local rebalancerRunning = false
local rebalancerFreq = 0.10

-- BH motion constants
local BH_AMPLITUDE_FACTOR = 0.22
local BH_MIN_AMPLITUDE = 0.6
local BH_MAX_AMPLITUDE = 80
local TARGET_SMOOTHNESS = 6.0

local ROTATE_INTERVAL = 0.2

-- Cycle (was LifeCycleMode) state & helpers
local CycleMode = false
local cycleActive = false
local cyclePlayers = {}
local cycleDead = {}
local cycleConns = {}
local cycleRestartPending = false

-- USER-REQUESTED VALUES (extreme)
local BASE_FLING_AXIS = 1e6
local BASE_PULL_FORCE = 1e8
local BASE_PULL_RESP  = 1e6

local FLING_MULTIPLIER = 9e15
local PULL_MULTIPLIER  = math.huge

local FLING_TORQUE = Vector3.new(BASE_FLING_AXIS * FLING_MULTIPLIER,
                                 BASE_FLING_AXIS * FLING_MULTIPLIER,
                                 BASE_FLING_AXIS * FLING_MULTIPLIER)
local PULL_MAX_FORCE = BASE_PULL_FORCE * PULL_MULTIPLIER
local PULL_RESPONSIVENESS = BASE_PULL_RESP * PULL_MULTIPLIER

local MASSLESS_TORQUE_SCALE = 1.0
local MASSLESS_PULL_SCALE  = 1.0
local MASSLESS_RESP_SCALE  = 1.2

-- SKIDDING toggle and params (new requested behaviour)
local SkiddingEnabled = true  -- optional toggle in GUI
-- Skid timing:
local SKID_STEP = 0.1 -- 0.1s forward, 0.1s backward => 0.2s cycle total
local SKID_MIN_HALF_LENGTH = 0.5

-- Prediction helpers (velocity history)
local playerLastVel = {}
local playerLastVelTime = {}
local playerVelBuffer = {} -- for short-term smoothing [player] = { {t, vel}, ... }

-- Setup folder & primary attachment
local function setupPlayer()
    local Folder = Workspace:FindFirstChild("Ã†S_BlackHole_Folder")
    if not Folder then
        Folder = Instance.new("Folder", Workspace)
        Folder.Name = "Ã†S_BlackHole_Folder"
    end
    local existing = Folder:FindFirstChild("BH_Center_Part")
    if existing and existing:IsA("BasePart") then
        local att = existing:FindFirstChildOfClass("Attachment")
        if att then return att end
        local newAtt = Instance.new("Attachment", existing)
        return newAtt
    end
    local Part = Instance.new("Part", Folder)
    Part.Name = "BH_Center_Part"
    Part.Anchored = true
    Part.CanCollide = false
    Part.Transparency = 1
    Part.Size = Vector3.new(1,1,1)
    local Attachment = Instance.new("Attachment", Part)
    return Attachment
end

Attachment1 = setupPlayer()

-- helpers
local function isNPC(character)
    if not character or not character:IsA("Model") then return false end
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if humanoid and not Players:GetPlayerFromCharacter(character) then return true end
    return false
end

local function isPartPlayerCharacter(part)
    if not part then return false end
    for _, pl in ipairs(Players:GetPlayers()) do
        local char = pl.Character
        if char and part:IsDescendantOf(char) then
            return true
        end
    end
    return false
end

local function stripBodyForces(part)
    for _, x in next, part:GetChildren() do
        if x:IsA("BodyAngularVelocity") or x:IsA("BodyForce") or x:IsA("BodyGyro")
        or x:IsA("BodyPosition") or x:IsA("BodyThrust") or x:IsA("BodyVelocity")
        or x:IsA("RocketPropulsion") then
            x:Destroy()
        end
    end
    if part:FindFirstChild("Attachment") then part:FindFirstChild("Attachment"):Destroy() end
    if part:FindFirstChild("AlignPosition") then part:FindFirstChild("AlignPosition"):Destroy() end
    if part:FindFirstChild("Torque") then part:FindFirstChild("Torque"):Destroy() end
end

local function shuffle(t)
    for i = #t, 2, -1 do
        local j = math.random(1, i)
        t[i], t[j] = t[j], t[i]
    end
end

local function smoothLerpCFrame(curCF, targetCF, dt)
    local alpha = 1 - math.exp(-TARGET_SMOOTHNESS * dt)
    if alpha < 0.001 then alpha = 0.001 end
    if alpha > 1 then alpha = 1 end
    return curCF:Lerp(targetCF, alpha)
end

local function isWhitelisted(player)
    if not player then return false end
    local v = player:FindFirstChild("Whitelisted")
    if v and typeof(v.Value) == "boolean" then
        return v.Value
    end
    return false
end

local function isPlayerAlive(player)
    if not player then return false end
    local char = player.Character
    if not char then return false end
    local humanoid = char:FindFirstChildOfClass("Humanoid")
    if not humanoid then return false end
    if humanoid.Health and humanoid.Health > 0 then return true end
    return false
end

local function getAllNonLocalPlayers()
    local res = {}
    for _, p in ipairs(Players:GetPlayers()) do
        if p and p ~= localPlayer and p.Parent and not isWhitelisted(p) then
            table.insert(res, p)
        end
    end
    return res
end

local function getSelectedPlayers(allowWhitelisted)
    local res = {}
    for _, player in pairs(Players:GetPlayers()) do
        if player and player ~= localPlayer and player.Parent then
            local sel = player:FindFirstChild("Selected")
            if sel and typeof(sel.Value) == "boolean" and sel.Value == true then
                if allowWhitelisted then
                    table.insert(res, player)
                else
                    if not isWhitelisted(player) then table.insert(res, player) end
                end
            end
        end
    end
    return res
end

local function getBHsBySource(source)
    local out = {}
    for _, bh in ipairs(extraBlackHoles) do
        if bh.source == source then table.insert(out, bh) end
    end
    return out
end

local function getLeastLoadedBlackHole()
    if #extraBlackHoles == 0 then return nil end
    table.sort(extraBlackHoles, function(a,b) return (#a.AssignedParts) < (#b.AssignedParts) end)
    return extraBlackHoles[1]
end

-- try to read client-measured ping (seconds). pcall for safety in case API differs.
local function getClientPing()
    local ok, ping = pcall(function()
        if localPlayer and localPlayer.GetNetworkPing then
            return localPlayer:GetNetworkPing()
        end
        return nil
    end)
    if ok and type(ping) == "number" and ping > 0 then
        return ping -- seconds
    end
    -- fallback: assume small ping ~0.075s
    return 0.075
end

-- accumulate a small velocity buffer per player for smoothing & accel estimation
local function pushVelocitySample(pl, vel, now)
    if not pl then return end
    playerVelBuffer[pl] = playerVelBuffer[pl] or {}
    local buf = playerVelBuffer[pl]
    table.insert(buf, 1, {t = now, v = vel})
    -- keep only last ~6 samples (0.2-0.5s worth)
    while #buf > 6 do table.remove(buf) end
end

local function estimateAccelFromBuffer(pl)
    local buf = playerVelBuffer[pl]
    if not buf or #buf < 2 then return Vector3.new(0,0,0) end
    local total = Vector3.new(0,0,0)
    local count = 0
    for i = 1, #buf-1 do
        local cur = buf[i].v
        local nxt = buf[i+1].v
        local dt = buf[i].t - buf[i+1].t
        if dt > 0 then
            total = total + (cur - nxt) / dt
            count = count + 1
        end
    end
    if count == 0 then return Vector3.new(0,0,0) end
    return total / count
end

-- Predict using velocity + acceleration estimate + ping compensation + angular velocity compensation
local function predictTargetPosition(pl, pos, vel, now)
    -- store recent velocity
    pushVelocitySample(pl, vel, now)
    local accel_est = estimateAccelFromBuffer(pl)

    -- client measured ping (round-trip-ish). We'll use it conservatively:
    local ping = getClientPing() -- seconds
    -- add a small base latency estimate to cover server processing (configurable)
    local baseLead = 0.05
    local effectiveLat = clamp(ping + baseLead, 0.03, 0.45) -- clamp to sane bounds

    -- speed-dependent lead multiplier (fast movers need more lead, but cap it)
    local speed = vel.Magnitude
    local speedFactor = clamp(0.12 + (speed * 0.03), 0.12, 1.4)

    -- rotational compensation: if player spinning strongly, predict lateral offsets
    local rotComp = Vector3.new(0,0,0)
    local rotVel = Vector3.new(0,0,0)
    if pl and pl.Character and pl.Character:FindFirstChild("HumanoidRootPart") then
        local hrp = pl.Character.HumanoidRootPart
        local ok, rv = pcall(function() return hrp.RotVelocity end)
        if ok and typeof(rv) == "Vector3" then
            rotVel = rv
        end
    end
    local rotMag = rotVel.Magnitude
    if rotMag > 1 then
        -- convert rotational speed into small lateral movement estimate
        local lateralScale = clamp(rotMag * 0.01 * speed, 0, math.max(0.5, speed * 0.25))
        -- estimate lateral offset perpendicular to velocity
        if speed > 0.001 then
            local perp = Vector3.new(-vel.Z, 0, vel.X).Unit
            if perp then rotComp = perp * lateralScale end
        end
    end

    -- lead time = effectiveLat * speedFactor (seconds)
    local leadTime = effectiveLat * speedFactor
    leadTime = clamp(leadTime, 0.03, 0.6)

    -- predicted position with kinematic equation
    local predicted = pos + vel * leadTime + 0.5 * accel_est * (leadTime * leadTime) + rotComp

    return predicted, leadTime, accel_est, ping
end

-- ForcePart (reordered so AlignPosition/Attachment applied BEFORE torque/anything else)
local function ForcePart(v)
    if not v or not v:IsA("BasePart") then return end
    if isPartPlayerCharacter(v) then return end
    if localPlayer.Character and v:IsDescendantOf(localPlayer.Character) then return end

    if v:IsA("BasePart")
        and not v.Anchored
        and v.Name ~= "Handle"
        and (
            (v.Parent:FindFirstChildOfClass("Humanoid") and isNPC(v.Parent))
            or (not v.Parent:FindFirstChildOfClass("Humanoid") and not v.Parent:FindFirstChild("Head"))
        ) then

        if processedParts[v] then return end
        processedParts[v] = true

        if initiallyMasslessParts[v] == nil then
            pcall(function() initiallyMasslessParts[v] = v.Massless end)
        end

        pcall(function() v.Massless = true end)

        stripBodyForces(v)
        v.CanCollide = false

        -- Create AlignPosition + Attachment first (grab/pull)
        local Attachment2 = Instance.new("Attachment", v)
        pcall(function() Attachment2.WorldCFrame = v.CFrame end)

        local AlignPosition = Instance.new("AlignPosition", v)
        AlignPosition.Attachment0 = Attachment2

        local ok, isMass = pcall(function() return v.Massless end)
        local maxF = PULL_MAX_FORCE
        local resp  = PULL_RESPONSIVENESS
        if ok and isMass == true then
            maxF = maxF * MASSLESS_PULL_SCALE
            resp  = resp * MASSLESS_RESP_SCALE
        end

        AlignPosition.MaxForce = maxF
        AlignPosition.MaxVelocity = math.huge
        AlignPosition.Responsiveness = resp

        -- Now create torque/fling after AlignPosition is set
        local torqueVal = FLING_TORQUE
        if ok and isMass == true then
            torqueVal = torqueVal * MASSLESS_TORQUE_SCALE
        end
        local Torque = Instance.new("Torque", v)
        Torque.Torque = torqueVal
        Torque.Attachment0 = Attachment2

        -- Attach this part to a least loaded BH or to Attachment1
        local bh = getLeastLoadedBlackHole()
        if bh and bh.Attachment and bh._active then
            AlignPosition.Attachment1 = bh.Attachment
            table.insert(bh.AssignedParts, v)
        else
            AlignPosition.Attachment1 = Attachment1
        end
    end
end

local function clearProcessedParts()
    for part, _ in pairs(processedParts) do
        if part and part.Parent then
            stripBodyForces(part)
            part.CanCollide = true
            if initiallyAnchoredParts[part] == false then
                part.Anchored = false
            elseif initiallyAnchoredParts[part] == true then
                part.Anchored = true
            end

            if initiallyMasslessParts[part] ~= nil then
                local original = initiallyMasslessParts[part]
                pcall(function() part.Massless = original end)
            else
                pcall(function() part.Massless = false end)
            end
        end
    end
    processedParts = {}
    initiallyAnchoredParts = {}
    initiallyMasslessParts = {}
    anchoredOnce = false
end

local function anchorAndDelayedUnanchorParts()
    unanchorTimerRunning = true

    local candidateParts = {}
    for _, v in ipairs(Workspace:GetDescendants()) do
        if v:IsA("BasePart")
            and not v.Anchored
            and v.Name ~= "Handle"
            and not isPartPlayerCharacter(v)
            and not (localPlayer.Character and v:IsDescendantOf(localPlayer.Character))
            and (
                (v.Parent:FindFirstChildOfClass("Humanoid") and isNPC(v.Parent))
                or (not v.Parent:FindFirstChildOfClass("Humanoid") and not v.Parent:FindFirstChild("Head"))
            ) then
            table.insert(candidateParts, v)
        end
    end

    initiallyAnchoredParts = {}
    for _, part in ipairs(candidateParts) do
        initiallyAnchoredParts[part] = false
        if initiallyMasslessParts[part] == nil then
            pcall(function() initiallyMasslessParts[part] = part.Massless end)
        end
        pcall(function() part.Massless = true end)

        part.Anchored = true
        part.CanCollide = false
    end

    for _, npcCandidate in ipairs(Workspace:GetChildren()) do
        if isNPC(npcCandidate) then
            for _, p in ipairs(npcCandidate:GetDescendants()) do
                if p:IsA("BasePart") then p.CanCollide = true end
            end
        end
    end

    local startTime = tick()
    while (targetAllActive or targetSelectedActive) and tick() - startTime < 1 do
        wait(0.05)
    end

    for _, part in ipairs(candidateParts) do
        if part and part.Parent and initiallyAnchoredParts[part] == false then
            part.Anchored = false
            pcall(function()
                if not isPartPlayerCharacter(part) and not (localPlayer.Character and part:IsDescendantOf(localPlayer.Character)) then
                    initiallyMasslessParts[part] = initiallyMasslessParts[part] or part.Massless
                    part.Massless = true
                end
            end)
            ForcePart(part)
        end
    end

    unanchorTimerRunning = false
    anchoredOnce = true
end

local descendantAddedConn
local function processWorkspaceParts()
    if descendantAddedConn then
        descendantAddedConn:Disconnect()
        descendantAddedConn = nil
    end

    if (targetAllActive or targetSelectedActive) then
        if not unanchorTimerRunning and not anchoredOnce then
            unanchorCoroutine = coroutine.create(anchorAndDelayedUnanchorParts)
            coroutine.resume(unanchorCoroutine)
        end

        descendantAddedConn = Workspace.DescendantAdded:Connect(function(v)
            if (targetAllActive or targetSelectedActive) then
                if v:IsA("BasePart")
                    and not v.Anchored
                    and not processedParts[v]
                    and not isPartPlayerCharacter(v)
                    and not (localPlayer.Character and v:IsDescendantOf(localPlayer.Character)) then
                    if initiallyMasslessParts[v] == nil then
                        pcall(function() initiallyMasslessParts[v] = v.Massless end)
                    end
                    pcall(function() v.Massless = true end)
                    ForcePart(v)
                end
            end
        end)
    end
end

local function getRandomPlayer()
    local players = getAllNonLocalPlayers()
    if #players == 0 then return nil end
    return players[math.random(1, #players)]
end

-- set BH active/inactive
local function setBlackHoleActiveState(bh, active)
    if not bh then return end
    if bh._active == active then return end
    bh._active = active
    if not active then
        for _, p in ipairs(bh.AssignedParts) do
            if p and p.Parent then
                p.CanCollide = true
                local ap = p:FindFirstChildOfClass("AlignPosition")
                if ap then
                    ap.Attachment1 = Attachment1
                    pcall(function()
                        local isMass = (pcall(function() return p.Massless end) and p.Massless)
                        ap.MaxForce = PULL_MAX_FORCE * (isMass and MASSLESS_PULL_SCALE or 1)
                        ap.Responsiveness = PULL_RESPONSIVENESS * (isMass and MASSLESS_RESP_SCALE or 1)
                    end)
                end
            end
        end
    else
        for _, p in ipairs(bh.AssignedParts) do
            if p and p.Parent then
                local ap = p:FindFirstChildOfClass("AlignPosition")
                if ap then ap.Attachment1 = bh.Attachment; p.CanCollide = false end
            end
        end
    end
end

-- create extra BH helper (restrict to PAA usage; remove CMD creation capability)
local function createExtraBlackHole(initialTarget, source)
    -- enforce PAA-only creation (user requested removing blackhole add via commands)
    if source ~= "PAA" then source = "PAA" end

    if initialTarget == localPlayer then initialTarget = nil end
    if initialTarget and isWhitelisted(initialTarget) and source ~= "CMD_ALLOW_WHITELISTED" then
        initialTarget = nil
    end

    local folder = Workspace:FindFirstChild("Ã†S_BlackHole_Folder") or Instance.new("Folder", Workspace)
    folder.Name = "Ã†S_BlackHole_Folder"
    local part = Instance.new("Part", folder)
    part.Anchored = true
    part.CanCollide = false
    part.Transparency = 1
    part.Size = Vector3.new(1,1,1)
    part.Name = "ExtraBH_Center"

    local att = Instance.new("Attachment", part)

    local bh = {
        Part = part,
        Attachment = att,
        AssignedParts = {},
        TargetPlayer = initialTarget,
        LastTarget = nil,
        _running = true,
        _active = true,
        source = source or "PAA",
        rotating = false,
        smoothedCF = part.CFrame,
        -- skid state
        skidState = 1, -- 1 => forward, -1 => backward; first forward
        skidAccumulator = 0,
    }

    local function isPlayerDisabled(pl)
        if not pl then return false end
        if pl:FindFirstChild("Disabled") and typeof(pl.Disabled.Value) == "boolean" then
            return pl.Disabled.Value
        end
        return false
    end

    -- BH behaviour thread (NEW skid algorithm per user request + improved prediction)
    bh._thread = spawn(function()
        local t = 0
        local lastSetPredictedPos = nil
        while bh._running do
            local dt = RunService.Heartbeat:Wait()
            t = t + dt

            -- If target valid -> track; else idle near Attachment1
            if bh.TargetPlayer and bh.TargetPlayer ~= localPlayer and not isWhitelisted(bh.TargetPlayer) and isPlayerAlive(bh.TargetPlayer) then
                if isPlayerDisabled(bh.TargetPlayer) then
                    setBlackHoleActiveState(bh, false)
                else
                    setBlackHoleActiveState(bh, true)

                    local char = bh.TargetPlayer.Character
                    if char and char:FindFirstChild("HumanoidRootPart") then
                        local hrp = char.HumanoidRootPart
                        local pos = hrp.Position
                        local vel = hrp.Velocity or Vector3.new(0,0,0)
                        local now = tick()

                        -- deterministic prediction using velocity history + ping
                        local predictedPos, leadTime, accel_est, ping = predictTargetPosition(bh.TargetPlayer, pos, vel, now)
                        lastSetPredictedPos = predictedPos

                        -- direction to define forward/back; prefer velocity direction when moving
                        local dir
                        if vel.Magnitude > 0.5 then
                            dir = vel.Unit
                        else
                            dir = hrp.CFrame.LookVector
                        end

                        -- half-length = speed (so total skid = 2*speed)
                        local halfLen = vel.Magnitude
                        if halfLen < SKID_MIN_HALF_LENGTH then halfLen = SKID_MIN_HALF_LENGTH end
                        -- scale halfLen by a small function of leadTime for high-speed cases
                        halfLen = halfLen * clamp(1 + (leadTime * 1.2), 1, 2.8)

                        local desiredPos
                        -- Skidding toggling logic (when disabled: no flips, BH stays at predicted position)
                        if SkiddingEnabled then
                            -- toggle skidState every SKID_STEP seconds; ensure toggling is consistent per-bh
                            bh.skidAccumulator = bh.skidAccumulator + dt
                            if bh.skidAccumulator >= SKID_STEP then
                                bh.skidAccumulator = bh.skidAccumulator - SKID_STEP
                                bh.skidState = -bh.skidState
                            end
                            -- apply forward/back along movement direction using skidState
                            desiredPos = predictedPos + dir * (bh.skidState * halfLen)

                            -- vertical compensation for jumping (makes BH track up)
                            local upwardVel = hrp.Velocity.Y
                            if upwardVel > 1 then
                                local vUp = clamp(upwardVel * 0.45, 0, halfLen)
                                desiredPos = desiredPos + Vector3.new(0, vUp, 0)
                            elseif upwardVel < -2 then
                                -- player falling fast -> allow BH to lead downward slightly
                                desiredPos = desiredPos + Vector3.new(0, clamp(upwardVel * 0.12, -halfLen, 0), 0)
                            end
                        else
                            -- Skidding disabled: ensure stable non-skidding state
                            bh.skidAccumulator = 0
                            bh.skidState = 0
                            desiredPos = predictedPos
                        end

                        -- When the player is rapidly spinning or changing directions, we bias smoothing to a more aggressive alpha
                        local speed = vel.Magnitude
                        local okRot, rotVel = pcall(function() return hrp.RotVelocity end)
                        local rotMag = (okRot and typeof(rotVel) == "Vector3") and rotVel.Magnitude or 0

                        -- Choose responsiveness: faster when speed, rotation, or ping are higher (so BH keeps up)
                        local responsiveness = 10 + (speed * 6) + (rotMag * 0.9) + (leadTime * 25)
                        responsiveness = clamp(responsiveness, 6, 160)

                        -- Build lookAt to orient BH toward predicted travel
                        local lookAt = predictedPos
                        if dir then lookAt = predictedPos + dir end
                        local targetCF = CFrame.new(desiredPos, lookAt)

                        -- Smooth the BH attachment toward targetCF; use responsiveness-based alpha
                        local success, cur = pcall(function() return bh.Attachment.WorldCFrame end)
                        local curCF = success and cur or bh.smoothedCF or bh.Part.CFrame

                        local alpha = 1 - math.exp(-responsiveness * dt)
                        if alpha < 0.01 then alpha = 0.01 end
                        if alpha > 0.99 then alpha = 0.99 end

                        bh.smoothedCF = curCF:Lerp(targetCF, alpha)

                        if bh.Attachment then
                            -- direct set world CFrame for attachment for deterministic tracking
                            bh.Attachment.WorldCFrame = bh.smoothedCF
                        end
                    end
                end
            else
                -- No valid target: idle near Attachment1 deterministically
                setBlackHoleActiveState(bh, false)
                if Attachment1 and Attachment1.Parent and bh.Attachment then
                    local success, cur = pcall(function() return bh.Attachment.WorldCFrame end)
                    local curCF = success and cur or bh.smoothedCF or bh.Part.CFrame
                    local centerCF
                    pcall(function() centerCF = Attachment1.WorldCFrame end)
                    if centerCF then
                        local targetCF = centerCF
                        local idleAlpha = 1 - math.exp(- 8 * dt)
                        if idleAlpha < 0.01 then idleAlpha = 0.01 end
                        if idleAlpha > 0.99 then idleAlpha = 0.99 end
                        bh.smoothedCF = curCF:Lerp(targetCF, idleAlpha)
                        bh.Attachment.WorldCFrame = bh.smoothedCF
                    end
                end
                wait(0.06)
            end
        end
    end)

    table.insert(extraBlackHoles, bh)
    return bh
end

local function destroyExtraBlackHole(bh)
    if not bh then return end
    bh._running = false
    if bh.Part and bh.Part.Parent then bh.Part:Destroy() end
    for _, p in ipairs(bh.AssignedParts) do
        if p and p.Parent then
            local ap = p:FindFirstChildOfClass("AlignPosition")
            if ap then ap.Attachment1 = Attachment1 end
            p.CanCollide = false
            if initiallyMasslessParts[p] ~= nil then
                pcall(function() p.Massless = initiallyMasslessParts[p] end)
            else
                pcall(function() p.Massless = false end)
            end
        end
    end
end

-- delete BHs by source (used for PAA cleanup)
local function deleteBHsBySource(source)
    for i = #extraBlackHoles, 1, -1 do
        local bh = extraBlackHoles[i]
        if bh and bh.source == source then
            destroyExtraBlackHole(bh)
            table.remove(extraBlackHoles, i)
        end
    end
end

-- rotating/distribution code
local rotatingCoroutine = nil
local rotatingActive = false
local function stopRotatingCoroutine()
    rotatingActive = false
    rotatingCoroutine = nil
end

local function distributeBHListEvenly(bhList, players)
    for _, bh in ipairs(bhList) do
        bh.rotating = false
        bh.TargetPlayer = nil
        bh.AssignedParts = {}
    end

    if #players == 0 then
        for _, bh in ipairs(bhList) do
            bh.TargetPlayer = nil
            setBlackHoleActiveState(bh, false)
        end
        stopRotatingCoroutine()
        return
    end

    local totalBH = #bhList
    local playerCount = #players
    local base = math.floor(totalBH / playerCount)
    local remainder = totalBH - (base * playerCount)

    local idx = 1
    for pi = 1, playerCount do
        local pl = players[pi]
        for k = 1, base do
            if bhList[idx] then
                bhList[idx].TargetPlayer = pl
                bhList[idx].rotating = false
                setBlackHoleActiveState(bhList[idx], true)
                if pl.Character and pl.Character:FindFirstChild("HumanoidRootPart") and bhList[idx].Attachment then
                    pcall(function() bhList[idx].Attachment.WorldCFrame = pl.Character.HumanoidRootPart.CFrame end)
                end
                idx = idx + 1
            end
        end
    end

    local rotatingBHs = {}
    for r = 1, remainder do
        if bhList[idx] then
            bhList[idx].rotating = true
            bhList[idx].TargetPlayer = nil
            setBlackHoleActiveState(bhList[idx], true)
            table.insert(rotatingBHs, bhList[idx])
            idx = idx + 1
        end
    end

    stopRotatingCoroutine()
    if #rotatingBHs == 0 then return end

    rotatingActive = true
    rotatingCoroutine = spawn(function()
        local posIndex = 1
        while rotatingActive do
            local curPlayers = {}
            for _, pl in ipairs(players) do
                if pl and pl.Parent and isPlayerAlive(pl) and not isWhitelisted(pl) and pl ~= localPlayer then
                    table.insert(curPlayers, pl)
                end
            end
            if #curPlayers == 0 then
                for _, rb in ipairs(rotatingBHs) do
                    rb.TargetPlayer = nil
                    setBlackHoleActiveState(rb, false)
                end
                break
            end

            for _, rb in ipairs(rotatingBHs) do
                local pick = curPlayers[((posIndex - 1) % #curPlayers) + 1]
                if pick and not isWhitelisted(pick) and pick ~= localPlayer and isPlayerAlive(pick) then
                    rb.TargetPlayer = pick
                    setBlackHoleActiveState(rb, true)
                    if pick.Character and pick.Character:FindFirstChild("HumanoidRootPart") and rb.Attachment then
                        pcall(function() rb.Attachment.WorldCFrame = pick.Character.HumanoidRootPart.CFrame end)
                    end
                else
                    rb.TargetPlayer = nil
                    setBlackHoleActiveState(rb, false)
                end
                posIndex = posIndex + 1
            end

            wait(ROTATE_INTERVAL)
        end
    end)
end

-- PAA assignment wrappers
local function assignTargetsForPAA()
    local paaBHs = getBHsBySource("PAA")
    if #paaBHs == 0 then return end

    local players = {}
    if CycleMode and cycleActive then
        for _, pl in ipairs(cyclePlayers) do
            if pl and pl.Parent and not cycleDead[pl] and isPlayerAlive(pl) then
                table.insert(players, pl)
            end
        end
    else
        if PAA_isUsingSelected then
            players = getSelectedPlayers(true)
        else
            players = getAllNonLocalPlayers()
        end
    end

    shuffle(paaBHs)
    distributeBHListEvenly(paaBHs, players)
end

local function refreshPAA()
    deleteBHsBySource("PAA")
    local targets = {}
    if CycleMode and cycleActive then
        for _, pl in ipairs(cyclePlayers) do
            if pl and pl.Parent and not cycleDead[pl] and isPlayerAlive(pl) then
                table.insert(targets, pl)
            end
        end
    else
        if PAA_isUsingSelected then
            targets = getSelectedPlayers(true)
        else
            targets = getAllNonLocalPlayers()
        end
    end

    for _, tgt in ipairs(targets) do
        if tgt and tgt ~= localPlayer and not isWhitelisted(tgt) then
            local bh = createExtraBlackHole(tgt, "PAA")
            bh.TargetPlayer = tgt
            bh.LastTarget = nil
            setBlackHoleActiveState(bh, true)
            if tgt.Character and tgt.Character:FindFirstChild("HumanoidRootPart") and bh.Attachment then
                pcall(function() bh.Attachment.WorldCFrame = tgt.Character.HumanoidRootPart.CFrame end)
            end
        end
    end

    assignTargetsForPAA()
    if #extraBlackHoles > 0 then startRebalancer() end
end

local function onPlayerAddedForPAA(pl)
    if PAAEnabled and not PAA_isUsingSelected and pl ~= localPlayer and not isWhitelisted(pl) then
        if CycleMode and cycleActive then
            return
        end
        local bh = createExtraBlackHole(pl, "PAA")
        bh.TargetPlayer = pl
        bh.LastTarget = nil
        assignTargetsForPAA()
    end
end

local function onPlayerRemovingForPAA(pl)
    if PAAEnabled then
        for i = #extraBlackHoles, 1, -1 do
            local bh = extraBlackHoles[i]
            if bh and bh.source == "PAA" and bh.TargetPlayer == pl then
                destroyExtraBlackHole(bh)
                table.remove(extraBlackHoles, i)
                break
            end
        end
        assignTargetsForPAA()
    end
end

-- Cycle / rebalancer and other management functions
local function clearCycleConnections()
    for _, conn in ipairs(cycleConns) do
        if conn and conn.Disconnect then
            pcall(function() conn:Disconnect() end)
        end
    end
    cycleConns = {}
end

local function stopCycle()
    cycleActive = false
    cyclePlayers = {}
    cycleDead = {}
    clearCycleConnections()
    cycleRestartPending = false
end

local function checkCycleCompletionAndMaybeRestart()
    if not cycleActive then return end
    if #cyclePlayers == 0 then
        cycleRestartPending = true
        return
    end
    for _, pl in ipairs(cyclePlayers) do
        if not cycleDead[pl] then
            return
        end
    end
    cycleRestartPending = true
end

local function scheduleCycleRestart()
    if cycleRestartPending then
        cycleRestartPending = false
        spawn(function()
            wait(0.12)
            local newSnapshot = {}
            if targetSelectedActive then
                newSnapshot = getSelectedPlayers(false)
            else
                newSnapshot = getAllNonLocalPlayers()
            end
            cyclePlayers = {}
            cycleDead = {}
            for _, pl in ipairs(newSnapshot) do
                if pl and pl.Parent and pl ~= localPlayer then
                    cyclePlayers[#cyclePlayers+1] = pl
                    cycleDead[pl] = false
                end
            end
            clearCycleConnections()
            for _, pl in ipairs(cyclePlayers) do
                if pl and pl.Parent then
                    local function onHumanoidAdded(char)
                        local hum = char:FindFirstChildOfClass("Humanoid")
                        if hum then
                            local dconn = hum.Died:Connect(function()
                                cycleDead[pl] = true
                                assignTargetsForPAA()
                                checkCycleCompletionAndMaybeRestart()
                            end)
                            table.insert(cycleConns, dconn)
                        end
                    end
                    if pl.Character then
                        onHumanoidAdded(pl.Character)
                    end
                    local cconn = pl.CharacterAdded:Connect(onHumanoidAdded)
                    table.insert(cycleConns, cconn)
                    local rconn = pl.AncestryChanged:Connect(function()
                        if not pl.Parent then
                            for i = #cyclePlayers, 1, -1 do
                                if cyclePlayers[i] == pl then table.remove(cyclePlayers, i) end
                            end
                            cycleDead[pl] = true
                            assignTargetsForPAA()
                            checkCycleCompletionAndMaybeRestart()
                        end
                    end)
                    table.insert(cycleConns, rconn)
                end
            end
            assignTargetsForPAA()
        end)
    end
end

local function startCycleSnapshot()
    stopCycle()
    cycleActive = true
    cyclePlayers = {}
    cycleDead = {}

    local snapshot = {}
    if targetSelectedActive then
        snapshot = getSelectedPlayers(false)
    else
        snapshot = getAllNonLocalPlayers()
    end

    for _, pl in ipairs(snapshot) do
        if pl and pl.Parent and pl ~= localPlayer then
            cyclePlayers[#cyclePlayers+1] = pl
            cycleDead[pl] = false
        end
    end

    clearCycleConnections()
    for _, pl in ipairs(cyclePlayers) do
        if pl and pl.Parent then
            local function attachHumanoidWatcher(char)
                local hum = char:FindFirstChildOfClass("Humanoid")
                if hum then
                    local dconn = hum.Died:Connect(function()
                        cycleDead[pl] = true
                        assignTargetsForPAA()
                        checkCycleCompletionAndMaybeRestart()
                        scheduleCycleRestart()
                    end)
                    table.insert(cycleConns, dconn)
                end
            end
            if pl.Character then attachHumanoidWatcher(pl.Character) end
            local cconn = pl.CharacterAdded:Connect(attachHumanoidWatcher)
            table.insert(cycleConns, cconn)
            local rconn = pl.AncestryChanged:Connect(function()
                if not pl.Parent then
                    for i = #cyclePlayers, 1, -1 do
                        if cyclePlayers[i] == pl then table.remove(cyclePlayers, i) end
                    end
                    cycleDead[pl] = true
                    assignTargetsForPAA()
                    checkCycleCompletionAndMaybeRestart()
                    scheduleCycleRestart()
                end
            end)
            table.insert(cycleConns, rconn)
        end
    end

    assignTargetsForPAA()
end

-- helper wrapper: try start cycle if mode enabled and we have active targeting
local function tryStartCycleIfNeeded()
    if CycleMode and not cycleActive and (targetAllActive or targetSelectedActive) then
        startCycleSnapshot()
    end
end

local function endCycleMode()
    stopCycle()
end

local function resetCycleNow()
    stopCycle()
    startCycleSnapshot()
end

function startRebalancer()
    if rebalancerRunning then return end
    rebalancerRunning = true
    spawn(function()
        while rebalancerRunning do
            local bhCount = #extraBlackHoles
            local parts = {}
            for p, _ in pairs(processedParts) do
                if p and p.Parent then
                    local ap = p:FindFirstChildOfClass("AlignPosition")
                    if ap then
                        pcall(function()
                            local isMass = (pcall(function() return p.Massless end) and p.Massless)
                            ap.MaxForce = PULL_MAX_FORCE * (isMass and MASSLESS_PULL_SCALE or 1)
                            ap.Responsiveness = PULL_RESPONSIVENESS * (isMass and MASSLESS_RESP_SCALE or 1)
                        end)
                        table.insert(parts, p)
                    else
                        ForcePart(p)
                        local ap2 = p:FindFirstChildOfClass("AlignPosition")
                        if ap2 then
                            pcall(function()
                                local isMass = (pcall(function() return p.Massless end) and p.Massless)
                                ap2.MaxForce = PULL_MAX_FORCE * (isMass and MASSLESS_PULL_SCALE or 1)
                                ap2.Responsiveness = PULL_RESPONSIVENESS * (isMass and MASSLESS_RESP_SCALE or 1)
                            end)
                            table.insert(parts, p)
                        end
                    end
                end
            end

            if bhCount > 0 and #parts > 0 then
                local total = #parts
                local base = math.floor(total / bhCount)
                local rem = total - (base * bhCount)
                local counts = {}
                for i = 1, bhCount do counts[i] = base + (i <= rem and 1 or 0) end

                local partIndex = 1
                for i = 1, bhCount do
                    local bh = extraBlackHoles[i]
                    local need = counts[i]
                    for c = 1, need do
                        local p = parts[partIndex]
                        if not p then break end
                        local ap = p:FindFirstChildOfClass("AlignPosition")
                        if ap then
                            if bh and bh.Attachment and bh._active then
                                ap.Attachment1 = bh.Attachment
                                p.CanCollide = false
                                table.insert(bh.AssignedParts, p)
                            else
                                ap.Attachment1 = Attachment1
                                p.CanCollide = false
                            end
                        end
                        partIndex = partIndex + 1
                    end
                end
            else
                for _, p in ipairs(parts) do
                    local ap = p:FindFirstChildOfClass("AlignPosition")
                    if ap then ap.Attachment1 = Attachment1; p.CanCollide = false end
                end
            end

            if PAAEnabled then assignTargetsForPAA() end

            if cycleRestartPending then
                scheduleCycleRestart()
            end

            wait(rebalancerFreq)
        end
    end)
end

function stopRebalancer() rebalancerRunning = false end

-- Primary loop (keeps Attachment1 moving around main target)
local function startPrimaryLoop()
    if primaryLoopRunning then return end
    primaryLoopRunning = true
    if not Attachment1 or not Attachment1.Parent then Attachment1 = setupPlayer() end
    anchoredOnce = false
    processWorkspaceParts()

    spawn(function()
        local phaseT = 0
        local lastHeartbeat = tick()
        while targetAllActive or targetSelectedActive do
            local now = tick()
            local dt = now - lastHeartbeat
            lastHeartbeat = now
            phaseT = phaseT + dt

            local targetPlayer
            if targetSelectedActive then
                local selectedPlayers = getSelectedPlayers(true)
                if #selectedPlayers > 0 then
                    targetPlayer = selectedPlayers[math.random(1, #selectedPlayers)]
                else
                    targetPlayer = nil
                end
            elseif targetAllActive then
                targetPlayer = getRandomPlayer()
            else
                targetPlayer = nil
            end

            if targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") and isPlayerAlive(targetPlayer) then
                local hrp = targetPlayer.Character.HumanoidRootPart
                local vel = hrp.Velocity or Vector3.new(0,0,0)
                local speed = vel.Magnitude
                local dir = (speed > 0.5) and vel.Unit or hrp.CFrame.LookVector
                local amplitude = clamp(speed * BH_AMPLITUDE_FACTOR, BH_MIN_AMPLITUDE, BH_MAX_AMPLITUDE)
                local phase = phaseT * (2 * math.pi * (1 / (0.01 * 2)))
                local primaryOffset = dir * (math.sin(phase) * amplitude)
                local lateral = hrp.CFrame.RightVector * (math.sin(phase * 1.27) * amplitude * 0.35)
                local vertical = hrp.CFrame.UpVector * (math.sin(phase * 1.0) * amplitude * 0.5)
                local targetCFrame = hrp.CFrame * CFrame.new(primaryOffset + lateral + vertical)
                if Attachment1 then
                    local success, cur = pcall(function() return Attachment1.WorldCFrame end)
                    local curCF = success and cur or Attachment1.WorldCFrame or hrp.CFrame
                    Attachment1.WorldCFrame = smoothLerpCFrame(curCF, targetCFrame, dt)
                end
            end

            wait(switchDelay)
        end

        primaryLoopRunning = false
        if unanchorTimerRunning and unanchorCoroutine then
            unanchorTimerRunning = false
            for part, anchored in pairs(initiallyAnchoredParts) do
                if part and part.Parent and anchored == false then
                    part.Anchored = false
                    ForcePart(part)
                end
            end
        end
        clearProcessedParts()

        if PAAEnabled then deleteBHsBySource("PAA") end
    end)
end

local function setTargetAll(value)
    targetAllActive = value
    if (targetAllActive or targetSelectedActive) then startPrimaryLoop() end

    if CycleMode then
        if targetAllActive then
            tryStartCycleIfNeeded()
        else
            endCycleMode()
        end
    end

    if PAAEnabled then
        if targetAllActive then
            PAA_isUsingSelected = false
            refreshPAA()
            if #paaConnections == 0 then
                paaConnections[#paaConnections+1] = Players.PlayerAdded:Connect(onPlayerAddedForPAA)
                paaConnections[#paaConnections+1] = Players.PlayerRemoving:Connect(onPlayerRemovingForPAA)
            end
        else
            deleteBHsBySource("PAA")
        end
    end
end

local function setTargetSelected(value)
    targetSelectedActive = value
    if (targetAllActive or targetSelectedActive) then startPrimaryLoop() end

    if CycleMode then
        if targetSelectedActive then
            tryStartCycleIfNeeded()
        else
            endCycleMode()
        end
    end

    if PAAEnabled then
        if targetSelectedActive then
            PAA_isUsingSelected = true
            refreshPAA()
            if #paaConnections == 0 then
                paaConnections[#paaConnections+1] = Players.PlayerAdded:Connect(onPlayerAddedForPAA)
                paaConnections[#paaConnections+1] = Players.PlayerRemoving:Connect(onPlayerRemovingForPAA)
            end
        else
            deleteBHsBySource("PAA")
        end
    end
end

local function onCharacterAdded(character)
    if (targetAllActive or targetSelectedActive) then
        processedParts = {}
        processWorkspaceParts()
    end
end

Players.LocalPlayer.CharacterAdded:Connect(onCharacterAdded)

-- GUI (TurtleLib)
local library = loadstring(game:HttpGet("https://raw.githubusercontent.com/miroeramaa/TurtleLib/main/TurtleUiLib.lua"))()
local window = library:Window("Fix it you panis negorðŸ—£ðŸ”¥")

window:Toggle("Unanchored Target All", false, function(Value) setTargetAll(Value) end)
window:Toggle("Target Selected Players", false, function(Value) setTargetSelected(Value) end)

-- Cycle toggle (renamed from Life Cycle Mode to Cycle)
window:Toggle("Cycle", false, function(Value)
    CycleMode = Value
    if CycleMode then
        tryStartCycleIfNeeded()
    else
        endCycleMode()
    end
end)

window:Button("Reset Cycle", function()
    resetCycleNow()
end)

window:Button("Load Player List Script", function()
    loadstring(game:HttpGet("https://raw.githubusercontent.com/Jlchris1/Udklol/refs/heads/main/Playerlistv6"))()
end)
window:Button("telekinesis/fix target", function()
    loadstring(game:HttpGet(('https://raw.githubusercontent.com/SAZXHUB/Control-update/main/README.md'), true))()
end)

local loopCheckActive = false
window:Toggle("Continuous Loop Check", false, function(Value)
    loopCheckActive = Value
    if loopCheckActive then
        spawn(function()
            while loopCheckActive do
                if targetAllActive or targetSelectedActive then
                    for _, v in ipairs(Workspace:GetDescendants()) do
                        if v:IsA("BasePart") and not v.Anchored and not processedParts[v] and not isPartPlayerCharacter(v) and not (localPlayer.Character and v:IsDescendantOf(localPlayer.Character)) then
                            if initiallyMasslessParts[v] == nil then pcall(function() initiallyMasslessParts[v] = v.Massless end) end
                            pcall(function() v.Massless = true end)
                            ForcePart(v)
                        end
                    end
                end
                wait(0.5)
            end
        end)
    end
end)

-- Keep PAA UI intact; this is the only blackhole auto-adding system left
window:Toggle("PAA/unPAA (player amount BHs)", false, function(Value)
    PAAEnabled = Value
    if PAAEnabled then
        PAA_isUsingSelected = false
        refreshPAA()
        paaConnections[#paaConnections+1] = Players.PlayerAdded:Connect(onPlayerAddedForPAA)
        paaConnections[#paaConnections+1] = Players.PlayerRemoving:Connect(onPlayerRemovingForPAA)
    else
        for _, c in ipairs(paaConnections) do pcall(function() c:Disconnect() end) end
        paaConnections = {}
        deleteBHsBySource("PAA")
    end
end)

-- SKIDDING toggle (user requested optional toggle)
window:Toggle("Skidding (0.1s forward/back)", SkiddingEnabled, function(Value)
    SkiddingEnabled = Value
    -- When disabling skidding, immediately force all BHs to non-skidding state and reset their accumulators
    if not SkiddingEnabled then
        for _, bh in ipairs(extraBlackHoles) do
            if bh then
                bh.skidAccumulator = 0
                bh.skidState = 0
            end
        end
    else
        -- when enabling, ensure each BH starts on forward step
        for _, bh in ipairs(extraBlackHoles) do
            if bh then
                bh.skidAccumulator = 0
                bh.skidState = 1
            end
        end
    end
end)

-- Removed: Create 3 Blackholes / Delete DBH / chat commands / CMD creation UI per user instruction
-- Removed: Black hole counter HUD (deleted as requested)

spawn(function()
    while true do
        if PAAEnabled then
            if PAA_isUsingSelected then
                if targetSelectedActive then refreshPAA() end
            else
                if targetAllActive then refreshPAA() end
            end
        end
        wait(2)
    end
end)

spawn(function()
    while true do
        if #extraBlackHoles > 0 and not rebalancerRunning then startRebalancer()
        elseif #extraBlackHoles == 0 and rebalancerRunning then stopRebalancer() end
        if cycleRestartPending then scheduleCycleRestart() end
        wait(0.5)
    end
end)

-- End of script
