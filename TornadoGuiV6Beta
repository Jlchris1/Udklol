-- Tornado (Friendly / Nightmare) LocalScript â€” FIXED: horizontal vortices & nightmare flings
-- Paste into StarterPlayerScripts or PlayerGui

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local localPlayer = Players.LocalPlayer

-- ========== Configurable Settings ==========
local enabled = false
local tornadoSpinSpeed = 80
local tornadoUpwardSpeed = 50
local tornadoWindfield = 100
local tornadoMoveSpeed = 10
local tornadoInwardPullSpeed = 50
local maxTornadoHeight = 60 -- parts above this will be teleported back down toward ground

local baseplateName = "Baseplate"

-- Satellite settings (adjustable via GUI)
local maxPartsPerSatellite = 6
local maxSubVortices = 3
local satelliteChaseSpeed = 20 -- studs/sec (only used in NIGHTMARE)
local satelliteOrbitRadius = 10
local satelliteRotationSpeed = 3.5
local horizontalVortexAttachRadius = 30
local satelliteMainOrbitAttackCount = 3
local satelliteMainOrbitAttackRate = 1

-- Vertical vortex (wiggly chain) settings
local verticalChainMinParts = 3
local verticalChainMaxParts = 6
local verticalChainSpeed = 0.7
local verticalChainAmplitude = 4
local verticalChainFrequency = 6
local verticalChainSegmentDelay = 0.12
local verticalAttachDistance = 2.0

-- Horizontal vortex settings (RESTORED & adjusted)
local horizontalVortexMaxPerMain = 4         -- how many horizontal vortices around main funnel
local horizontalVortexMaxPerSatellite = 2    -- per satellite
local horizontalVortexPartsPerVortex = 6     -- default parts per horizontal vortex (satellite overrides to 1/3 rule)
local horizontalVortexRadiusMin = 18
local horizontalVortexRadiusMax = 50         -- increased to 50 studs as requested
local horizontalVortexSpeedMin = 30
local horizontalVortexSpeedMax = 90
local horizontalVortexDetectRadius = 50      -- increased detect radius
local horizontalVortexAttachDistance = 3.0   -- when a vortex part gets within this distance of player's HRP, attach
local horizontalVortexLifetime = 5           -- seconds before vortex retreats

-- ========== Runtime State ==========
local tornadoPosition = nil
local pickedUpByFunnel = {}      -- part -> true (picked)
local whitelistedParts = {}      -- part -> true (available pool)
local assignedToSatellite = {}   -- part -> satelliteId or true
local assignedToVortex = {}      -- part -> vortexId or true (horizontal)
local debrisAttachedToPlayer = {}-- part -> player

local satelliteVortices = {}     -- id -> satellite table
local satelliteAttackState = {}  -- id -> attack state
local nextSatelliteId = 1

local horizontalVortices = {}    -- id -> vortex table
local nextHorizontalVortexId = 1

local playerAttachmentMap = {}   -- player -> Attachment on HRP
local playerTargetThreads = {}   -- player -> boolean
local playerPrevDist = {}        -- player -> previous distance to tornado (for threshold triggers)

local playerDebrisCount = {}     -- player -> number of debris parts attached

local nightmareMode = false

-- ========== UI ==========
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "TornadoBlastGUI"
screenGui.ResetOnSpawn = false
screenGui.DisplayOrder = 100
screenGui.IgnoreGuiInset = true
screenGui.Parent = localPlayer:WaitForChild("PlayerGui")

local hideToggle = Instance.new("TextButton")
hideToggle.Size = UDim2.new(0, 40, 0, 20)
hideToggle.Position = UDim2.new(0, 10, 0.5, -10)
hideToggle.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
hideToggle.TextColor3 = Color3.fromRGB(255, 255, 255)
hideToggle.Font = Enum.Font.SourceSansBold
hideToggle.TextSize = 14
hideToggle.Text = "Hide"
hideToggle.Parent = screenGui

local inputsVisible = true
local function toggleInputs()
    inputsVisible = not inputsVisible
    for _, child in ipairs(screenGui:GetChildren()) do
        if (child:IsA("TextBox") or child:IsA("TextLabel")) and not (child == hideToggle or child == toggleBtn or child == modeToggle) then
            child.Visible = inputsVisible
        end
    end
end

hideToggle.MouseButton1Click:Connect(function()
    toggleInputs()
    hideToggle.Text = inputsVisible and "Hide" or "Show"
end)

local function createLabeledTextbox(labelText, default, index)
    local perRow = 4
    local row = math.floor(index / perRow)
    local col = index % perRow
    local xOffset = 0.02 + 0.25 * col
    local yOffset = 60 + (row * 60)

    local label = Instance.new("TextLabel")
    label.Size = UDim2.new(0, 160, 0, 16)
    label.Position = UDim2.new(xOffset, 0, 0, yOffset)
    label.BackgroundTransparency = 1
    label.Text = labelText
    label.TextColor3 = Color3.fromRGB(255, 255, 255)
    label.Font = Enum.Font.SourceSans
    label.TextSize = 14
    label.ZIndex = 2
    label.Parent = screenGui

    local box = Instance.new("TextBox")
    box.Size = UDim2.new(0, 160, 0, 20)
    box.Position = UDim2.new(xOffset, 0, 0, yOffset + 18)
    box.BackgroundColor3 = Color3.fromRGB(240, 240, 240)
    box.TextColor3 = Color3.fromRGB(0, 0, 0)
    box.Font = Enum.Font.SourceSans
    box.TextSize = 14
    box.Text = tostring(default)
    box.ZIndex = 2
    box.Parent = screenGui

    return box
end

local inputBoxes = {
    {"Spin Speed", tornadoSpinSpeed},
    {"Upward Speed", tornadoUpwardSpeed},
    {"Windfield Radius", tornadoWindfield},
    {"Tornado Movement Speed", tornadoMoveSpeed},
    {"Inward Pull Speed", tornadoInwardPullSpeed},
    {"Max Parts / Satellite", maxPartsPerSatellite},
    {"Max Sub-Vortices", maxSubVortices},
}

local references = {}
for i, data in ipairs(inputBoxes) do
    references[i] = createLabeledTextbox(data[1], data[2], i - 1)
end

-- toggleBtn and modeToggle must exist before toggleInputs references them
local toggleBtn = Instance.new("TextButton")
toggleBtn.Size = UDim2.new(0, 24, 0, 24)
toggleBtn.Position = UDim2.new(0.5, -130, 0, 10)
toggleBtn.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
toggleBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
toggleBtn.Font = Enum.Font.SourceSansBold
toggleBtn.TextSize = 16
toggleBtn.Text = "O"
toggleBtn.ZIndex = 2
toggleBtn.Parent = screenGui

local modeToggle = Instance.new("TextButton")
modeToggle.Size = UDim2.new(0, 120, 0, 24)
modeToggle.Position = UDim2.new(0.5, -100, 0, 40)
modeToggle.BackgroundColor3 = Color3.fromRGB(70, 30, 30)
modeToggle.TextColor3 = Color3.fromRGB(255, 255, 255)
modeToggle.Font = Enum.Font.SourceSansBold
modeToggle.TextSize = 14
modeToggle.Text = "Mode: Friendly"
modeToggle.Parent = screenGui

-- forward declarations for functions used in toggle handler
local stopFiringAtPlayer, cleanupDebrisForPlayer

modeToggle.MouseButton1Click:Connect(function()
    nightmareMode = not nightmareMode
    modeToggle.Text = nightmareMode and "Mode: Nightmare" or "Mode: Friendly"

    -- If we switched into Friendly, immediately stop all player attachments/attack threads and cleanup any attached debris
    if not nightmareMode then
        -- stop firing threads and cleanup debris for all players
        for pl, _ in pairs(playerTargetThreads) do
            stopFiringAtPlayer(pl)
        end
        -- cleanup any existing debris attachments
        for part, plr in pairs(debrisAttachedToPlayer) do
            if plr then cleanupDebrisForPlayer(plr) end
        end
        -- ensure satellites stop chasing
        for id, _ in pairs(satelliteAttackState) do
            satelliteAttackState[id] = {attackingPlayers = {}, attackThreads = {}}
        end
    end
end)

-- Bind UI values (and ensure dynamic satellite count changes trigger immediate spawn/despawn)
references[1].FocusLost:Connect(function() local v = tonumber(references[1].Text); if v then tornadoSpinSpeed = v end end)
references[2].FocusLost:Connect(function() local v = tonumber(references[2].Text); if v then tornadoUpwardSpeed = v end end)
references[3].FocusLost:Connect(function() local v = tonumber(references[3].Text); if v then tornadoWindfield = v end end)
references[4].FocusLost:Connect(function() local v = tonumber(references[4].Text); if v then tornadoMoveSpeed = v end end)
references[5].FocusLost:Connect(function() local v = tonumber(references[5].Text); if v then tornadoInwardPullSpeed = v end end)
references[6].FocusLost:Connect(function()
    local v = tonumber(references[6].Text)
    if v then maxPartsPerSatellite = math.max(1, math.floor(v)) end
end)

local function adjustSatelliteCount(newCount)
    newCount = math.max(0, math.floor(newCount or maxSubVortices))
    maxSubVortices = newCount
    references[7].Text = tostring(maxSubVortices)
    if not enabled or not tornadoPosition then return end

    -- compute current satellite count
    local current = 0
    for _ in pairs(satelliteVortices) do current = current + 1 end

    if newCount > current then
        local toSpawn = newCount - current
        local orbitRad = math.clamp(tornadoWindfield * 0.3, 8, tornadoWindfield * 0.7)
        local startAngle = math.random() * math.pi * 2
        for i = 1, toSpawn do
            local angle = startAngle + (2 * math.pi * (i - 1) / newCount) + (math.random()*0.2 - 0.1)
            local pos = tornadoPosition + Vector3.new(math.cos(angle) * orbitRad, 10 + math.random()*6, math.sin(angle) * orbitRad)
            spawnSatelliteAt(pos)
        end
    elseif newCount < current then
        local ids = {}
        for id, _ in pairs(satelliteVortices) do table.insert(ids, id) end
        table.sort(ids, function(a,b) return a > b end)
        local toRemove = current - newCount
        for i = 1, toRemove do
            despawnSatellite(ids[i])
        end
    end
end

references[7].FocusLost:Connect(function()
    local v = tonumber(references[7].Text)
    if v then adjustSatelliteCount(v) end
end)

-- ========== Helper functions ==========
local function isPlayerPart(part)
    for _, plr in ipairs(Players:GetPlayers()) do
        if plr.Character and part:IsDescendantOf(plr.Character) then return true end
    end
    return false
end

local function processPartForFunnel(obj)
    if obj:IsA("BasePart") and not obj.Anchored and not isPlayerPart(obj) and obj.Name ~= baseplateName then
        if not whitelistedParts[obj] and not assignedToSatellite[obj] and not assignedToVortex[obj] and not debrisAttachedToPlayer[obj] then
            pickedUpByFunnel[obj] = true
            whitelistedParts[obj] = true
        end
    end
end

local function claimPartsForSatellite(n)
    local claimed = {}
    for part in pairs(whitelistedParts) do
        if #claimed >= n then break end
        if part and part.Parent and not part.Anchored and not debrisAttachedToPlayer[part] and not assignedToSatellite[part] and not assignedToVortex[part] then
            table.insert(claimed, part)
            assignedToSatellite[part] = true
            whitelistedParts[part] = nil
            pickedUpByFunnel[part] = nil
        end
    end
    return claimed
end

local function claimPartsForHorizontal(n, preferredParts)
    local claimed = {}
    -- prefer preferredParts table (list)
    if preferredParts then
        for _, part in ipairs(preferredParts) do
            if #claimed >= n then break end
            if part and part.Parent and not part.Anchored and not debrisAttachedToPlayer[part] and not assignedToSatellite[part] and not assignedToVortex[part] then
                table.insert(claimed, part)
                assignedToVortex[part] = true
                whitelistedParts[part] = nil
                pickedUpByFunnel[part] = nil
            end
        end
    end
    for part in pairs(whitelistedParts) do
        if #claimed >= n then break end
        if part and part.Parent and not part.Anchored and not debrisAttachedToPlayer[part] and not assignedToSatellite[part] and not assignedToVortex[part] then
            table.insert(claimed, part)
            assignedToVortex[part] = true
            whitelistedParts[part] = nil
            pickedUpByFunnel[part] = nil
        end
    end
    return claimed
end

-- teleport part down to ground under it to keep tornado shape when it reaches max height
local function lowerPartToGround(part)
    if not part or not part.Parent or not tornadoPosition then return end
    local origin = part.Position + Vector3.new(0, 200, 0)
    local direction = Vector3.new(0, -400, 0)
    local rayParams = RaycastParams.new()
    rayParams.FilterDescendantsInstances = {part}
    rayParams.FilterType = Enum.RaycastFilterType.Blacklist
    local result = Workspace:Raycast(origin, direction, rayParams)
    if result and result.Position then
        local groundY = result.Position.Y
        part.CFrame = CFrame.new(part.Position.X, groundY + 1.5, part.Position.Z)
        part.AssemblyLinearVelocity = Vector3.zero
    else
        -- fallback: place near tornado base
        part.CFrame = CFrame.new(part.Position.X, tornadoPosition.Y + 2, part.Position.Z)
        part.AssemblyLinearVelocity = Vector3.zero
    end
end

-- ========== Attach / cleanup functions ==========
local function getPlayerAttachment(targetPlayer)
    if not targetPlayer or not targetPlayer.Character then return nil end
    if playerAttachmentMap[targetPlayer] and playerAttachmentMap[targetPlayer].Parent then return playerAttachmentMap[targetPlayer] end
    local hrp = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not hrp then return nil end
    local att = Instance.new("Attachment")
    att.Name = "Tornado_TargetAttachment"
    att.Parent = hrp
    playerAttachmentMap[targetPlayer] = att
    return att
end

local function attachDebrisToPlayer(debrisPart, targetPlayer)
    -- IMPORTANT: attachments only happen in NIGHTMARE mode. Friendly mode is non-aggressive.
    if not nightmareMode then return end

    if not debrisPart or not debrisPart.Parent or not targetPlayer or not targetPlayer.Character then return end
    if debrisAttachedToPlayer[debrisPart] then return end
    if targetPlayer == localPlayer then return end

    local hrp = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not hrp then return end

    for _, x in next, debrisPart:GetChildren() do
        if x:IsA("BodyAngularVelocity") or x:IsA("BodyForce") or x:IsA("BodyGyro") or x:IsA("BodyPosition")
            or x:IsA("BodyThrust") or x:IsA("BodyVelocity") or x:IsA("RocketPropulsion") then
            x:Destroy()
        end
    end

    debrisPart.CanCollide = false

    local attachDeb = Instance.new("Attachment")
    attachDeb.Name = "Tornado_DebrisAttachment"
    attachDeb.Parent = debrisPart

    local align = Instance.new("AlignPosition")
    align.MaxForce = math.huge
    align.MaxVelocity = math.huge
    align.Responsiveness = 200
    align.Attachment0 = attachDeb
    align.Attachment1 = getPlayerAttachment(targetPlayer)
    align.Parent = debrisPart

    local torque = Instance.new("Torque")
    torque.Attachment0 = attachDeb
    torque.Parent = debrisPart

    debrisAttachedToPlayer[debrisPart] = targetPlayer
    playerDebrisCount[targetPlayer] = (playerDebrisCount[targetPlayer] or 0) + 1
    -- clear assignments so other systems won't try to mess with it
    assignedToSatellite[debrisPart] = nil
    assignedToVortex[debrisPart] = nil
    whitelistedParts[debrisPart] = nil
    pickedUpByFunnel[debrisPart] = nil
end

function cleanupDebrisForPlayer(targetPlayer)
    for part, pl in pairs(debrisAttachedToPlayer) do
        if pl == targetPlayer then
            if part and part.Parent then
                for _, child in ipairs(part:GetChildren()) do
                    if child:IsA("AlignPosition") or child:IsA("Attachment") or child:IsA("Torque") then child:Destroy() end
                end
                part.CanCollide = true
            end
            debrisAttachedToPlayer[part] = nil
            playerDebrisCount[targetPlayer] = math.max(0, (playerDebrisCount[targetPlayer] or 1) - 1)
            assignedToSatellite[part] = nil
            assignedToVortex[part] = nil
            whitelistedParts[part] = nil
            pickedUpByFunnel[part] = nil
        end
    end
    if playerAttachmentMap[targetPlayer] then
        if playerAttachmentMap[targetPlayer].Parent then playerAttachmentMap[targetPlayer]:Destroy() end
        playerAttachmentMap[targetPlayer] = nil
    end
end

-- ========== Tornado physical forces ==========
local function applyTornadoFriendly(position)
    local parts = Workspace:GetPartBoundsInRadius(position, tornadoWindfield)
    for _, obj in ipairs(parts) do
        if obj:IsA("BasePart") and not obj.Anchored and not isPlayerPart(obj) and obj.Name ~= baseplateName then
            processPartForFunnel(obj)
            if whitelistedParts[obj] and not assignedToSatellite[obj] and not assignedToVortex[obj] then
                local offset = obj.Position - position
                local horizontalOffset = Vector3.new(offset.X, 0, offset.Z)
                local distance = horizontalOffset.Magnitude
                local dirToCenter = distance > 0 and horizontalOffset.Unit or Vector3.zero
                local spinDir = Vector3.new(-dirToCenter.Z, 0, dirToCenter.X)

                local inwardPull = (distance > 0) and (-dirToCenter * tornadoInwardPullSpeed) or Vector3.zero
                local upward = Vector3.new(0, tornadoUpwardSpeed, 0)
                local rotational = spinDir * tornadoSpinSpeed

                obj.CanCollide = false
                obj.AssemblyLinearVelocity = rotational + inwardPull + upward

                if obj.Position.Y >= (position.Y + maxTornadoHeight) then
                    lowerPartToGround(obj)
                end
            end
        end
    end
end

local function applyTornadoNightmare(position)
    local parts = Workspace:GetPartBoundsInRadius(position, tornadoWindfield)
    for _, obj in ipairs(parts) do
        if obj:IsA("BasePart") and not obj.Anchored and not isPlayerPart(obj) and obj.Name ~= baseplateName then
            processPartForFunnel(obj)
            if whitelistedParts[obj] and not assignedToSatellite[obj] and not assignedToVortex[obj] then
                local offset = obj.Position - position
                local horizontalOffset = Vector3.new(offset.X, 0, offset.Z)
                local distance = horizontalOffset.Magnitude
                local dirToCenter = distance > 0 and horizontalOffset.Unit or Vector3.zero
                local spinDir = Vector3.new(-dirToCenter.Z, 0, dirToCenter.X)

                local inwardPull = (distance > 0) and (-dirToCenter * (tornadoInwardPullSpeed * 1.1)) or Vector3.zero
                local upward = Vector3.new(0, tornadoUpwardSpeed * 1.0, 0)
                local rotational = spinDir * (tornadoSpinSpeed * 1.2)

                obj.CanCollide = false
                obj.AssemblyLinearVelocity = rotational + inwardPull + upward

                if obj.Position.Y >= (position.Y + maxTornadoHeight) then
                    lowerPartToGround(obj)
                end
            end
        end
    end
end

local function tornadoLoop()
    while enabled do
        local root = localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart")
        if root then
            tornadoPosition = root.Position
            if nightmareMode then applyTornadoNightmare(tornadoPosition) else applyTornadoFriendly(tornadoPosition) end
        end
        task.wait(0.1)
    end
end

-- ========== Player windfield targeting & multi-attack triggers ==========
local function startFiringAtPlayer(targetPlayer)
    -- Only start firing threads in NIGHTMARE mode
    if not nightmareMode then return end
    if playerTargetThreads[targetPlayer] then return end
    playerTargetThreads[targetPlayer] = true
    spawn(function()
        while playerTargetThreads[targetPlayer] and targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") do
            local hrp = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
            if not hrp or not tornadoPosition then break end
            local dist = (hrp.Position - tornadoPosition).Magnitude
            if dist > tornadoWindfield then break end

            local candidate = nil
            for part in pairs(whitelistedParts) do
                if part and part.Parent and not debrisAttachedToPlayer[part] and not assignedToSatellite[part] and not assignedToVortex[part] then
                    candidate = part
                    break
                end
            end

            if candidate then attachDebrisToPlayer(candidate, targetPlayer) end

            local waitFor = 3
            for i=1, waitFor*10 do
                if not playerTargetThreads[targetPlayer] then break end
                task.wait(0.1)
            end
        end
        cleanupDebrisForPlayer(targetPlayer)
        playerTargetThreads[targetPlayer] = nil
    end)
end

stopFiringAtPlayer = function(targetPlayer)
    playerTargetThreads[targetPlayer] = nil
    cleanupDebrisForPlayer(targetPlayer)
end

local function windfieldWatcher()
    local thresholdDist = tornadoWindfield * (1/3) -- when player penetrates 1/3 of windfield radius
    while true do
        if tornadoPosition then
            for _, plr in ipairs(Players:GetPlayers()) do
                if plr ~= localPlayer and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
                    local hrp = plr.Character.HumanoidRootPart
                    local dist = (hrp.Position - tornadoPosition).Magnitude

                    -- detect crossing inward past threshold
                    local prev = playerPrevDist[plr] or math.huge
                    if prev > thresholdDist and dist <= thresholdDist then
                        -- player has passed inward into the 1/3 threshold
                        if nightmareMode then
                            -- spawn a main horizontal vortex and multi-attack the player sequentially
                            local angle = math.random() * math.pi * 2
                            local rad = math.random(horizontalVortexRadiusMin, horizontalVortexRadiusMax)
                            local pos = tornadoPosition + Vector3.new(math.cos(angle) * rad, 8 + math.random()*4, math.sin(angle) * rad)
                            local hvId = spawnHorizontalVortex(pos, "main", nil)
                            if hvId then
                                local hv = horizontalVortices[hvId]
                                spawn(function()
                                    if not hv then return end
                                    while hv and (tick() - hv.created) <= horizontalVortexLifetime do
                                        local sent = false
                                        for part, _ in pairs(hv.parts) do
                                            if part and part.Parent and not debrisAttachedToPlayer[part] and not part.Anchored then
                                                hv.parts[part] = nil
                                                assignedToVortex[part] = nil
                                                if not part.Anchored and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
                                                    local dir = (plr.Character.HumanoidRootPart.Position - part.Position)
                                                    local unit = dir.Unit
                                                    part.AssemblyLinearVelocity = unit * 140 + Vector3.new(0, 40, 0)
                                                    task.wait(0.15)
                                                    attachDebrisToPlayer(part, plr)
                                                end
                                                sent = true
                                                break
                                            end
                                        end
                                        if not sent then break end
                                        task.wait(1)
                                    end
                                end)
                            end
                        else
                            -- Friendly: spawn non-attacking player-centered vortex growth if many parts attached
                            if playerDebrisCount[plr] and playerDebrisCount[plr] >= 3 then
                                local count = playerDebrisCount[plr]
                                local center = plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") and plr.Character.HumanoidRootPart.Position or tornadoPosition
                                spawnHorizontalVortex(center, "player", plr, count)
                            end
                        end
                    end

                    -- manage per-player firing threads only in nightmareMode
                    if dist <= tornadoWindfield then
                        if nightmareMode then
                            if not playerTargetThreads[plr] then startFiringAtPlayer(plr) end
                        else
                            if playerTargetThreads[plr] then stopFiringAtPlayer(plr) end
                        end
                    else
                        if playerTargetThreads[plr] then stopFiringAtPlayer(plr) end
                    end

                    playerPrevDist[plr] = dist
                end
            end
        end
        task.wait(1)
    end
end

-- ========== Nightmare launcher fling logic helpers ==========
local function findNearestOtherPlayer(pos)
    local best, bestDist = nil, math.huge
    for _, plr in ipairs(Players:GetPlayers()) do
        if plr ~= localPlayer and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
            local d = (plr.Character.HumanoidRootPart.Position - pos).Magnitude
            if d < bestDist then bestDist = d; best = plr end
        end
    end
    return best, bestDist
end

-- Send front/closest part from a specific horizontal vortex at a player (then attach)
local function sendFrontPartFromVortexToPlayer(vortexId, targetPlayer)
    local v = horizontalVortices[vortexId]
    if not v or not targetPlayer or not targetPlayer.Character then return false end
    local targetHRP = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not targetHRP then return false end

    -- find front-most (closest to target) part
    local bestPart, bestDist = nil, math.huge
    for part, _ in pairs(v.parts) do
        if part and part.Parent and not part.Anchored and not debrisAttachedToPlayer[part] then
            local d = (part.Position - targetHRP.Position).Magnitude
            if d < bestDist then bestDist = d; bestPart = part end
        end
    end

    if not bestPart then return false end

    -- remove from vortex bookkeeping
    v.parts[bestPart] = nil
    assignedToVortex[bestPart] = nil

    -- fling toward player then attach
    local dir = (targetHRP.Position - bestPart.Position)
    if dir.Magnitude > 0 then
        local unit = dir.Unit
        bestPart.AssemblyLinearVelocity = unit * 140 + Vector3.new(0, 40, 0)
    else
        bestPart.AssemblyLinearVelocity = Vector3.new(0, 140, 0)
    end
    task.wait(0.15)
    attachDebrisToPlayer(bestPart, targetPlayer)
    return true
end

-- fling helper that finds a vortex owned by a satellite and sends a part; returns true if sent
local function satelliteSendPartToPlayer(satId, targetPlayer)
    for id, v in pairs(horizontalVortices) do
        if v.ownerType == "satellite" and v.ownerId == satId then
            -- try to send front part
            local sent = sendFrontPartFromVortexToPlayer(id, targetPlayer)
            if sent then return true end
        end
    end
    return false
end

local function nightmareLauncherLoop()
    while true do
        if enabled and nightmareMode and tornadoPosition then
            local pool = {}
            for part in pairs(whitelistedParts) do
                if part and part.Parent and not debrisAttachedToPlayer[part] and not assignedToSatellite[part] and not assignedToVortex[part] and not part.Anchored then
                    table.insert(pool, part)
                end
            end
            if #pool > 0 then
                local part = pool[math.random(1, #pool)]
                local targetPlr, d = findNearestOtherPlayer(part.Position)
                if targetPlr and targetPlr.Character and targetPlr.Character:FindFirstChild("HumanoidRootPart") then
                    local dir = (targetPlr.Character.HumanoidRootPart.Position - part.Position)
                    local unit = dir.Unit
                    local launchSpeed = 300 + math.random(0,200)
                    if not part.Anchored then part.AssemblyLinearVelocity = unit * launchSpeed + Vector3.new(0, 50, 0) end
                end
            end
        end
        task.wait(4 + math.random())
    end
end

-- ========== Satellite creation / lifecycle ==========
function spawnSatelliteAt(pos, idOverride)
    local id = idOverride or nextSatelliteId
    if not idOverride then nextSatelliteId = nextSatelliteId + 1 end

    local parts = claimPartsForSatellite(maxPartsPerSatellite)
    local partsMap = {}
    for i, p in ipairs(parts) do
        if p and p.Parent then
            partsMap[p] = {
                radius = satelliteOrbitRadius + math.random(-3, 6),
                speed = satelliteRotationSpeed + math.random() * 1.5,
                phase = math.random() * math.pi * 2
            }
            assignedToSatellite[p] = id
        end
    end

    satelliteVortices[id] = {
        id = id,
        pos = pos,
        angleOffset = math.random() * math.pi * 2,
        parts = partsMap,
        target = nil,
        verticalChains = {},
        lastVortexSpawnTick = tick()
    }
    satelliteAttackState[id] = {attackingPlayers = {}, attackThreads = {}}
    return id
end

function despawnSatellite(id)
    local sat = satelliteVortices[id]
    if not sat then return end
    for part, _ in pairs(sat.parts) do
        if part and part.Parent then
            assignedToSatellite[part] = nil
            assignedToVortex[part] = nil
            whitelistedParts[part] = true
            pickedUpByFunnel[part] = true
            for _, c in ipairs(part:GetChildren()) do
                if c:IsA("AlignPosition") or c:IsA("Attachment") or c:IsA("Torque") then c:Destroy() end
            end
            part.CanCollide = true
        end
    end
    satelliteVortices[id] = nil
    satelliteAttackState[id] = nil
end

-- vertical chain builder (only makes sense in NIGHTMARE)
local function spawnVerticalChain(sat, targetPlayer)
    if not sat or not targetPlayer or not targetPlayer.Character then return end
    if not nightmareMode then return end
    local needed = math.random(verticalChainMinParts, verticalChainMaxParts)
    local chainParts = {}

    for part, _ in pairs(sat.parts) do
        if #chainParts >= needed then break end
        if part and part.Parent and not debrisAttachedToPlayer[part] and not part.Anchored then
            table.insert(chainParts, part)
            assignedToSatellite[part] = sat.id
            sat.parts[part] = sat.parts[part] or {
                radius = satelliteOrbitRadius + math.random(-3, 6),
                speed = satelliteRotationSpeed + math.random() * 1.5,
                phase = math.random() * math.pi * 2
            }
        end
    end

    for part in pairs(whitelistedParts) do
        if #chainParts >= needed then break end
        if part and part.Parent and not debrisAttachedToPlayer[part] and not part.Anchored then
            table.insert(chainParts, part)
            assignedToSatellite[part] = sat.id
            whitelistedParts[part] = nil
            pickedUpByFunnel[part] = nil
            sat.parts[part] = {
                radius = satelliteOrbitRadius + math.random(-3, 6),
                speed = satelliteRotationSpeed + math.random() * 1.5,
                phase = math.random() * math.pi * 2
            }
        end
    end

    if #chainParts == 0 then return end

    local chain = {
        parts = chainParts,
        target = targetPlayer,
        progress = 0,
        speed = verticalChainSpeed * (0.8 + math.random()*0.8),
        amplitude = verticalChainAmplitude * (0.6 + math.random()*0.8),
        frequency = verticalChainFrequency * (0.8 + math.random()*0.8),
        segmentDelay = verticalChainSegmentDelay,
        ownerSatellite = sat.id,
        created = tick()
    }

    table.insert(sat.verticalChains, chain)
end

-- ========== Horizontal vortices (restored & enhanced) ==========
local function spawnHorizontalVortex(centerPos, ownerType, ownerId, preferredPartsCount)
    -- ownerType = "main" or "satellite" or "player"
    local id = nextHorizontalVortexId
    nextHorizontalVortexId = nextHorizontalVortexId + 1

    -- decide how many parts to claim
    local preferredParts = nil
    if ownerType == "satellite" and ownerId and satelliteVortices[ownerId] then
        -- prefer satellite-owned parts
        preferredParts = {}
        for part, _ in pairs(satelliteVortices[ownerId].parts) do table.insert(preferredParts, part) end
    elseif ownerType == "player" and ownerId then
        -- prefer parts attached to that player
        preferredParts = {}
        for part, pl in pairs(debrisAttachedToPlayer) do
            if pl == ownerId then table.insert(preferredParts, part) end
        end
    end

    local partsToClaim = horizontalVortexPartsPerVortex
    if ownerType == "satellite" and ownerId and satelliteVortices[ownerId] then
        local satCount = 0
        for _ in pairs(satelliteVortices[ownerId].parts) do satCount = satCount + 1 end
        partsToClaim = math.max(1, math.floor(satCount / 3)) -- use 1/3rd of the satellite's parts
    elseif ownerType == "player" then
        partsToClaim = math.max(2, (preferredPartsCount or #preferredParts)) -- grow bigger if centered on player
    end

    local partsList = claimPartsForHorizontal(partsToClaim, preferredParts)
    if #partsList == 0 then
        -- nothing to build the vortex with â€” return nil so callers know
        return nil
    end

    local partsMap = {}
    local wiggleBase = math.random(2,6)
    for i, p in ipairs(partsList) do
        if p and p.Parent then
            partsMap[p] = {
                phase = math.random() * math.pi * 2,
                radius = math.random(horizontalVortexRadiusMin, horizontalVortexRadiusMax) * (0.5 + math.random()*0.8),
                speed = math.random(horizontalVortexSpeedMin, horizontalVortexSpeedMax),
                ownerType = ownerType,
                ownerId = ownerId,
                wiggleAmp = wiggleBase * (1 + (i / math.max(1, #partsList)))
            }
            assignedToVortex[p] = id
        end
    end

    horizontalVortices[id] = {
        id = id,
        center = centerPos,
        parts = partsMap,
        created = tick(),
        ownerType = ownerType,
        ownerId = ownerId
    }

    return id
end

local function despawnHorizontalVortex(id)
    local v = horizontalVortices[id]
    if not v then return end
    for part, _ in pairs(v.parts) do
        if part and part.Parent then
            assignedToVortex[part] = nil
            assignedToSatellite[part] = nil
            whitelistedParts[part] = true
            pickedUpByFunnel[part] = true
            for _, c in ipairs(part:GetChildren()) do
                if c:IsA("AlignPosition") or c:IsA("Attachment") or c:IsA("Torque") then c:Destroy() end
            end
            part.CanCollide = true
        end
    end
    horizontalVortices[id] = nil
end

-- horizontal vortex updater: moves parts in an orbit with wiggle; in nightmare it can stretch & attack (but attack is done by flinging front part)
local function updateHorizontalVortices(delta)
    if not tornadoPosition then return end

    -- collect ids to despawn (avoid mutating table while iterating)
    local toDespawn = {}
    for id, v in pairs(horizontalVortices) do
        if tick() - v.created >= horizontalVortexLifetime then
            table.insert(toDespawn, id)
        end
    end
    for _, id in ipairs(toDespawn) do despawnHorizontalVortex(id) end

    for id, v in pairs(horizontalVortices) do
        if not v then goto continue end

        -- update center if owned by satellite (follow it) or player
        if v.ownerType == "satellite" and v.ownerId and satelliteVortices[v.ownerId] then
            v.center = satelliteVortices[v.ownerId].pos
        elseif v.ownerType == "player" and v.ownerId and v.ownerId.Character and v.ownerId.Character:FindFirstChild("HumanoidRootPart") then
            v.center = v.ownerId.Character.HumanoidRootPart.Position
            -- optionally grow radius based on how many parts that player has attached
            local count = playerDebrisCount[v.ownerId] or 0
            for part, meta in pairs(v.parts) do
                meta.radius = meta.radius + (count * 0.8)
            end
        end

        -- determine possible stretch targets (only in nightmare)
        local playersToStretch = {}
        if nightmareMode then
            for _, plr in ipairs(Players:GetPlayers()) do
                if plr ~= localPlayer and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
                    local hrp = plr.Character.HumanoidRootPart
                    local dToTornado = (hrp.Position - tornadoPosition).Magnitude
                    if dToTornado <= horizontalVortexDetectRadius then
                        table.insert(playersToStretch, plr)
                    end
                end
            end
        end

        local stretchTarget = nil
        local bestD = math.huge
        for _, pl in ipairs(playersToStretch) do
            local hrp = pl.Character and pl.Character:FindFirstChild("HumanoidRootPart")
            if hrp then
                local d = (hrp.Position - v.center).Magnitude
                if d < bestD then bestD = d; stretchTarget = pl end
            end
        end

        -- update each part, adding wiggle patterns (sideways and up/down)
        for part, meta in pairs(v.parts) do
            if part and part.Parent then
                local angle = (tick() * (meta.speed / 50)) + meta.phase
                local orbitR = meta.radius
                -- base orbit
                local basePos = v.center + Vector3.new(math.cos(angle) * orbitR, 0, math.sin(angle) * orbitR) + Vector3.new(0, 8, 0)

                -- wiggle offsets (sideways + vertical)
                local sideWiggle = math.sin(tick() * (meta.speed/60) + meta.phase) * (meta.wiggleAmp * 0.6)
                local vertWiggle = math.sin(tick() * (meta.speed/40) + meta.phase*1.23) * (meta.wiggleAmp * 0.4)

                local finalPos = basePos + Vector3.new(sideWiggle * math.cos(angle + meta.phase), vertWiggle, sideWiggle * math.sin(angle + meta.phase))

                -- if in nightmare and we have a stretch target, bias toward that player (visual stretch only)
                if stretchTarget and v.ownerType ~= "player" then
                    local targetHRP = stretchTarget.Character and stretchTarget.Character:FindFirstChild("HumanoidRootPart")
                    if targetHRP then
                        local dir = (targetHRP.Position - v.center)
                        local horiz = Vector3.new(dir.X, 0, dir.Z)
                        if horiz.Magnitude > 0.1 then
                            local distToTornado = (targetHRP.Position - tornadoPosition).Magnitude
                            local extFactor = math.clamp(1 - (distToTornado / horizontalVortexDetectRadius), 0, 1)
                            local extendAmount = 8 + (meta.radius * 0.6) * extFactor
                            local toward = horiz.Unit * (extendAmount)
                            finalPos = v.center + toward + Vector3.new(0, 6 + math.sin(tick() * (meta.speed/60)) * 2, 0)
                            finalPos = finalPos + Vector3.new(math.cos(angle) * (meta.radius * 0.2), 0, math.sin(angle) * (meta.radius * 0.2))
                            -- keep wiggle
                            finalPos = finalPos + Vector3.new(sideWiggle * 0.35, vertWiggle * 0.6, sideWiggle * 0.35)
                        end
                    end
                end

                if not part.Anchored then
                    local vel = (finalPos - part.Position) / math.max(delta, 0.016)
                    part.AssemblyLinearVelocity = Vector3.new(vel.X, math.clamp(vel.Y, -140, 140), vel.Z)
                    part.CanCollide = false
                end

                -- IMPORTANT: in NIGHTMARE, actual attachments should come from explicit flings (sendFrontPartFromVortexToPlayer)
                -- so we DO NOT auto-attach here to preserve the fling behavior.
                -- Friendly mode still never attaches.

                -- keep parts from rising too high
                if part.Position.Y >= (tornadoPosition.Y + maxTornadoHeight) then
                    lowerPartToGround(part)
                end
            else
                v.parts[part] = nil
            end
        end

        -- if vortex ran out of parts, despawn
        local count = 0
        for p, _ in pairs(v.parts) do if p and p.Parent then count = count + 1 end end
        if count == 0 then despawnHorizontalVortex(id) end

        ::continue::
    end
end

-- spawn some horizontal vortices for main funnel and satellites periodically
spawn(function()
    local lastTornadoPos = nil
    while true do
        if enabled and tornadoPosition then
            local playersInWindfield = 0
            for _, plr in ipairs(Players:GetPlayers()) do
                if plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
                    local d = (plr.Character.HumanoidRootPart.Position - tornadoPosition).Magnitude
                    if d <= tornadoWindfield then playersInWindfield = playersInWindfield + 1 end
                end
            end

            local movedDistance = 0
            if lastTornadoPos then movedDistance = (tornadoPosition - lastTornadoPos).Magnitude end

            -- main funnel vortices: random when no players; more likely when tornado is moving and players are inside
            local mainCount = 0
            for id, v in pairs(horizontalVortices) do if v.ownerType == "main" then mainCount = mainCount + 1 end end

            local spawnChance = 0.0
            if playersInWindfield == 0 then
                spawnChance = 0.20 -- 20% chance to spawn new main vortices as a natural random occurance
            elseif movedDistance > 2 and playersInWindfield > 0 then
                spawnChance = 0.60 -- more likely to spawn when tornado is traveling and players are present
            else
                spawnChance = 0.30
            end

            if mainCount < horizontalVortexMaxPerMain and math.random() < spawnChance then
                local toSpawn = math.max(1, horizontalVortexMaxPerMain - mainCount)
                for i = 1, toSpawn do
                    local angle = math.random() * math.pi * 2
                    local rad = math.random(horizontalVortexRadiusMin, horizontalVortexRadiusMax) * (0.6 + math.random()*0.8)
                    local pos = tornadoPosition + Vector3.new(math.cos(angle) * rad, 8 + math.random()*6, math.sin(angle) * rad)
                    spawnHorizontalVortex(pos, "main", nil)
                end
            end

            -- per-satellite vortices: spawn randomly but do NOT chase players in friendly (they will just orbit)
            for id, sat in pairs(satelliteVortices) do
                local satCount = 0
                for _, v in pairs(horizontalVortices) do if v.ownerType == "satellite" and v.ownerId == id then satCount = satCount + 1 end end
                if satCount < horizontalVortexMaxPerSatellite then
                    if math.random() < (playersInWindfield == 0 and 0.15 or 0.45) then
                        local toSpawn = horizontalVortexMaxPerSatellite - satCount
                        for i = 1, toSpawn do
                            local ang = math.random() * math.pi * 2
                            local r = math.random(horizontalVortexRadiusMin * 0.3, horizontalVortexRadiusMin * 0.8)
                            local pos = sat.pos + Vector3.new(math.cos(ang) * r, 6 + math.random()*4, math.sin(ang) * r)
                            spawnHorizontalVortex(pos, "satellite", id)
                        end
                    end
                end
            end

            -- growth from attached-player debris: horizontal vortices can spawn around players who already have debris attached
            for pl, cnt in pairs(playerDebrisCount) do
                if cnt and cnt >= 2 and pl.Character and pl.Character:FindFirstChild("HumanoidRootPart") then
                    if math.random() < 0.08 then -- small chance to grow from attached debris
                        local center = pl.Character.HumanoidRootPart.Position
                        spawnHorizontalVortex(center, "player", pl, cnt)
                    end
                end
            end

            lastTornadoPos = tornadoPosition
        end
        task.wait(5 + math.random() * 2)
    end
end)

-- ========== Satellites and vertical chain update ==========
local function updateSatellites(delta)
    if not tornadoPosition then return end
    for id, sat in pairs(satelliteVortices) do
        -- update target to nearest player inside windfield (but only used in NIGHTMARE)
        local best, bestDist = nil, math.huge
        if nightmareMode then
            for _, plr in ipairs(Players:GetPlayers()) do
                if plr ~= localPlayer and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
                    local d = (plr.Character.HumanoidRootPart.Position - tornadoPosition).Magnitude
                    if d <= tornadoWindfield and d < bestDist then bestDist = d; best = plr end
                end
            end
            sat.target = best
        else
            sat.target = nil
        end

        -- movement: chase target (nightmare) or orbit main funnel center (friendly remains orbit only)
        local pos = sat.pos
        if nightmareMode and sat.target and sat.target.Character and sat.target.Character:FindFirstChild("HumanoidRootPart") then
            local tgtPos = sat.target.Character.HumanoidRootPart.Position + Vector3.new(0, 8, 0)
            local dir = (tgtPos - pos)
            if dir.Magnitude > 0.2 then
                local move = dir.Unit * math.min(dir.Magnitude, satelliteChaseSpeed * delta)
                sat.pos = pos + Vector3.new(move.X, move.Y, move.Z)
            end
        else
            sat.angleOffset = sat.angleOffset + (0.5 * delta)
            local orbitRad = math.clamp(tornadoWindfield * 0.25, 6, tornadoWindfield * 0.7)
            local newPos = tornadoPosition + Vector3.new(math.cos(sat.angleOffset) * orbitRad, 10, math.sin(sat.angleOffset) * orbitRad)
            local dir = (newPos - pos)
            sat.pos = pos + dir * math.min(1, delta * 1.5)
        end

        -- update parts orbiting satellite (regular sideways orbit)
        for part, meta in pairs(sat.parts) do
            if part and part.Parent then
                local center = sat.pos
                local angle = (tick() * (meta.speed)) + meta.phase
                local targetPos = center + Vector3.new(math.cos(angle) * meta.radius, 0, math.sin(angle) * meta.radius) + Vector3.new(0, 8 + math.sin(tick()+meta.phase)*3, 0)
                if not part.Anchored then
                    local vel = (targetPos - part.Position) / math.max(delta, 0.016)
                    part.AssemblyLinearVelocity = Vector3.new(vel.X, math.clamp(vel.Y, -120, 120), vel.Z)
                    part.CanCollide = false
                end
            else
                sat.parts[part] = nil
            end
        end

        -- spawn vertical chains occasionally (only in nightmare)
        if nightmareMode and sat.target and (tick() - sat.lastVortexSpawnTick) >= (1.5 + math.random()*2.0) then
            sat.lastVortexSpawnTick = tick()
            spawnVerticalChain(sat, sat.target)
        end

        -- vertical chain updates
        for ci = #sat.verticalChains, 1, -1 do
            local chain = sat.verticalChains[ci]
            if not chain or not chain.target or not chain.target.Character then
                table.remove(sat.verticalChains, ci)
            else
                chain.progress = math.min(1.5, chain.progress + chain.speed * delta)
                local targetHRP = chain.target.Character:FindFirstChild("HumanoidRootPart")
                if targetHRP then
                    for idx, part in ipairs(chain.parts) do
                        if part and part.Parent and not part.Anchored then
                            local segT = math.clamp(chain.progress - ((idx - 1) * chain.segmentDelay), 0, 1)
                            local basePos = sat.pos
                            local goalPos = basePos:Lerp(targetHRP.Position + Vector3.new(0, 6, 0), segT)
                            local toTarget = (targetHRP.Position - basePos)
                            local horiz = Vector3.new(toTarget.X, 0, toTarget.Z)
                            local perp = (horiz.Magnitude > 0.1) and Vector3.new(-horiz.Z, 0, horiz.X).Unit or Vector3.new(1,0,0)
                            local wiggle = perp * math.sin((segT * chain.frequency) + idx) * (chain.amplitude * (1 - segT))
                            local finalPos = goalPos + wiggle + Vector3.new(0, segT * 6, 0)
                            local vel = (finalPos - part.Position) / math.max(delta, 0.016)
                            part.AssemblyLinearVelocity = Vector3.new(vel.X, math.clamp(vel.Y, -140, 140), vel.Z)
                            part.CanCollide = false

                            local distToHRP = (part.Position - targetHRP.Position).Magnitude
                            if distToHRP <= verticalAttachDistance then
                                attachDebrisToPlayer(part, chain.target)
                                chain.parts[idx] = nil
                            end
                        else
                            chain.parts[idx] = nil
                        end
                    end

                    -- compress parts
                    local newParts = {}
                    for _, p in ipairs(chain.parts) do if p then table.insert(newParts, p) end end
                    chain.parts = newParts

                    if #chain.parts == 0 or chain.progress >= 1.4 then table.remove(sat.verticalChains, ci) end
                else
                    table.remove(sat.verticalChains, ci)
                end
            end
        end

        -- main orbit attack logic (in nightmare: send front part then next every 1s; in friendly: no attacks)
        local meanRadius = 0
        local countR = 0
        for _, m in pairs(sat.parts) do meanRadius = meanRadius + (m.radius or satelliteOrbitRadius); countR = countR + 1 end
        if countR > 0 then meanRadius = meanRadius / countR else meanRadius = satelliteOrbitRadius end

        for _, plr in ipairs(Players:GetPlayers()) do
            if plr ~= localPlayer and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
                local hrp = plr.Character.HumanoidRootPart
                local dToSat = (hrp.Position - sat.pos).Magnitude
                local inOrbit = dToSat <= (meanRadius + 3)
                local state = satelliteAttackState[id]
                if inOrbit and nightmareMode then
                    state.attackingPlayers[plr] = state.attackingPlayers[plr] or true
                    if not state.attackThreads[plr] then
                        state.attackThreads[plr] = true
                        spawn(function()
                            while state.attackingPlayers[plr] do
                                if not plr or not plr.Character or not plr.Character:FindFirstChild("HumanoidRootPart") then break end
                                local curDist = (plr.Character.HumanoidRootPart.Position - sat.pos).Magnitude
                                if curDist > (meanRadius + 6) then break end

                                -- Try to use a horizontal vortex owned by this satellite and send its front part sequentially
                                local sent = satelliteSendPartToPlayer(id, plr)
                                if not sent then
                                    -- fallback: send from satellite orbit parts (claim one and send)
                                    for part, _ in pairs(sat.parts) do
                                        if part and part.Parent and not debrisAttachedToPlayer[part] and not part.Anchored then
                                            sat.parts[part] = nil
                                            assignedToSatellite[part] = nil
                                            if plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
                                                local dir = (plr.Character.HumanoidRootPart.Position - part.Position)
                                                local unit = dir.Unit
                                                part.AssemblyLinearVelocity = unit * 140 + Vector3.new(0, 40, 0)
                                                task.wait(0.15)
                                                attachDebrisToPlayer(part, plr)
                                            end
                                            sent = true
                                            break
                                        end
                                    end
                                end

                                -- if none sent (no parts), attempt to claim one from funnel
                                if not sent then
                                    local extras = claimPartsForSatellite(1)
                                    for _, p in ipairs(extras) do
                                        if p and p.Parent then
                                            sat.parts[p] = {
                                                radius = satelliteOrbitRadius + math.random(-3, 6),
                                                speed = satelliteRotationSpeed + math.random() * 1.5,
                                                phase = math.random() * math.pi * 2
                                            }
                                            assignedToSatellite[p] = id
                                        end
                                    end
                                end

                                -- wait 1 second before sending next part (sequential attack)
                                local waited = 0
                                while waited < 1 do
                                    if not state.attackingPlayers[plr] then break end
                                    task.wait(0.1)
                                    waited = waited + 0.1
                                end
                            end
                            state.attackThreads[plr] = nil
                            state.attackingPlayers[plr] = nil
                        end)
                    end
                else
                    if state then state.attackingPlayers[plr] = nil; state.attackThreads[plr] = nil end
                end
            end
        end

        -- cleanup satellite if no parts remain
        local partCount = 0
        for p, _ in pairs(sat.parts) do if p and p.Parent then partCount = partCount + 1 end end
        if partCount == 0 then despawnSatellite(id) end
    end
end

-- ========== Satellite formation helpers ==========
local function formSatellitesInstant()
    for id, _ in pairs(satelliteVortices) do despawnSatellite(id) end

    local count = math.max(0, maxSubVortices)
    if count == 0 then return end
    if not tornadoPosition then
        local waited = 0
        while not tornadoPosition and waited < 1.0 do
            task.wait(0.05); waited = waited + 0.05
            local root = localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart")
            if root then tornadoPosition = root.Position; break end
        end
        if not tornadoPosition then return end
    end

    local orbitRad = math.clamp(tornadoWindfield * 0.3, 8, tornadoWindfield * 0.7)
    for i = 1, count do
        local angle = (2 * math.pi * (i - 1) / count) + (math.random() * 0.2 - 0.1)
        local pos = tornadoPosition + Vector3.new(math.cos(angle) * orbitRad, 10 + math.random()*6, math.sin(angle) * orbitRad)
        spawnSatelliteAt(pos)
    end
end

-- ========== Workspace scanning & DescendantAdded ==========
Workspace.DescendantAdded:Connect(function(desc)
    if desc and desc:IsA("BasePart") then
        task.defer(function()
            if enabled and tornadoPosition and (desc.Position - tornadoPosition).Magnitude <= tornadoWindfield then
                if not desc.Anchored then processPartForFunnel(desc) end
            end
        end)
    end
end)

spawn(function()
    while true do
        if enabled and tornadoPosition then
            local parts = Workspace:GetPartBoundsInRadius(tornadoPosition, tornadoWindfield)
            for _, p in ipairs(parts) do
                if p and p:IsA("BasePart") and not p.Anchored then processPartForFunnel(p) end
            end
        end
        task.wait(1)
    end
end)

-- ========== Heartbeat & loops ==========
RunService.Heartbeat:Connect(function(delta)
    if enabled then
        updateSatellites(delta)
        updateHorizontalVortices(delta)
    end
end)

spawn(windfieldWatcher)
spawn(nightmareLauncherLoop)

-- ========== Robust respawn handling ==========
local function onCharacterAdded(character)
    task.wait(0.1)
    local root = character:WaitForChild("HumanoidRootPart", 2)
    if root then tornadoPosition = root.Position end

    if enabled and tornadoPosition then
        local parts = Workspace:GetPartBoundsInRadius(tornadoPosition, tornadoWindfield)
        for _, p in ipairs(parts) do if p and p:IsA("BasePart") and not p.Anchored then processPartForFunnel(p) end end

        formSatellitesInstant()

        -- ensure horizontal vortices are created around main funnel immediately
        -- clear existing main horizontal vortices first
        for id, v in pairs(horizontalVortices) do
            if v.ownerType == "main" then despawnHorizontalVortex(id) end
        end
        for i = 1, horizontalVortexMaxPerMain do
            local angle = math.random() * math.pi * 2
            local rad = math.random(horizontalVortexRadiusMin, horizontalVortexRadiusMax)
            local pos = tornadoPosition + Vector3.new(math.cos(angle) * rad, 8 + math.random()*4, math.sin(angle) * rad)
            spawnHorizontalVortex(pos, "main", nil)
        end
    end
end

if localPlayer.Character then onCharacterAdded(localPlayer.Character) end
localPlayer.CharacterAdded:Connect(onCharacterAdded)

-- ========== Toggle button logic ==========
local function cleanupAll()
    for part in pairs(whitelistedParts) do
        if part and part:IsA("BasePart") and part.Parent then
            part.AssemblyLinearVelocity = Vector3.zero
            part.CanCollide = true
            for _, child in ipairs(part:GetChildren()) do
                if child:IsA("AlignPosition") or child:IsA("Attachment") or child:IsA("Torque") then child:Destroy() end
            end
        end
    end

    for id, _ in pairs(satelliteVortices) do despawnSatellite(id) end
    for id, _ in pairs(horizontalVortices) do despawnHorizontalVortex(id) end

    for pl, att in pairs(playerAttachmentMap) do if att and att.Parent then att:Destroy() end playerAttachmentMap[pl] = nil end
    for pl, _ in pairs(playerTargetThreads) do playerTargetThreads[pl] = nil end

    debrisAttachedToPlayer = {}
    whitelistedParts = {}
    pickedUpByFunnel = {}
    assignedToSatellite = {}
    assignedToVortex = {}
    satelliteVortices = {}
    satelliteAttackState = {}
    horizontalVortices = {}
    playerDebrisCount = {}
    playerPrevDist = {}
end

cleanupDebrisForPlayer = cleanupDebrisForPlayer -- expose locally

toggleBtn.MouseButton1Click:Connect(function()
    enabled = not enabled
    toggleBtn.Text = enabled and "X" or "O"
    if enabled then
        pickedUpByFunnel = {}
        whitelistedParts = {}
        assignedToSatellite = {}
        assignedToVortex = {}
        satelliteVortices = {}
        satelliteAttackState = {}
        horizontalVortices = {}
        nextSatelliteId = 1
        nextHorizontalVortexId = 1
        debrisAttachedToPlayer = {}
        playerDebrisCount = {}

        spawn(tornadoLoop)
        task.wait(0.05)
        if localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart") then tornadoPosition = localPlayer.Character.HumanoidRootPart.Position end

        if tornadoPosition then
            local parts = Workspace:GetPartBoundsInRadius(tornadoPosition, tornadoWindfield)
            for _, p in ipairs(parts) do if p and p:IsA("BasePart") and not p.Anchored then processPartForFunnel(p) end end
        end

        -- form satellites & horizontal vortices instantly
        formSatellitesInstant()

        -- create main horizontal vortices instantly
        for id, v in pairs(horizontalVortices) do if v.ownerType == "main" then despawnHorizontalVortex(id) end end
        for i = 1, horizontalVortexMaxPerMain do
            local angle = math.random() * math.pi * 2
            local rad = math.random(horizontalVortexRadiusMin, horizontalVortexRadiusMax)
            local pos = tornadoPosition + Vector3.new(math.cos(angle) * rad, 8 + math.random()*4, math.sin(angle) * rad)
            spawnHorizontalVortex(pos, "main", nil)
        end
    else
        cleanupAll()
    end
end)

-- End of script
