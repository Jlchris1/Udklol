-- Full updated script (client)
-- Changes:
--  * Local player is never modified (no attachments parented to character, no noclip changes affecting player)
--  * switchDelay = 0.13 (target selection delay)
--  * BH_SWAP_INTERVAL = 0.01 (swap spam interval, unchanged)
--  * Smoother targeting via exponential smoothing (TARGET_SMOOTHNESS)
--  * ForcePart still uses part center attachments and ignores any player character parts
--  * FRONT offset based on speed (studs -> distance ahead)
--  * Rapid skid (fast lateral / vertical oscillation)
--  * When BHs > players: BHs are distributed across remote players evenly (no BH on local player)
--  * Removed Loop Fix Parts toggle

local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")

local localPlayer = Players.LocalPlayer

-- Utilities
local function clamp(val, a, b)
    if val < a then return a end
    if val > b then return b end
    return val
end

-- Core state
local blackHoleActive = false
local toggleState = false
local targetPlayer = nil
local switchDelay = 0.13 -- seconds between target selection / refresh (user requested)
local processedParts = {} -- set: part -> true
local initiallyAnchoredParts = {}
local anchoredOnce = false
local unanchorTimerRunning = false
local unanchorCoroutine

-- Primary single attachment (kept in workspace folder, NOT parented to local player)
local Attachment1 = nil

-- Manager for extra black holes created by commands (table of {Part, Attachment, AssignedParts, TargetPlayer, LastTarget, _running, _active})
local extraBlackHoles = {}

-- PAA mode state
local PAAEnabled = false
local PAA_isUsingSelected = false -- when true, PAA uses selected players
local paaConnections = {}

-- Rebalancer state
local rebalancerRunning = false
local rebalancerFreq = 0.10 -- seconds between rebalances; lower = faster redistribution (tweakable)
local alignResponsiveness = 1500 -- high = snappy; tweak if physics break

-- BH motion tuning (tweakable)
local BH_SWAP_INTERVAL = 0.01         -- seconds per swap (fast back-and-forth spam)
local BH_OSC_FREQUENCY = 1 / (BH_SWAP_INTERVAL * 2) -- frequency derived from swap interval
local BH_AMPLITUDE_FACTOR = 0.22     -- amplitude multiplier applied to speed to compute displacement
local BH_MIN_AMPLITUDE = 0.6        -- small jitter even when standing still
local BH_MAX_AMPLITUDE = 80         -- upper clamp for amplitude (studs)

-- Front-distance (how many studs ahead based on speed)
local FRONT_MULTIPLIER = 0.54 -- 24 * 0.54 ≈ 13.0 studs (example you gave)
local FRONT_MIN = 0.6
local FRONT_MAX = 80

-- Skid tuning (rapid lateral/vertical wobble)
local SKID_FACTOR = 6.0 -- multiply base frequency for fast skid oscillation
local SKID_LATERAL_SCALE = 0.35
local SKID_VERTICAL_SCALE = 0.5

-- Target smoothing (higher => smoother, lower => more immediate)
local TARGET_SMOOTHNESS = 6.0

-- Setup initial Attachment placed under a workspace folder (not parented to player)
local function setupPlayer()
    local Folder = Workspace:FindFirstChild("ÆS_BlackHole_Folder")
    if not Folder then
        Folder = Instance.new("Folder", Workspace)
        Folder.Name = "ÆS_BlackHole_Folder"
    end
    -- keep a single invisible part for the default attachment
    local existing = Folder:FindFirstChild("BH_Center_Part")
    if existing and existing:IsA("BasePart") then
        local att = existing:FindFirstChildOfClass("Attachment")
        if att then return att end
        local newAtt = Instance.new("Attachment", existing)
        return newAtt
    end
    local Part = Instance.new("Part", Folder)
    Part.Name = "BH_Center_Part"
    Part.Anchored = true
    Part.CanCollide = false
    Part.Transparency = 1
    Part.Size = Vector3.new(1,1,1)
    local Attachment = Instance.new("Attachment", Part)
    return Attachment
end

Attachment1 = setupPlayer()

-- Detect if a character is an NPC (has Humanoid but not a player character)
local function isNPC(character)
    if not character or not character:IsA("Model") then return false end
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if humanoid and not Players:GetPlayerFromCharacter(character) then
        return true
    end
    return false
end

-- Ensure we don't affect any player's character parts (local or remote players)
local function isPartPlayerCharacter(part)
    if not part then return false end
    for _, pl in ipairs(Players:GetPlayers()) do
        local char = pl.Character
        if char and part:IsDescendantOf(char) then
            return true
        end
    end
    return false
end

-- ===== NOTE: We deliberately make noclip a no-op so local player's movement is never modified =====
local function enableLocalPlayerNoclip(enable)
    -- no-op: do not alter local player's parts or collisions; avoids breaking walking
    return
end

-- helper to remove any existing physics bodyobjects from a part
local function stripBodyForces(part)
    for _, x in next, part:GetChildren() do
        if x:IsA("BodyAngularVelocity") or x:IsA("BodyForce") or x:IsA("BodyGyro")
        or x:IsA("BodyPosition") or x:IsA("BodyThrust") or x:IsA("BodyVelocity")
        or x:IsA("RocketPropulsion") then
            x:Destroy()
        end
    end
    if part:FindFirstChild("Attachment") then part:FindFirstChild("Attachment"):Destroy() end
    if part:FindFirstChild("AlignPosition") then part:FindFirstChild("AlignPosition"):Destroy() end
    if part:FindFirstChild("Torque") then part:FindFirstChild("Torque"):Destroy() end
end

-- Utility: shuffle table in place
local function shuffle(t)
    for i = #t, 2, -1 do
        local j = math.random(1, i)
        t[i], t[j] = t[j], t[i]
    end
end

-- Choose the extra black hole with fewest assigned parts (for immediate balanced assignment)
local function getLeastLoadedBlackHole()
    if #extraBlackHoles == 0 then return nil end
    table.sort(extraBlackHoles, function(a,b) return (#a.AssignedParts) < (#b.AssignedParts) end)
    return extraBlackHoles[1]
end

-- Return array of players excluding local player. Always returns current players even without characters.
local function getAllNonLocalPlayers()
    local res = {}
    for _, p in ipairs(Players:GetPlayers()) do
        if p ~= localPlayer then
            table.insert(res, p)
        end
    end
    return res
end

-- Exponential smoothing for CFrame lerp (smoother targeting)
local function smoothLerpCFrame(curCF, targetCF, dt)
    -- alpha = 1 - exp(-k * dt). k = TARGET_SMOOTHNESS
    local alpha = 1 - math.exp(-TARGET_SMOOTHNESS * dt)
    if alpha < 0.001 then alpha = 0.001 end
    if alpha > 1 then alpha = 1 end
    return curCF:Lerp(targetCF, alpha)
end

-- ForcePart now assigns to extra black holes (if any). Also prevents affecting player characters.
local function ForcePart(v)
    if not v or not v:IsA("BasePart") then return end
    -- safety checks: skip ANY player's character parts (local or remote)
    if isPartPlayerCharacter(v) then return end
    -- also skip anything parented to local player's character explicitly
    if localPlayer.Character and v:IsDescendantOf(localPlayer.Character) then return end

    if v:IsA("BasePart")
        and not v.Anchored
        and v.Name ~= "Handle"
        and (
            (v.Parent:FindFirstChildOfClass("Humanoid") and isNPC(v.Parent))
            or (not v.Parent:FindFirstChildOfClass("Humanoid") and not v.Parent:FindFirstChild("Head"))
        ) then

        if processedParts[v] then return end
        processedParts[v] = true

        stripBodyForces(v)

        -- ensure picked up parts have collisions off (unless deactivated later)
        v.CanCollide = false

        -- torque + alignposition
        local Torque = Instance.new("Torque", v)
        Torque.Torque = Vector3.new(1e6, 1e6, 1e6)
        local AlignPosition = Instance.new("AlignPosition", v)
        local Attachment2 = Instance.new("Attachment", v)
        -- place attachment at the part's world center to avoid grabbing edges (mesh offsets)
        pcall(function()
            Attachment2.WorldCFrame = v.CFrame
        end)
        Torque.Attachment0 = Attachment2

        -- make align fast & snappy for rapid switching
        AlignPosition.MaxForce = 1e9
        AlignPosition.MaxVelocity = math.huge
        AlignPosition.Responsiveness = alignResponsiveness
        AlignPosition.Attachment0 = Attachment2

        -- assign immediate target: least loaded BH if exists else primary Attachment1
        local bh = getLeastLoadedBlackHole()
        if bh and bh.Attachment and bh._active then
            AlignPosition.Attachment1 = bh.Attachment
            table.insert(bh.AssignedParts, v)
        else
            AlignPosition.Attachment1 = Attachment1
        end
    end
end

local function clearProcessedParts()
    for part, _ in pairs(processedParts) do
        if part and part.Parent then
            stripBodyForces(part)
            part.CanCollide = true
            if not initiallyAnchoredParts[part] then
                part.Anchored = false
            else
                part.Anchored = true
            end
        end
    end
    processedParts = {}
    initiallyAnchoredParts = {}
    anchoredOnce = false
end

-- Unfreeze cooldown changed to 1 second
local function anchorAndDelayedUnanchorParts()
    unanchorTimerRunning = true

    local candidateParts = {}
    for _, v in ipairs(Workspace:GetDescendants()) do
        -- IMPORTANT: exclude ANY player's character parts here too
        if v:IsA("BasePart")
            and not v.Anchored
            and v.Name ~= "Handle"
            and not isPartPlayerCharacter(v)
            and not (localPlayer.Character and v:IsDescendantOf(localPlayer.Character))
            and (
                (v.Parent:FindFirstChildOfClass("Humanoid") and isNPC(v.Parent))
                or (not v.Parent:FindFirstChildOfClass("Humanoid") and not v.Parent:FindFirstChild("Head"))
            ) then
            table.insert(candidateParts, v)
        end
    end

    initiallyAnchoredParts = {}
    for _, part in ipairs(candidateParts) do
        initiallyAnchoredParts[part] = false
        part.Anchored = true
        part.CanCollide = false
    end

    -- Enable collisions for NPC characters (not players)
    for _, npcCandidate in ipairs(Workspace:GetChildren()) do
        if isNPC(npcCandidate) then
            for _, p in ipairs(npcCandidate:GetDescendants()) do
                if p:IsA("BasePart") then
                    p.CanCollide = true
                end
            end
        end
    end

    -- NOTE: do NOT change local player's collisions or noclip.

    local startTime = tick()
    while blackHoleActive and tick() - startTime < 1 do
        wait(0.05)
    end

    -- After cooldown unanchor candidate parts and apply ForcePart
    for _, part in ipairs(candidateParts) do
        if part and part.Parent and initiallyAnchoredParts[part] == false then
            part.Anchored = false
            ForcePart(part)
        end
    end

    unanchorTimerRunning = false
    anchoredOnce = true
end

local descendantAddedConn

local function processWorkspaceParts()
    if descendantAddedConn then
        descendantAddedConn:Disconnect()
        descendantAddedConn = nil
    end

    if blackHoleActive then
        if not unanchorTimerRunning and not anchoredOnce then
            unanchorCoroutine = coroutine.create(anchorAndDelayedUnanchorParts)
            coroutine.resume(unanchorCoroutine)
        end

        descendantAddedConn = Workspace.DescendantAdded:Connect(function(v)
            if blackHoleActive then
                -- ensure we don't attach to player character parts that spawn
                if v:IsA("BasePart")
                    and not v.Anchored
                    and not processedParts[v]
                    and not isPartPlayerCharacter(v)
                    and not (localPlayer.Character and v:IsDescendantOf(localPlayer.Character)) then
                    ForcePart(v)
                end
            end
        end)
    end
end

local function getRandomPlayer()
    local players = getAllNonLocalPlayers()
    if #players == 0 then return nil end
    return players[math.random(1, #players)]
end

local function getSelectedPlayers()
    local res = {}
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= localPlayer and player:FindFirstChild("Selected") and player.Selected.Value then
            table.insert(res, player)
        end
    end
    return res
end

-- Helper: sets a BH active/inactive (deactivate means stop effects but keep object)
local function setBlackHoleActiveState(bh, active)
    if not bh then return end
    if bh._active == active then return end
    bh._active = active
    if not active then
        -- when deactivated: re-enable collisions on assigned parts and clear their attachments gently
        for _, p in ipairs(bh.AssignedParts) do
            if p and p.Parent then
                p.CanCollide = true
                local ap = p:FindFirstChildOfClass("AlignPosition")
                if ap then
                    ap.Attachment1 = Attachment1
                end
            end
        end
    else
        -- when re-activated: ensure assigned parts are set back to this BH's attachment
        for _, p in ipairs(bh.AssignedParts) do
            if p and p.Parent then
                local ap = p:FindFirstChildOfClass("AlignPosition")
                if ap then
                    ap.Attachment1 = bh.Attachment
                    p.CanCollide = false
                end
            end
        end
    end
end

-- Helper: create an extra black hole (part + attachment) and start its loop
local function createExtraBlackHole(initialTarget)
    -- ensure initialTarget is never the local player
    if initialTarget == localPlayer then initialTarget = nil end

    local folder = Workspace:FindFirstChild("ÆS_BlackHole_Folder") or Instance.new("Folder", Workspace)
    folder.Name = "ÆS_BlackHole_Folder"
    local part = Instance.new("Part", folder)
    part.Anchored = true
    part.CanCollide = false
    part.Transparency = 1
    part.Size = Vector3.new(1,1,1)
    part.Name = "ExtraBH_Center"

    local att = Instance.new("Attachment", part)

    local bh = {
        Part = part,
        Attachment = att,
        AssignedParts = {},
        TargetPlayer = initialTarget,
        LastTarget = nil,
        _running = true,
        _active = true -- active by default
    }

    -- small helper to check if a player is "disabled" by design (BoolValue named "Disabled")
    local function isPlayerDisabled(pl)
        if not pl then return false end
        if pl:FindFirstChild("Disabled") and typeof(pl.Disabled.Value) == "boolean" then
            return pl.Disabled.Value
        end
        return false
    end

    -- spawn loop: update position to target's HRP if exists
    bh._thread = spawn(function()
        local t = 0
        while bh._running do
            local dt = RunService.Heartbeat:Wait()
            t = t + dt

            if bh.TargetPlayer and bh.TargetPlayer ~= localPlayer then
                -- If player flagged disabled, deactivate BH (but keep it around)
                if isPlayerDisabled(bh.TargetPlayer) then
                    setBlackHoleActiveState(bh, false)
                else
                    setBlackHoleActiveState(bh, true)
                    local char = bh.TargetPlayer.Character
                    if char and char:FindFirstChild("HumanoidRootPart") then
                        local hrp = char.HumanoidRootPart

                        -- Compute velocity-based offsets
                        local vel = hrp.Velocity or Vector3.new(0,0,0)
                        local speed = vel.Magnitude
                        local dir
                        if speed > 0.5 then
                            dir = vel.Unit
                        else
                            dir = (hrp.CFrame.LookVector + hrp.CFrame.UpVector * 0.3).Unit
                        end

                        -- front distance based on speed (example: 24 * FRONT_MULTIPLIER ≈ 13)
                        local frontDist = clamp(speed * FRONT_MULTIPLIER, FRONT_MIN, FRONT_MAX)

                        -- amplitude-based oscillation for skid/wobble
                        local amplitude = clamp(speed * BH_AMPLITUDE_FACTOR, BH_MIN_AMPLITUDE, BH_MAX_AMPLITUDE)
                        local phase = t * (2 * math.pi * BH_OSC_FREQUENCY)

                        -- fast skid phase for rapid lateral/up-down jitter
                        local skidPhase = t * (2 * math.pi * BH_OSC_FREQUENCY * SKID_FACTOR)

                        -- primary is now base forward distance plus sinusoidal forward/back jitter
                        local forwardJitter = math.sin(phase) * amplitude
                        local primaryOffset = dir * (frontDist + forwardJitter)

                        -- vertical & lateral skid using faster frequency
                        local verticalOffset = hrp.CFrame.UpVector * (math.sin(skidPhase * 1.0) * amplitude * SKID_VERTICAL_SCALE)
                        local lateralOffset = hrp.CFrame.RightVector * (math.sin(skidPhase * 1.27) * amplitude * SKID_LATERAL_SCALE)

                        local targetCFrame = hrp.CFrame * CFrame.new(primaryOffset + lateralOffset + verticalOffset)

                        -- Smoothly move BH attachment towards computed CFrame (smoother targeting)
                        if att then
                            local success, cur = pcall(function() return att.WorldCFrame end)
                            local curCF = success and cur or att.WorldCFrame or part.CFrame
                            att.WorldCFrame = smoothLerpCFrame(curCF, targetCFrame, dt)
                        end
                    end
                end
            else
                -- roam near local player when no target assigned (pure roam, does not modify local player)
                if localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart") then
                    local hrp = localPlayer.Character.HumanoidRootPart
                    local phase = t * (BH_OSC_FREQUENCY * 0.45)
                    local roamOffset = Vector3.new(math.sin(phase*1.11)*4, math.sin(phase*1.3)*1.6, math.cos(phase*0.9)*4)
                    if att then
                        local success, cur = pcall(function() return att.WorldCFrame end)
                        local curCF = success and cur or att.WorldCFrame or part.CFrame
                        local targetCF = hrp.CFrame * CFrame.new(roamOffset + Vector3.new(math.random(-2,2), math.random(-1,1), math.random(-2,2)))
                        att.WorldCFrame = smoothLerpCFrame(curCF, targetCF, dt)
                    end
                end
            end
        end
    end)

    table.insert(extraBlackHoles, bh)
    return bh
end

local function destroyExtraBlackHole(bh)
    if not bh then return end
    bh._running = false
    if bh.Part and bh.Part.Parent then bh.Part:Destroy() end
    for _, p in ipairs(bh.AssignedParts) do
        if p and p.Parent then
            local ap = p:FindFirstChildOfClass("AlignPosition")
            if ap then
                ap.Attachment1 = Attachment1
            end
            p.CanCollide = false
        end
    end
end

-- Assign unique targets to BHs for PAA but if BHs > players distribute BHs evenly across players.
local function assignUniqueTargetsToBHs()
    if #extraBlackHoles == 0 then return end

    -- gather candidate players (exclude local)
    local players = {}
    if PAA_isUsingSelected then
        players = getSelectedPlayers()
    else
        players = getAllNonLocalPlayers()
    end

    -- if no remote players, leave BHs targetless (they roam)
    if #players == 0 then
        for _, bh in ipairs(extraBlackHoles) do
            bh.LastTarget = bh.TargetPlayer
            bh.TargetPlayer = nil
            bh.AssignedParts = {}
            setBlackHoleActiveState(bh, true)
        end
        return
    end

    local bhCount = #extraBlackHoles
    local playerCount = #players

    -- compute even distribution counts (difference <= 1)
    local base = math.floor(bhCount / playerCount)
    local rem = bhCount - (base * playerCount) -- remainder (0..playerCount-1)

    -- build playerPool list where each player appears base (+1 for first rem players) times
    local playerPool = {}
    for i = 1, playerCount do
        local count = base + (i <= rem and 1 or 0)
        for j = 1, count do
            table.insert(playerPool, players[i])
        end
    end

    -- shuffle pool so distribution doesn't always start with same player
    shuffle(playerPool)

    -- attempt to avoid giving a BH the same LastTarget when possible:
    -- We will assign pool entries to BHs; if pool[i] == bh.LastTarget and there's another pool entry not equal, swap.
    for idx, bh in ipairs(extraBlackHoles) do
        bh.LastTarget = bh.TargetPlayer
    end

    for i, bh in ipairs(extraBlackHoles) do
        local candidate = playerPool[i]
        if candidate == bh.LastTarget then
            -- try to find alternative in remainder of pool
            local swapped = false
            for j = i+1, #playerPool do
                if playerPool[j] ~= bh.LastTarget then
                    playerPool[i], playerPool[j] = playerPool[j], playerPool[i]
                    swapped = true
                    break
                end
            end
            -- if couldn't swap, keep as-is (no perfect solution)
        end
    end

    -- assign from pool
    for i, bh in ipairs(extraBlackHoles) do
        local p = playerPool[i]
        bh.TargetPlayer = p
        bh.AssignedParts = {}
        -- respect disabled state
        if bh.TargetPlayer and bh.TargetPlayer:FindFirstChild("Disabled") and bh.TargetPlayer.Disabled.Value == true then
            setBlackHoleActiveState(bh, false)
        else
            setBlackHoleActiveState(bh, true)
        end
        -- place BH instantly if HRP exists
        if p and p.Character and p.Character:FindFirstChild("HumanoidRootPart") and bh.Attachment then
            bh.Attachment.WorldCFrame = p.Character.HumanoidRootPart.CFrame
        end
    end
end

-- Create N extra black holes, attempt to assign different initial targets
local function createNBlackHoles(n)
    if n <= 0 then return end

    -- Create BHs
    for i = 1, n do
        createExtraBlackHole(nil)
    end

    -- Assignment behavior:
    if PAAEnabled then
        -- allow multiple BHs per player when BHs > players (even distribution)
        assignUniqueTargetsToBHs()
    else
        -- non-PAA multi-BH: allow players to have multiple BHs evenly distributed across players (no local player)
        local players = getAllNonLocalPlayers()
        if #players > 0 then
            -- distribute bhCount across players evenly
            local bhCount = #extraBlackHoles
            local playerCount = #players
            local base = math.floor(bhCount / playerCount)
            local rem = bhCount - base * playerCount
            local pool = {}
            for i = 1, playerCount do
                local cnt = base + (i <= rem and 1 or 0)
                for j = 1, cnt do
                    table.insert(pool, players[i])
                end
            end
            -- assign
            for i, bh in ipairs(extraBlackHoles) do
                local pl = pool[i]
                bh.TargetPlayer = pl
                bh.LastTarget = nil
                if bh.TargetPlayer and bh.TargetPlayer:FindFirstChild("Disabled") and bh.TargetPlayer.Disabled.Value == true then
                    setBlackHoleActiveState(bh, false)
                else
                    setBlackHoleActiveState(bh, true)
                end
                if bh.TargetPlayer and bh.TargetPlayer.Character and bh.TargetPlayer.Character:FindFirstChild("HumanoidRootPart") then
                    bh.Attachment.WorldCFrame = bh.TargetPlayer.Character.HumanoidRootPart.CFrame
                end
            end
        end
    end

    if #extraBlackHoles > 0 then
        startRebalancer()
    end
end

-- Delete extra black holes and reset back to single Attachment1
local function deleteExtraBlackHoles()
    for _, bh in ipairs(extraBlackHoles) do
        destroyExtraBlackHole(bh)
    end
    extraBlackHoles = {}
    if not Attachment1 or not Attachment1.Parent then
        Attachment1 = setupPlayer()
    end
    stopRebalancer()
end

-- PAA management: create one black hole per player (or selected players)
local function refreshPAA()
    deleteExtraBlackHoles()

    local targets = {}
    if PAA_isUsingSelected then
        targets = getSelectedPlayers()
    else
        targets = getAllNonLocalPlayers()
    end

    for _, tgt in ipairs(targets) do
        local bh = createExtraBlackHole(tgt)
        bh.TargetPlayer = tgt
        bh.LastTarget = nil
        -- respect disabled at creation
        if tgt:FindFirstChild("Disabled") and tgt.Disabled.Value == true then
            setBlackHoleActiveState(bh, false)
        else
            setBlackHoleActiveState(bh, true)
        end
        if tgt.Character and tgt.Character:FindFirstChild("HumanoidRootPart") and bh.Attachment then
            bh.Attachment.WorldCFrame = tgt.Character.HumanoidRootPart.CFrame
        end
    end

    -- ensure distribution also handles BHs > players (if you later create extra BHs)
    assignUniqueTargetsToBHs()

    if #extraBlackHoles > 0 then
        startRebalancer()
    end
end

-- Player join/leave handlers for PAA live updates
local function onPlayerAddedForPAA(pl)
    if PAAEnabled and not PAA_isUsingSelected and pl ~= localPlayer then
        local bh = createExtraBlackHole(pl)
        bh.TargetPlayer = pl
        bh.LastTarget = nil
        assignUniqueTargetsToBHs()
    end
end

local function onPlayerRemovingForPAA(pl)
    if PAAEnabled then
        for i = #extraBlackHoles, 1, -1 do
            local bh = extraBlackHoles[i]
            if bh and bh.TargetPlayer == pl then
                destroyExtraBlackHole(bh)
                table.remove(extraBlackHoles, i)
                break
            end
        end
        assignUniqueTargetsToBHs()
    end
end

-- Toggle main black hole (legacy single Attachment1 behavior)
local function toggleBlackHole()
    blackHoleActive = toggleState
    if blackHoleActive then
        -- Keep Attachment1 in the global folder (do NOT parent to local player)
        if not Attachment1 or not Attachment1.Parent then
            Attachment1 = setupPlayer()
        end

        anchoredOnce = false
        processWorkspaceParts()
        spawn(function()
            local phaseT = 0
            local lastHeartbeat = tick()
            while blackHoleActive do
                local now = tick()
                local dt = now - lastHeartbeat
                lastHeartbeat = now
                phaseT = phaseT + dt

                targetPlayer = getRandomPlayer()
                if targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
                    local hrp = targetPlayer.Character.HumanoidRootPart
                    local vel = hrp.Velocity or Vector3.new(0,0,0)
                    local speed = vel.Magnitude
                    local dir = (speed > 0.5) and vel.Unit or hrp.CFrame.LookVector

                    -- front distance based on speed
                    local frontDist = clamp(speed * FRONT_MULTIPLIER, FRONT_MIN, FRONT_MAX)

                    local amplitude = clamp(speed * BH_AMPLITUDE_FACTOR, BH_MIN_AMPLITUDE, BH_MAX_AMPLITUDE)
                    local phase = phaseT * (2 * math.pi * BH_OSC_FREQUENCY)
                    local skidPhase = phaseT * (2 * math.pi * BH_OSC_FREQUENCY * SKID_FACTOR)

                    local forwardJitter = math.sin(phase) * amplitude
                    local primaryOffset = dir * (frontDist + forwardJitter)
                    local lateral = hrp.CFrame.RightVector * (math.sin(skidPhase * 1.27) * amplitude * SKID_LATERAL_SCALE)
                    local vertical = hrp.CFrame.UpVector * (math.sin(skidPhase * 1.0) * amplitude * SKID_VERTICAL_SCALE)
                    local targetCFrame = hrp.CFrame * CFrame.new(primaryOffset + lateral + vertical)

                    -- smoothly lerp Attachment1 toward the target (smoother targeting)
                    if Attachment1 then
                        local success, cur = pcall(function() return Attachment1.WorldCFrame end)
                        local curCF = success and cur or Attachment1.WorldCFrame or hrp.CFrame
                        Attachment1.WorldCFrame = smoothLerpCFrame(curCF, targetCFrame, dt)
                    end
                end
                wait(switchDelay)
            end
        end)
    else
        blackHoleActive = false
        -- do not change local player's collisions/noclip
        if unanchorTimerRunning and unanchorCoroutine then
            unanchorTimerRunning = false
            for part, anchored in pairs(initiallyAnchoredParts) do
                if part and part.Parent and anchored == false then
                    part.Anchored = false
                    ForcePart(part)
                end
            end
        end
        clearProcessedParts()

        -- If PAA is enabled and we toggled off the primary targeting mode, destroy existing extra BHs (so enabling will re-create correctly)
        if PAAEnabled then
            deleteExtraBlackHoles()
        end
    end
end

-- Toggle target selected behavior (legacy)
local function toggleTargetSelected()
    blackHoleActive = toggleState
    if blackHoleActive then
        if not Attachment1 or not Attachment1.Parent then
            Attachment1 = setupPlayer()
        end

        anchoredOnce = false
        processWorkspaceParts()
        spawn(function()
            local phaseT = 0
            local lastHeartbeat = tick()
            while blackHoleActive do
                local now = tick()
                local dt = now - lastHeartbeat
                lastHeartbeat = now
                phaseT = phaseT + dt

                local selectedPlayers = getSelectedPlayers()
                if #selectedPlayers > 0 then
                    targetPlayer = selectedPlayers[math.random(1, #selectedPlayers)]
                else
                    targetPlayer = nil
                end
                if targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
                    local hrp = targetPlayer.Character.HumanoidRootPart
                    local vel = hrp.Velocity or Vector3.new(0,0,0)
                    local speed = vel.Magnitude
                    local dir = (speed > 0.5) and vel.Unit or hrp.CFrame.LookVector

                    local frontDist = clamp(speed * FRONT_MULTIPLIER, FRONT_MIN, FRONT_MAX)
                    local amplitude = clamp(speed * BH_AMPLITUDE_FACTOR, BH_MIN_AMPLITUDE, BH_MAX_AMPLITUDE)
                    local phase = phaseT * (2 * math.pi * BH_OSC_FREQUENCY)
                    local skidPhase = phaseT * (2 * math.pi * BH_OSC_FREQUENCY * SKID_FACTOR)

                    local forwardJitter = math.sin(phase) * amplitude
                    local primaryOffset = dir * (frontDist + forwardJitter)
                    local lateral = hrp.CFrame.RightVector * (math.sin(skidPhase * 1.27) * amplitude * SKID_LATERAL_SCALE)
                    local vertical = hrp.CFrame.UpVector * (math.sin(skidPhase * 1.0) * amplitude * SKID_VERTICAL_SCALE)
                    local targetCFrame = hrp.CFrame * CFrame.new(primaryOffset + lateral + vertical)

                    if Attachment1 then
                        local success, cur = pcall(function() return Attachment1.WorldCFrame end)
                        local curCF = success and cur or Attachment1.WorldCFrame or hrp.CFrame
                        Attachment1.WorldCFrame = smoothLerpCFrame(curCF, targetCFrame, dt)
                    end
                end
                wait(switchDelay)
            end
        end)
    else
        blackHoleActive = false
        if unanchorTimerRunning and unanchorCoroutine then
            unanchorTimerRunning = false
            for part, anchored in pairs(initiallyAnchoredParts) do
                if part and part.Parent and anchored == false then
                    part.Anchored = false
                    ForcePart(part)
                end
            end
        end
        clearProcessedParts()

        if PAAEnabled then
            deleteExtraBlackHoles()
        end
    end
end

-- Keep primary behavior consistent on respawn but do NOT reparent Attachment1 to local player
local function onCharacterAdded(character)
    if blackHoleActive then
        -- do not attach Attachment1 to character; keep it in folder
        processedParts = {}
        processWorkspaceParts()
    end
end

localPlayer.CharacterAdded:Connect(onCharacterAdded)

-- ---- Rebalancer: exact equal-count distribution of processed parts across extraBlackHoles ----
function startRebalancer()
    if rebalancerRunning then return end
    rebalancerRunning = true
    spawn(function()
        while rebalancerRunning do
            local bhCount = #extraBlackHoles
            local parts = {}
            for p, _ in pairs(processedParts) do
                if p and p.Parent then
                    local ap = p:FindFirstChildOfClass("AlignPosition")
                    if ap then
                        table.insert(parts, p)
                    else
                        ForcePart(p)
                        local ap2 = p:FindFirstChildOfClass("AlignPosition")
                        if ap2 then table.insert(parts, p) end
                    end
                end
            end

            if bhCount > 0 and #parts > 0 then
                -- exact equal-count calculation
                local total = #parts
                local base = math.floor(total / bhCount)
                local rem = total - (base * bhCount) -- remainder to distribute (0..bhCount-1)
                local counts = {}
                for i = 1, bhCount do
                    counts[i] = base + (i <= rem and 1 or 0)
                end

                local partIndex = 1
                for i = 1, bhCount do
                    local bh = extraBlackHoles[i]
                    local need = counts[i]
                    for c = 1, need do
                        local p = parts[partIndex]
                        if not p then break end
                        local ap = p:FindFirstChildOfClass("AlignPosition")
                        if ap then
                            -- ensure the BH attachment is safe and BH active
                            if bh and bh.Attachment and bh._active then
                                ap.Attachment1 = bh.Attachment
                                p.CanCollide = false
                                table.insert(bh.AssignedParts, p)
                            else
                                ap.Attachment1 = Attachment1
                                p.CanCollide = false
                            end
                        end
                        partIndex = partIndex + 1
                    end
                end
            else
                -- no extra BHs: ensure all parts point to Attachment1 (primary)
                for _, p in ipairs(parts) do
                    local ap = p:FindFirstChildOfClass("AlignPosition")
                    if ap then
                        ap.Attachment1 = Attachment1
                        p.CanCollide = false
                    end
                end
            end

            if PAAEnabled then
                assignUniqueTargetsToBHs()
            end

            wait(rebalancerFreq)
        end
    end)
end

function stopRebalancer()
    rebalancerRunning = false
end

-- ---- Command system (chat) and GUI toggles ----
local enableCommands = true -- commands enabled by default

-- Chat command parser (client-side; only listens to local player's chat)
local function onLocalPlayerChatted(msg)
    if not enableCommands then return end
    if not msg then return end
    local raw = msg
    msg = msg:lower()
    -- /e blackholes N
    local bhArg = string.match(msg, "^/e%s+blackholes%s+(%d+)")
    if bhArg then
        local n = tonumber(bhArg)
        if n and n > 0 then
            createNBlackHoles(n)
        end
        return
    end

    -- /e dbh
    if string.match(msg, "^/e%s+dbh") then
        deleteExtraBlackHoles()
        return
    end

    -- /e paa -> toggle PAA on
    if string.match(msg, "^/e%s+paa") then
        PAAEnabled = true
        PAA_isUsingSelected = false
        refreshPAA()
        paaConnections[#paaConnections+1] = Players.PlayerAdded:Connect(onPlayerAddedForPAA)
        paaConnections[#paaConnections+1] = Players.PlayerRemoving:Connect(onPlayerRemovingForPAA)
        return
    end

    -- /e unpaa -> disable PAA
    if string.match(msg, "^/e%s+unpaa") then
        PAAEnabled = false
        for _, c in ipairs(paaConnections) do
            if c and c.Disconnect then pcall(function() c:Disconnect() end) end
        end
        paaConnections = {}
        deleteExtraBlackHoles()
        return
    end

    -- /e psel -> PAA using selected players
    if string.match(msg, "^/e%s+psel") then
        PAAEnabled = true
        PAA_isUsingSelected = true
        refreshPAA()
        return
    end
end

localPlayer.Chatted:Connect(onLocalPlayerChatted)

-- ---- GUI (TurtleLib) ----
local library = loadstring(game:HttpGet("https://raw.githubusercontent.com/miroeramaa/TurtleLib/main/TurtleUiLib.lua"))()
local window = library:Window("made by JLchris") 

window:Toggle("Unanchored Target All", false, function(Value)
    toggleState = Value
    blackHoleActive = Value
    toggleBlackHole()

    if PAAEnabled then
        if Value then
            refreshPAA()
        else
            deleteExtraBlackHoles()
        end
    end
end)

window:Toggle("Target Selected Players", false, function(Value)
    toggleState = Value
    blackHoleActive = Value
    toggleTargetSelected()

    if PAAEnabled then
        if Value then
            refreshPAA()
        else
            deleteExtraBlackHoles()
        end
    end
end)

window:Button("Load Player List Script", function()
    loadstring(game:HttpGet("https://raw.githubusercontent.com/Jlchris1/Udklol/refs/heads/main/Playerlistv6"))()
end)

window:Button("telekinesis/fix target", function()
    loadstring(game:HttpGet(('https://raw.githubusercontent.com/SAZXHUB/Control-update/main/README.md'), true))()
end)

local loopCheckActive = false

window:Toggle("Continuous Loop Check", false, function(Value)
    loopCheckActive = Value
    if loopCheckActive then
        spawn(function()
            while loopCheckActive do
                if blackHoleActive then
                    for _, v in ipairs(Workspace:GetDescendants()) do
                        if v:IsA("BasePart") and not v.Anchored and not processedParts[v] and not isPartPlayerCharacter(v) and not (localPlayer.Character and v:IsDescendantOf(localPlayer.Character)) then
                            ForcePart(v)
                        end
                    end
                end
                wait(0.5)
            end
        end)
    end
end)

-- PAA/unPAA toggle (player-amount BHs)
window:Toggle("PAA/unPAA (player amount BHs)", false, function(Value)
    PAAEnabled = Value
    if PAAEnabled then
        PAA_isUsingSelected = false
        refreshPAA()
        paaConnections[#paaConnections+1] = Players.PlayerAdded:Connect(onPlayerAddedForPAA)
        paaConnections[#paaConnections+1] = Players.PlayerRemoving:Connect(onPlayerRemovingForPAA)
    else
        for _, c in ipairs(paaConnections) do
            if c and c.Disconnect then pcall(function() c:Disconnect() end) end
        end
        paaConnections = {}
        deleteExtraBlackHoles()
    end
end)

-- convenience buttons
window:Button("Create 3 Blackholes (quick)", function()
    createNBlackHoles(3)
end)

window:Button("Delete Extra Blackholes (DBH)", function()
    deleteExtraBlackHoles()
end)

-- Continuous refresh for selection-based PAA if selected mode is enabled
spawn(function()
    while true do
        if PAAEnabled and PAA_isUsingSelected then
            refreshPAA()
        end
        wait(2)
    end
end)

-- Start/stop rebalancer based on presence of extra black holes
spawn(function()
    while true do
        if #extraBlackHoles > 0 and not rebalancerRunning then
            startRebalancer()
        elseif #extraBlackHoles == 0 and rebalancerRunning then
            stopRebalancer()
        end
        wait(0.5)
    end
end)

-- GUI: top-of-screen invisible box with visible text showing how many black hole PARTS exist in blackhole folders
do
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "ÆS_BHCountGui"
    screenGui.ResetOnSpawn = false
    screenGui.Parent = localPlayer:WaitForChild("PlayerGui")

    local txt = Instance.new("TextLabel")
    txt.Name = "BlackHoleCount"
    txt.AnchorPoint = Vector2.new(0.5, 0)
    txt.Position = UDim2.new(0.5, 0, 0, 6)
    txt.Size = UDim2.new(0, 220, 0, 24)
    txt.BackgroundTransparency = 1 -- invisible box
    txt.TextTransparency = 0
    txt.Text = "BlackHoles: 0"
    txt.TextScaled = false
    txt.TextSize = 18
    txt.Font = Enum.Font.SourceSansSemibold
    txt.TextColor3 = Color3.new(1,1,1)
    txt.Parent = screenGui

    -- helper to count black hole parts inside any folder with "blackhole" or "bh" in its name
    local function countBlackHolePartsInFolders()
        local count = 0
        for _, obj in ipairs(Workspace:GetDescendants()) do
            if obj:IsA("Folder") then
                local lname = obj.Name:lower()
                if string.find(lname, "blackhole") or string.find(lname, "bh") or string.find(lname, "aes_blackhole") or string.find(lname, "æs_blackhole") then
                    for _, child in ipairs(obj:GetDescendants()) do
                        if child:IsA("BasePart") then
                            local cname = child.Name:lower()
                            if string.find(cname, "extrabh_center") or string.find(cname, "bh_center") or string.find(cname, "bh_center_part") or string.find(cname, "extra") then
                                count = count + 1
                            end
                        end
                    end
                end
            end
        end
        return count
    end

    spawn(function()
        while true do
            local count = 0
            pcall(function()
                count = countBlackHolePartsInFolders()
            end)
            txt.Text = "BlackHoles: "..tostring(count)
            wait(0.5)
        end
    end)
end

-- End of script
