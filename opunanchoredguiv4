-- Full updated client script
-- Changes in this version:
--  * Aggressive straight-line skidding (already present)
--  * Ping-aware prediction (uses ReplicatedStorage ÆS_Ping RemoteFunction if available; fallback to server-time estimate)
--  * More precise part->BH dividing (nearest BH with balanced counts)
--  * Apply pull (AlignPosition) BEFORE fling (Torque) to avoid parts collapsing on their own forces
--  * Removed "Create 3 Blackholes" + "Delete Extra Blackholes" UI buttons and the chat commands for them
--  * Massless-aware behavior preserved; restores Massless on cleanup
--  * Various safety pcalls and smoothing

local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local localPlayer = Players.LocalPlayer

local function clamp(val, a, b)
    if val < a then return a end
    if val > b then return b end
    return val
end

-- ====== CONFIG / STATE ======
local targetAllActive = false
local targetSelectedActive = false
local primaryLoopRunning = false

local switchDelay = 0.13
local processedParts = {}
local initiallyAnchoredParts = {}
local initiallyMasslessParts = {} -- store original Massless state to restore later
local anchoredOnce = false
local unanchorTimerRunning = false
local unanchorCoroutine

local Attachment1 = nil
local extraBlackHoles = {}

-- PAA state
local PAAEnabled = false
local PAA_isUsingSelected = false
local paaConnections = {}

-- Rebalancer
local rebalancerRunning = false
local rebalancerFreq = 0.10

-- BH motion
local TARGET_SMOOTHNESS = 6.0

local ROTATE_INTERVAL = 0.2

local LifeCycleMode = false
local cycleActive = false
local cyclePlayers = {}
local cycleDead = {}
local cycleConns = {}
local cycleRestartPending = false

-- USER-REQUESTED VALUES (extremely large)
local fallenpartsdestroyheight = 0/0 -- NaN intentional

local BASE_FLING_AXIS = 1e6
local BASE_PULL_FORCE = 1e8
local BASE_PULL_RESP  = 1e6

local FLING_MULTIPLIER = 100000000      -- 1e8
local PULL_MULTIPLIER  = 1000000000000  -- 1e12

local FLING_TORQUE = Vector3.new(BASE_FLING_AXIS * FLING_MULTIPLIER,
                                 BASE_FLING_AXIS * FLING_MULTIPLIER,
                                 BASE_FLING_AXIS * FLING_MULTIPLIER) -- 1e14 per axis
local PULL_MAX_FORCE = BASE_PULL_FORCE * PULL_MULTIPLIER -- 1e20
local PULL_RESPONSIVENESS = BASE_PULL_RESP * PULL_MULTIPLIER -- 1e18

local MASSLESS_TORQUE_SCALE = 1.0
local MASSLESS_PULL_SCALE  = 1.0
local MASSLESS_RESP_SCALE  = 1.2

-- AGGRESSIVE SKID SETTINGS (user tuned)
local SKID_SMOOTHNESS = 40.0

-- prediction & ping tracking
local playerLastVel = {}        -- last velocity per-player
local playerLastVelTime = {}
local playerPingEstimate = {}   -- ms (smoothed)
local localPingEstimate = 0     -- ms (smoothed)

-- smoothing constants for ping estimates
local PING_SMOOTH_ALPHA = 0.12

-- Try to use a server RemoteFunction for accurate RTT if available.
-- If you place a RemoteFunction named "ÆS_Ping" in ReplicatedStorage which returns its server time,
-- the script will invoke it to compute a measured round-trip time.
local PingRemoteFunction = nil
do
    local ok, found = pcall(function() return ReplicatedStorage:FindFirstChild("ÆS_Ping") end)
    if ok and found and found:IsA("RemoteFunction") then
        PingRemoteFunction = found
    end
end

-- Fallback server-time offset method if no remote function is available.
-- workspace:GetServerTimeNow() is used to form a coarse estimate of offset between client and server.
local lastServerTimeSample = nil
local lastLocalTimeSample = nil
local serverOffsetSmoothed = nil
local function sampleServerTimeEstimate()
    -- sample server clock and local tick
    local ok, sTime = pcall(function() return Workspace:GetServerTimeNow() end)
    if not ok or not sTime then return end
    local lt = tick()
    if lastServerTimeSample and lastLocalTimeSample then
        local prevOffset = lastServerTimeSample - lastLocalTimeSample
        local newOffset = sTime - lt
        -- smoothing
        if not serverOffsetSmoothed then serverOffsetSmoothed = newOffset end
        serverOffsetSmoothed = serverOffsetSmoothed + (newOffset - serverOffsetSmoothed) * 0.08
        -- approximate RTT by change magnitude between samples (very rough)
        local rttEstimate = math.abs(newOffset - prevOffset) * 1000
        -- smooth to local ping estimate (ms)
        localPingEstimate = localPingEstimate + (rttEstimate - localPingEstimate) * 0.08
    end
    lastServerTimeSample = sTime
    lastLocalTimeSample = lt
end

-- optional active ping check (if RemoteFunction exists)
local function measurePingToServer()
    if not PingRemoteFunction then return end
    local ok, recv
    local before = tick()
    ok, recv = pcall(function() return PingRemoteFunction:InvokeServer() end)
    local after = tick()
    if ok then
        local rtt = (after - before) * 1000
        -- smooth
        localPingEstimate = (localPingEstimate * (1 - PING_SMOOTH_ALPHA)) + (rtt * PING_SMOOTH_ALPHA)
    end
end

-- call periodically
spawn(function()
    while true do
        -- prefer measured remote function ping if available
        if PingRemoteFunction then
            pcall(measurePingToServer)
        else
            pcall(sampleServerTimeEstimate)
        end
        wait(0.5)
    end
end)

-- Predict target using velocity + acceleration + ping compensation
local function predictTargetPosition(pl, pos, vel, now)
    local lastV = playerLastVel[pl]
    local lastT = playerLastVelTime[pl]
    local accel = Vector3.new(0,0,0)
    if lastV and lastT and now and now > lastT then
        accel = (vel - lastV) / (now - lastT)
    end
    playerLastVel[pl] = vel
    playerLastVelTime[pl] = now

    local speed = vel.Magnitude

    -- base lead factor grows with speed
    local leadFactor = clamp(0.25 + (speed * 0.06), 0.25, 1.8)

    -- ping compensation: use localPing + estimated target ping if available (both ms)
    local targetPing = playerPingEstimate[pl] or localPingEstimate or 0
    local combinedPingMs = (localPingEstimate or 0) + (targetPing or 0) -- ms
    -- convert to seconds and scale a small amount (we don't want ping to dominate)
    local pingComp = clamp((combinedPingMs / 1000) * 0.9, 0, 1.2) -- seconds
    -- add ping comp to leadFactor (as additional seconds)
    local tlead = leadFactor + pingComp

    -- use kinematic formula pos + v*t + 0.5*a*t^2
    local predicted = pos + vel * tlead + 0.5 * accel * (tlead * tlead)
    return predicted, tlead, accel
end

-- helpers
local function isNPC(character)
    if not character or not character:IsA("Model") then return false end
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if humanoid and not Players:GetPlayerFromCharacter(character) then return true end
    return false
end

local function isPartPlayerCharacter(part)
    if not part then return false end
    for _, pl in ipairs(Players:GetPlayers()) do
        local char = pl.Character
        if char and part:IsDescendantOf(char) then
            return true
        end
    end
    return false
end

local function stripBodyForces(part)
    for _, x in next, part:GetChildren() do
        if x:IsA("BodyAngularVelocity") or x:IsA("BodyForce") or x:IsA("BodyGyro")
        or x:IsA("BodyPosition") or x:IsA("BodyThrust") or x:IsA("BodyVelocity")
        or x:IsA("RocketPropulsion") then
            x:Destroy()
        end
    end
    if part:FindFirstChild("Attachment") then part:FindFirstChild("Attachment"):Destroy() end
    if part:FindFirstChild("AlignPosition") then part:FindFirstChild("AlignPosition"):Destroy() end
    if part:FindFirstChild("Torque") then part:FindFirstChild("Torque"):Destroy() end
end

local function shuffle(t)
    for i = #t, 2, -1 do
        local j = math.random(1, i)
        t[i], t[j] = t[j], t[i]
    end
end

local function smoothLerpCFrame(curCF, targetCF, dt)
    local alpha = 1 - math.exp(-TARGET_SMOOTHNESS * dt)
    if alpha < 0.001 then alpha = 0.001 end
    if alpha > 1 then alpha = 1 end
    return curCF:Lerp(targetCF, alpha)
end

local function isWhitelisted(player)
    if not player then return false end
    local v = player:FindFirstChild("Whitelisted")
    if v and typeof(v.Value) == "boolean" then
        return v.Value
    end
    return false
end

local function isPlayerAlive(player)
    if not player then return false end
    local char = player.Character
    if not char then return false end
    local humanoid = char:FindFirstChildOfClass("Humanoid")
    if not humanoid then return false end
    if humanoid.Health and humanoid.Health > 0 then return true end
    return false
end

local function getAllNonLocalPlayers()
    local res = {}
    for _, p in ipairs(Players:GetPlayers()) do
        if p and p ~= localPlayer and p.Parent and not isWhitelisted(p) then
            table.insert(res, p)
        end
    end
    return res
end

local function getSelectedPlayers(allowWhitelisted)
    local res = {}
    for _, player in pairs(Players:GetPlayers()) do
        if player and player ~= localPlayer and player.Parent then
            local sel = player:FindFirstChild("Selected")
            if sel and typeof(sel.Value) == "boolean" and sel.Value == true then
                if allowWhitelisted then
                    table.insert(res, player)
                else
                    if not isWhitelisted(player) then table.insert(res, player) end
                end
            end
        end
    end
    return res
end

-- Improved assignment algorithm:
-- For each unprocessed part, compute distances to each BH; greedily assign to the BH with minimal (distance * weight)
-- where weight is 1 + (assignedCount / idealCount). This favors nearest BH while balancing counts.
local function distributePartsToBHs(parts, bhs)
    if #bhs == 0 then return end
    local totalParts = #parts
    local idealPerBH = math.max(1, math.floor(totalParts / #bhs))
    -- clear assigned lists
    for _, bh in ipairs(bhs) do
        bh.AssignedParts = bh.AssignedParts or {}
    end
    -- precompute BH positions
    local bhPos = {}
    for i,bh in ipairs(bhs) do
        local pos = bh.Part and bh.Part.Position or (bh.Attachment and bh.Attachment.WorldCFrame.p) or Vector3.new(0,0,0)
        bhPos[i] = pos
    end
    -- assignment loop
    for _, part in ipairs(parts) do
        if part and part.Parent then
            local bestIdx = 1
            local bestScore = math.huge
            for i,bh in ipairs(bhs) do
                local d = (part.Position - bhPos[i]).Magnitude
                local assigned = #bh.AssignedParts
                local weight = 1 + (assigned / math.max(1, idealPerBH))
                local score = d * weight
                if score < bestScore then
                    bestScore = score
                    bestIdx = i
                end
            end
            local chosen = bhs[bestIdx]
            chosen.AssignedParts[#chosen.AssignedParts + 1] = part
        end
    end
end

-- get BHs by source
local function getBHsBySource(source)
    local out = {}
    for _, bh in ipairs(extraBlackHoles) do
        if bh.source == source then table.insert(out, bh) end
    end
    return out
end

local function getLeastLoadedBlackHole()
    if #extraBlackHoles == 0 then return nil end
    table.sort(extraBlackHoles, function(a,b) return (#a.AssignedParts) < (#b.AssignedParts) end)
    return extraBlackHoles[1]
end

-- ForcePart: apply AlignPosition (pull) first and let it engage, then apply Torque (fling)
local function ForcePart(v)
    if not v or not v:IsA("BasePart") then return end
    if isPartPlayerCharacter(v) then return end
    if localPlayer.Character and v:IsDescendantOf(localPlayer.Character) then return end

    if v:IsA("BasePart")
        and not v.Anchored
        and v.Name ~= "Handle"
        and (
            (v.Parent:FindFirstChildOfClass("Humanoid") and isNPC(v.Parent))
            or (not v.Parent:FindFirstChildOfClass("Humanoid") and not v.Parent:FindFirstChild("Head"))
        ) then

        if processedParts[v] then return end
        processedParts[v] = true

        -- store original Massless
        if initiallyMasslessParts[v] == nil then
            pcall(function() initiallyMasslessParts[v] = v.Massless end)
        end

        -- make massless
        pcall(function() v.Massless = true end)

        stripBodyForces(v)
        v.CanCollide = false

        -- Create AlignPosition (PULL) first and attach to BH or Attachment1
        local AlignPosition = Instance.new("AlignPosition")
        AlignPosition.MaxVelocity = math.huge
        -- set high force now so it resists collapse while torque later applied
        local ok, isMass = pcall(function() return v.Massless end)
        local pullForce = PULL_MAX_FORCE * (ok and isMass and MASSLESS_PULL_SCALE or 1)
        local pullResp  = PULL_RESPONSIVENESS * (ok and isMass and MASSLESS_RESP_SCALE or 1)
        AlignPosition.MaxForce = pullForce
        AlignPosition.Responsiveness = pullResp
        AlignPosition.Attachment0 = Instance.new("Attachment", v)
        pcall(function() AlignPosition.Attachment0.WorldCFrame = v.CFrame end)
        AlignPosition.Parent = v

        -- decide attachment1 (BH or Attachment1)
        local bh = getLeastLoadedBlackHole()
        if bh and bh.Attachment and bh._active then
            AlignPosition.Attachment1 = bh.Attachment
            bh.AssignedParts[#bh.AssignedParts + 1] = v
        else
            AlignPosition.Attachment1 = Attachment1
        end

        -- small yield to let AlignPosition register and start pulling (reduces collapse)
        -- we do not use long yields; short wait yields enough for engine to apply forces
        spawn(function()
            -- allow AlignPosition to begin applying force
            wait(0.02) -- 20ms

            -- now create Torque (FLING)
            local torqueVal = FLING_TORQUE
            if ok and isMass == true then
                torqueVal = torqueVal * MASSLESS_TORQUE_SCALE
            end
            local Torque = Instance.new("Torque")
            Torque.Attachment0 = v:FindFirstChildOfClass("Attachment") or AlignPosition.Attachment0
            Torque.Torque = torqueVal
            Torque.Parent = v
        end)
    end
end

-- clean-up
local function clearProcessedParts()
    for part, _ in pairs(processedParts) do
        if part and part.Parent then
            stripBodyForces(part)
            part.CanCollide = true

            if initiallyAnchoredParts[part] == false then
                part.Anchored = false
            elseif initiallyAnchoredParts[part] == true then
                part.Anchored = true
            end

            if initiallyMasslessParts[part] ~= nil then
                local original = initiallyMasslessParts[part]
                pcall(function() part.Massless = original end)
            else
                pcall(function() part.Massless = false end)
            end
        end
    end
    processedParts = {}
    initiallyAnchoredParts = {}
    initiallyMasslessParts = {}
    anchoredOnce = false
end

-- anchor/unanchor flow (massless handling integrated)
local function anchorAndDelayedUnanchorParts()
    unanchorTimerRunning = true

    local candidateParts = {}
    for _, v in ipairs(Workspace:GetDescendants()) do
        if v:IsA("BasePart")
            and not v.Anchored
            and v.Name ~= "Handle"
            and not isPartPlayerCharacter(v)
            and not (localPlayer.Character and v:IsDescendantOf(localPlayer.Character))
            and (
                (v.Parent:FindFirstChildOfClass("Humanoid") and isNPC(v.Parent))
                or (not v.Parent:FindFirstChildOfClass("Humanoid") and not v.Parent:FindFirstChild("Head"))
            ) then
            table.insert(candidateParts, v)
        end
    end

    initiallyAnchoredParts = {}
    for _, part in ipairs(candidateParts) do
        initiallyAnchoredParts[part] = false
        if initiallyMasslessParts[part] == nil then
            pcall(function() initiallyMasslessParts[part] = part.Massless end)
        end
        pcall(function() part.Massless = true end)

        part.Anchored = true
        part.CanCollide = false
    end

    for _, npcCandidate in ipairs(Workspace:GetChildren()) do
        if isNPC(npcCandidate) then
            for _, p in ipairs(npcCandidate:GetDescendants()) do
                if p:IsA("BasePart") then p.CanCollide = true end
            end
        end
    end

    local startTime = tick()
    while (targetAllActive or targetSelectedActive) and tick() - startTime < 1 do
        wait(0.05)
    end

    for _, part in ipairs(candidateParts) do
        if part and part.Parent and initiallyAnchoredParts[part] == false then
            part.Anchored = false
            pcall(function()
                if not isPartPlayerCharacter(part) and not (localPlayer.Character and part:IsDescendantOf(localPlayer.Character)) then
                    initiallyMasslessParts[part] = initiallyMasslessParts[part] or part.Massless
                    part.Massless = true
                end
            end)
            ForcePart(part)
        end
    end

    unanchorTimerRunning = false
    anchoredOnce = true
end

local descendantAddedConn
local function processWorkspaceParts()
    if descendantAddedConn then
        descendantAddedConn:Disconnect()
        descendantAddedConn = nil
    end

    if (targetAllActive or targetSelectedActive) then
        if not unanchorTimerRunning and not anchoredOnce then
            unanchorCoroutine = coroutine.create(anchorAndDelayedUnanchorParts)
            coroutine.resume(unanchorCoroutine)
        end

        descendantAddedConn = Workspace.DescendantAdded:Connect(function(v)
            if (targetAllActive or targetSelectedActive) then
                if v:IsA("BasePart")
                    and not v.Anchored
                    and not processedParts[v]
                    and not isPartPlayerCharacter(v)
                    and not (localPlayer.Character and v:IsDescendantOf(localPlayer.Character)) then
                    if initiallyMasslessParts[v] == nil then
                        pcall(function() initiallyMasslessParts[v] = v.Massless end)
                    end
                    pcall(function() v.Massless = true end)
                    ForcePart(v)
                end
            end
        end)
    end
end

local function getRandomPlayer()
    local players = getAllNonLocalPlayers()
    if #players == 0 then return nil end
    return players[math.random(1, #players)]
end

-- set BH active/inactive
local function setBlackHoleActiveState(bh, active)
    if not bh then return end
    if bh._active == active then return end
    bh._active = active
    if not active then
        for _, p in ipairs(bh.AssignedParts) do
            if p and p.Parent then
                p.CanCollide = true
                local ap = p:FindFirstChildOfClass("AlignPosition")
                if ap then
                    ap.Attachment1 = Attachment1
                    pcall(function()
                        local isMass = (pcall(function() return p.Massless end) and p.Massless)
                        ap.MaxForce = PULL_MAX_FORCE * (isMass and MASSLESS_PULL_SCALE or 1)
                        ap.Responsiveness = PULL_RESPONSIVENESS * (isMass and MASSLESS_RESP_SCALE or 1)
                    end)
                end
            end
        end
    else
        for _, p in ipairs(bh.AssignedParts) do
            if p and p.Parent then
                local ap = p:FindFirstChildOfClass("AlignPosition")
                if ap then ap.Attachment1 = bh.Attachment; p.CanCollide = false end
            end
        end
    end
end

-- create extra BH helper
local function createExtraBlackHole(initialTarget, source)
    if initialTarget == localPlayer then initialTarget = nil end
    if initialTarget and isWhitelisted(initialTarget) and source ~= "CMD_ALLOW_WHITELISTED" then
        initialTarget = nil
    end

    local folder = Workspace:FindFirstChild("ÆS_BlackHole_Folder") or Instance.new("Folder", Workspace)
    folder.Name = "ÆS_BlackHole_Folder"
    local part = Instance.new("Part", folder)
    part.Anchored = true
    part.CanCollide = false
    part.Transparency = 1
    part.Size = Vector3.new(1,1,1)
    part.Name = "ExtraBH_Center"

    local att = Instance.new("Attachment", part)

    local bh = {
        Part = part,
        Attachment = att,
        AssignedParts = {},
        TargetPlayer = initialTarget,
        LastTarget = nil,
        _running = true,
        _active = true,
        source = source or "CMD",
        rotating = false,
        smoothedCF = part.CFrame
    }

    local function isPlayerDisabled(pl)
        if not pl then return false end
        if pl:FindFirstChild("Disabled") and typeof(pl.Disabled.Value) == "boolean" then
            return pl.Disabled.Value
        end
        return false
    end

    -- BH thread: aggressive straight-line skid (uses predictTargetPosition with ping compensation)
    bh._thread = spawn(function()
        local t = 0
        while bh._running do
            local dt = RunService.Heartbeat:Wait()
            t = t + dt

            if bh.TargetPlayer and bh.TargetPlayer ~= localPlayer and not isWhitelisted(bh.TargetPlayer) and isPlayerAlive(bh.TargetPlayer) then
                if isPlayerDisabled(bh.TargetPlayer) then
                    setBlackHoleActiveState(bh, false)
                else
                    setBlackHoleActiveState(bh, true)

                    local char = bh.TargetPlayer.Character
                    if char and char:FindFirstChild("HumanoidRootPart") then
                        local hrp = char.HumanoidRootPart
                        local pos = hrp.Position
                        local vel = hrp.Velocity or Vector3.new(0,0,0)
                        local now = tick()

                        -- update player ping estimate coarse (we cannot measure remotely per-player without server support).
                        -- If you implement server-side ping echo per-player it can be stored into playerPingEstimate[pl].
                        -- Here we leave playerPingEstimate[pl] as-is; maintain smoothing if it's present.
                        -- Predict with ping compensation:
                        local predictedPos, leadSecs, accel = predictTargetPosition(bh.TargetPlayer, pos, vel, now)
                        local speed = vel.Magnitude

                        -- Straight-line skid endpoints; total skid length = 2 * speed (user requested)
                        local dir = (speed > 0.001) and vel.Unit or hrp.CFrame.LookVector
                        local halfLen = speed
                        if halfLen < 0.5 then halfLen = 0.5 end -- minimum

                        -- Frequency scales with speed (aggressive)
                        local baseFreq = 8.0
                        local freq = baseFreq + (speed * 3.0)
                        if freq < 6 then freq = 6 end

                        local phase = t * (2 * math.pi * freq)
                        local s = math.sin(phase) -- [-1,1]

                        local offset = dir * (s * halfLen)
                        local desiredPos = predictedPos + offset
                        local lookAt = predictedPos + dir
                        local targetCF = CFrame.new(desiredPos, lookAt)

                        -- Aggressive smoothing (faster for higher speed)
                        local effectiveSmooth = SKID_SMOOTHNESS * (1 + speed * 0.8)
                        if effectiveSmooth < 1.0 then effectiveSmooth = 1.0 end
                        local skidAlpha = 1 - math.exp(-effectiveSmooth * dt)
                        if skidAlpha < 0.01 then skidAlpha = 0.01 end
                        if skidAlpha > 0.999 then skidAlpha = 0.999 end

                        local success, cur = pcall(function() return bh.Attachment.WorldCFrame end)
                        local curCF = success and cur or bh.smoothedCF or bh.Part.CFrame

                        bh.smoothedCF = curCF:Lerp(targetCF, skidAlpha)

                        if att then
                            att.WorldCFrame = bh.smoothedCF
                        end
                    end
                end
            else
                -- No valid targets: deactivate and stay near Attachment1 (do NOT roam to local player)
                local hasValidTargets = false
                for _, pl in ipairs(Players:GetPlayers()) do
                    if pl ~= localPlayer and pl.Parent and not isWhitelisted(pl) and isPlayerAlive(pl) then
                        hasValidTargets = true
                        break
                    end
                end

                if not hasValidTargets then
                    setBlackHoleActiveState(bh, false)
                    if Attachment1 and Attachment1.Parent and att then
                        local success, cur = pcall(function() return bh.Attachment.WorldCFrame end)
                        local curCF = success and cur or bh.smoothedCF or bh.Part.CFrame
                        local centerCF
                        pcall(function() centerCF = Attachment1.WorldCFrame end)
                        if centerCF then
                            local targetCF = centerCF
                            local idleAlpha = 1 - math.exp(- (SKID_SMOOTHNESS * 1.2) * dt)
                            if idleAlpha < 0.01 then idleAlpha = 0.01 end
                            if idleAlpha > 0.99 then idleAlpha = 0.99 end
                            bh.smoothedCF = curCF:Lerp(targetCF, idleAlpha)
                            att.WorldCFrame = bh.smoothedCF
                        end
                    end
                    wait(0.06)
                else
                    if att then
                        local success, cur = pcall(function() return bh.Attachment.WorldCFrame end)
                        local curCF = success and cur or bh.smoothedCF or bh.Part.CFrame
                        local idleAlpha = 1 - math.exp(- (SKID_SMOOTHNESS * 0.6) * dt)
                        if idleAlpha < 0.01 then idleAlpha = 0.01 end
                        if idleAlpha > 0.85 then idleAlpha = 0.85 end
                        bh.smoothedCF = curCF:Lerp(curCF, idleAlpha)
                        att.WorldCFrame = bh.smoothedCF
                    end
                end
            end
        end
    end)

    table.insert(extraBlackHoles, bh)
    return bh
end

local function destroyExtraBlackHole(bh)
    if not bh then return end
    bh._running = false
    if bh.Part and bh.Part.Parent then bh.Part:Destroy() end
    for _, p in ipairs(bh.AssignedParts) do
        if p and p.Parent then
            local ap = p:FindFirstChildOfClass("AlignPosition")
            if ap then ap.Attachment1 = Attachment1 end
            p.CanCollide = false
            if initiallyMasslessParts[p] ~= nil then
                pcall(function() p.Massless = initiallyMasslessParts[p] end)
            else
                pcall(function() p.Massless = false end)
            end
        end
    end
end

local function deleteBHsBySource(source)
    for i = #extraBlackHoles, 1, -1 do
        local bh = extraBlackHoles[i]
        if bh and bh.source == source then
            destroyExtraBlackHole(bh)
            table.remove(extraBlackHoles, i)
        end
    end
end

local function deleteAllExtraBlackHoles()
    for _, bh in ipairs(extraBlackHoles) do destroyExtraBlackHole(bh) end
    extraBlackHoles = {}
    if not Attachment1 or not Attachment1.Parent then
        -- recreate Attachment1 if needed
        local Folder = Workspace:FindFirstChild("ÆS_BlackHole_Folder")
        if not Folder then
            Folder = Instance.new("Folder", Workspace)
            Folder.Name = "ÆS_BlackHole_Folder"
        end
        local existing = Folder:FindFirstChild("BH_Center_Part")
        if existing and existing:IsA("BasePart") then
            local att = existing:FindFirstChildOfClass("Attachment")
            if att then Attachment1 = att end
        end
        if not Attachment1 then
            local Part = Instance.new("Part", Folder)
            Part.Name = "BH_Center_Part"
            Part.Anchored = true
            Part.CanCollide = false
            Part.Transparency = 1
            Part.Size = Vector3.new(1,1,1)
            local Attachment = Instance.new("Attachment", Part)
            Attachment1 = Attachment
        end
    end
end

-- ---------- Even distribution + rotating leftovers ----------
local rotatingCoroutine = nil
local rotatingActive = false
local function stopRotatingCoroutine()
    rotatingActive = false
    rotatingCoroutine = nil
end

local function distributeBHListEvenly(bhList, players)
    -- reset rotating flags for BHs in bhList
    for _, bh in ipairs(bhList) do
        bh.rotating = false
        bh.TargetPlayer = nil
        bh.AssignedParts = {}
    end

    if #players == 0 then
        for _, bh in ipairs(bhList) do
            bh.TargetPlayer = nil
            setBlackHoleActiveState(bh, false)
        end
        stopRotatingCoroutine()
        return
    end

    local totalBH = #bhList
    local playerCount = #players
    local base = math.floor(totalBH / playerCount)
    local remainder = totalBH - (base * playerCount)

    local idx = 1
    for pi = 1, playerCount do
        local pl = players[pi]
        for k = 1, base do
            if bhList[idx] then
                bhList[idx].TargetPlayer = pl
                bhList[idx].rotating = false
                setBlackHoleActiveState(bhList[idx], true)
                if pl.Character and pl.Character:FindFirstChild("HumanoidRootPart") then
                    pcall(function() bhList[idx].Attachment.WorldCFrame = pl.Character.HumanoidRootPart.CFrame end)
                end
                idx = idx + 1
            end
        end
    end

    local rotatingBHs = {}
    for r = 1, remainder do
        if bhList[idx] then
            bhList[idx].rotating = true
            bhList[idx].TargetPlayer = nil
            setBlackHoleActiveState(bhList[idx], true)
            table.insert(rotatingBHs, bhList[idx])
            idx = idx + 1
        end
    end

    stopRotatingCoroutine()
    if #rotatingBHs == 0 then return end

    rotatingActive = true
    rotatingCoroutine = spawn(function()
        local posIndex = 1
        while rotatingActive do
            local curPlayers = {}
            for _, pl in ipairs(players) do
                if pl and pl.Parent and isPlayerAlive(pl) and not isWhitelisted(pl) and pl ~= localPlayer then
                    table.insert(curPlayers, pl)
                end
            end
            if #curPlayers == 0 then
                for _, rb in ipairs(rotatingBHs) do
                    rb.TargetPlayer = nil
                    setBlackHoleActiveState(rb, false)
                end
                break
            end

            for _, rb in ipairs(rotatingBHs) do
                local pick = curPlayers[((posIndex - 1) % #curPlayers) + 1]
                if pick and not isWhitelisted(pick) and pick ~= localPlayer and isPlayerAlive(pick) then
                    rb.TargetPlayer = pick
                    setBlackHoleActiveState(rb, true)
                    if pick.Character and pick.Character:FindFirstChild("HumanoidRootPart") and rb.Attachment then
                        pcall(function() rb.Attachment.WorldCFrame = pick.Character.HumanoidRootPart.CFrame end)
                    end
                else
                    rb.TargetPlayer = nil
                    setBlackHoleActiveState(rb, false)
                end
                posIndex = posIndex + 1
            end

            wait(ROTATE_INTERVAL)
        end
    end)
end

-- wrapper: distribute PAA BHs
local function assignTargetsForPAA()
    local paaBHs = getBHsBySource("PAA")
    if #paaBHs == 0 then return end

    local players = {}
    if LifeCycleMode and cycleActive then
        for _, pl in ipairs(cyclePlayers) do
            if pl and pl.Parent and not cycleDead[pl] and isPlayerAlive(pl) then
                table.insert(players, pl)
            end
        end
    else
        if PAA_isUsingSelected then
            players = getSelectedPlayers(true)
        else
            players = getAllNonLocalPlayers()
        end
    end

    shuffle(paaBHs)
    distributeBHListEvenly(paaBHs, players)
end

-- distribute CMD BHs across players
local function assignTargetsForCMD()
    local cmdBHs = getBHsBySource("CMD")
    if #cmdBHs == 0 then return end

    local players = {}
    if LifeCycleMode and cycleActive then
        for _, pl in ipairs(cyclePlayers) do
            if pl and pl.Parent and not cycleDead[pl] and isPlayerAlive(pl) then
                table.insert(players, pl)
            end
        end
    else
        players = getAllNonLocalPlayers()
    end

    shuffle(cmdBHs)
    distributeBHListEvenly(cmdBHs, players)
end

-- create N command BHs (CMD) - kept but no UI or chat exposed
local function createNCommandBlackHoles(n)
    if n <= 0 then return end
    for i = 1, n do createExtraBlackHole(nil, "CMD") end
    assignTargetsForCMD()
    if PAAEnabled then assignTargetsForPAA() end
    if #extraBlackHoles > 0 then
        -- improved rebalancer: distribute parts by nearest BH
        startRebalancer()
    end
end

local function deleteCommandBlackHoles()
    deleteBHsBySource("CMD")
    stopRotatingCoroutine()
end

-- PAA refresh
local function refreshPAA()
    deleteBHsBySource("PAA")
    local targets = {}
    if LifeCycleMode and cycleActive then
        for _, pl in ipairs(cyclePlayers) do
            if pl and pl.Parent and not cycleDead[pl] and isPlayerAlive(pl) then
                table.insert(targets, pl)
            end
        end
    else
        if PAA_isUsingSelected then
            targets = getSelectedPlayers(true)
        else
            targets = getAllNonLocalPlayers()
        end
    end

    for _, tgt in ipairs(targets) do
        if tgt and tgt ~= localPlayer and not isWhitelisted(tgt) then
            local bh = createExtraBlackHole(tgt, "PAA")
            bh.TargetPlayer = tgt
            bh.LastTarget = nil
            setBlackHoleActiveState(bh, true)
            if tgt.Character and tgt.Character:FindFirstChild("HumanoidRootPart") and bh.Attachment then
                pcall(function() bh.Attachment.WorldCFrame = tgt.Character.HumanoidRootPart.CFrame end)
            end
        end
    end

    assignTargetsForPAA()
    if #extraBlackHoles > 0 then startRebalancer() end
end

-- Player join/leave for PAA
local function onPlayerAddedForPAA(pl)
    if PAAEnabled and not PAA_isUsingSelected and pl ~= localPlayer and not isWhitelisted(pl) then
        if LifeCycleMode and cycleActive then return end
        local bh = createExtraBlackHole(pl, "PAA")
        bh.TargetPlayer = pl
        bh.LastTarget = nil
        assignTargetsForPAA()
    end
end

local function onPlayerRemovingForPAA(pl)
    if PAAEnabled then
        for i = #extraBlackHoles, 1, -1 do
            local bh = extraBlackHoles[i]
            if bh and bh.source == "PAA" and bh.TargetPlayer == pl then
                destroyExtraBlackHole(bh)
                table.remove(extraBlackHoles, i)
                break
            end
        end
        assignTargetsForPAA()
    end
end

-- Life cycle functions unchanged (kept for completeness)
local function clearCycleConnections()
    for _, conn in ipairs(cycleConns) do
        if conn and conn.Disconnect then
            pcall(function() conn:Disconnect() end)
        end
    end
    cycleConns = {}
end

local function stopCycle()
    cycleActive = false
    cyclePlayers = {}
    cycleDead = {}
    clearCycleConnections()
    cycleRestartPending = false
end

local function checkCycleCompletionAndMaybeRestart()
    if not cycleActive then return end
    if #cyclePlayers == 0 then
        cycleRestartPending = true
        return
    end
    for _, pl in ipairs(cyclePlayers) do
        if not cycleDead[pl] then
            return
        end
    end
    cycleRestartPending = true
end

local function scheduleCycleRestart()
    if cycleRestartPending then
        cycleRestartPending = false
        spawn(function()
            wait(0.12)
            local newSnapshot = {}
            if targetSelectedActive then
                newSnapshot = getSelectedPlayers(false)
            else
                newSnapshot = getAllNonLocalPlayers()
            end
            cyclePlayers = {}
            cycleDead = {}
            for _, pl in ipairs(newSnapshot) do
                if pl and pl.Parent and pl ~= localPlayer then
                    cyclePlayers[#cyclePlayers+1] = pl
                    cycleDead[pl] = false
                end
            end
            clearCycleConnections()
            for _, pl in ipairs(cyclePlayers) do
                if pl and pl.Parent then
                    local function onHumanoidAdded(char)
                        local hum = char:FindFirstChildOfClass("Humanoid")
                        if hum then
                            local dconn = hum.Died:Connect(function()
                                cycleDead[pl] = true
                                assignTargetsForPAA()
                                assignTargetsForCMD()
                                checkCycleCompletionAndMaybeRestart()
                            end)
                            table.insert(cycleConns, dconn)
                        end
                    end
                    if pl.Character then
                        onHumanoidAdded(pl.Character)
                    end
                    local cconn = pl.CharacterAdded:Connect(onHumanoidAdded)
                    table.insert(cycleConns, cconn)
                    local rconn = pl.AncestryChanged:Connect(function()
                        if not pl.Parent then
                            for i = #cyclePlayers, 1, -1 do
                                if cyclePlayers[i] == pl then table.remove(cyclePlayers, i) end
                            end
                            cycleDead[pl] = true
                            assignTargetsForPAA()
                            assignTargetsForCMD()
                            checkCycleCompletionAndMaybeRestart()
                        end
                    end)
                    table.insert(cycleConns, rconn)
                end
            end
            assignTargetsForPAA()
            assignTargetsForCMD()
        end)
    end
end

local function startCycleSnapshot()
    stopCycle()
    cycleActive = true
    cyclePlayers = {}
    cycleDead = {}

    local snapshot = {}
    if targetSelectedActive then
        snapshot = getSelectedPlayers(false)
    else
        snapshot = getAllNonLocalPlayers()
    end

    for _, pl in ipairs(snapshot) do
        if pl and pl.Parent and pl ~= localPlayer then
            cyclePlayers[#cyclePlayers+1] = pl
            cycleDead[pl] = false
        end
    end

    clearCycleConnections()
    for _, pl in ipairs(cyclePlayers) do
        if pl and pl.Parent then
            local function attachHumanoidWatcher(char)
                local hum = char:FindFirstChildOfClass("Humanoid")
                if hum then
                    local dconn = hum.Died:Connect(function()
                        cycleDead[pl] = true
                        assignTargetsForPAA()
                        assignTargetsForCMD()
                        checkCycleCompletionAndMaybeRestart()
                        scheduleCycleRestart()
                    end)
                    table.insert(cycleConns, dconn)
                end
            end
            if pl.Character then attachHumanoidWatcher(pl.Character) end
            local cconn = pl.CharacterAdded:Connect(attachHumanoidWatcher)
            table.insert(cycleConns, cconn)
            local rconn = pl.AncestryChanged:Connect(function()
                if not pl.Parent then
                    for i = #cyclePlayers, 1, -1 do
                        if cyclePlayers[i] == pl then table.remove(cyclePlayers, i) end
                    end
                    cycleDead[pl] = true
                    assignTargetsForPAA()
                    assignTargetsForCMD()
                    checkCycleCompletionAndMaybeRestart()
                    scheduleCycleRestart()
                end
            end)
            table.insert(cycleConns, rconn)
        end
    end

    assignTargetsForPAA()
    assignTargetsForCMD()
end

-- Rebalancer now collects processed parts and assigns them with nearest-BH balancing
function startRebalancer()
    if rebalancerRunning then return end
    rebalancerRunning = true
    spawn(function()
        while rebalancerRunning do
            local bhCount = #extraBlackHoles
            local parts = {}
            for p, _ in pairs(processedParts) do
                if p and p.Parent then
                    -- ensure AlignPosition values match massless adaptation
                    local ap = p:FindFirstChildOfClass("AlignPosition")
                    if ap then
                        pcall(function()
                            local isMass = (pcall(function() return p.Massless end) and p.Massless)
                            ap.MaxForce = PULL_MAX_FORCE * (isMass and MASSLESS_PULL_SCALE or 1)
                            ap.Responsiveness = PULL_RESPONSIVENESS * (isMass and MASSLESS_RESP_SCALE or 1)
                        end)
                        table.insert(parts, p)
                    else
                        -- reapply ForcePart (will create AlignPosition)
                        ForcePart(p)
                        local ap2 = p:FindFirstChildOfClass("AlignPosition")
                        if ap2 then
                            pcall(function()
                                local isMass = (pcall(function() return p.Massless end) and p.Massless)
                                ap2.MaxForce = PULL_MAX_FORCE * (isMass and MASSLESS_PULL_SCALE or 1)
                                ap2.Responsiveness = PULL_RESPONSIVENESS * (isMass and MASSLESS_RESP_SCALE or 1)
                            end)
                            table.insert(parts, p)
                        end
                    end
                end
            end

            if bhCount > 0 and #parts > 0 then
                -- assign parts to BHs by nearest-with-balancing
                distributePartsToBHs(parts, extraBlackHoles)
                -- ensure attachments set
                for _, bh in ipairs(extraBlackHoles) do
                    if bh and bh.Attachment and bh._active then
                        for _, p in ipairs(bh.AssignedParts) do
                            if p and p.Parent then
                                local ap = p:FindFirstChildOfClass("AlignPosition")
                                if ap then
                                    ap.Attachment1 = bh.Attachment
                                    p.CanCollide = false
                                end
                            end
                        end
                    else
                        for _, p in ipairs(bh.AssignedParts) do
                            if p and p.Parent then
                                local ap = p:FindFirstChildOfClass("AlignPosition")
                                if ap then
                                    ap.Attachment1 = Attachment1
                                    p.CanCollide = false
                                end
                            end
                        end
                    end
                end
            else
                -- no BHs: attach everything to Attachment1
                for _, p in ipairs(parts) do
                    local ap = p:FindFirstChildOfClass("AlignPosition")
                    if ap then ap.Attachment1 = Attachment1; p.CanCollide = false end
                end
            end

            if PAAEnabled then assignTargetsForPAA() end
            assignTargetsForCMD()

            if cycleRestartPending then
                scheduleCycleRestart()
            end

            wait(rebalancerFreq)
        end
    end)
end

function stopRebalancer() rebalancerRunning = false end

-- LOCAL CHAT COMMANDS: removed create/delete BH commands per request
local enableCommands = true
local function onLocalPlayerChatted(msg)
    if not enableCommands then return end
    if not msg then return end
    local raw = msg
    msg = msg:lower()

    -- removed blackhole create/delete & quick-buttons (per user request)
    if string.match(msg, "^/e%s+paa") then
        PAAEnabled = true
        PAA_isUsingSelected = false
        refreshPAA()
        paaConnections[#paaConnections+1] = Players.PlayerAdded:Connect(onPlayerAddedForPAA)
        paaConnections[#paaConnections+1] = Players.PlayerRemoving:Connect(onPlayerRemovingForPAA)
        return
    end

    if string.match(msg, "^/e%s+unpaa") then
        PAAEnabled = false
        for _, c in ipairs(paaConnections) do pcall(function() c:Disconnect() end) end
        paaConnections = {}
        deleteBHsBySource("PAA")
        return
    end

    if string.match(msg, "^/e%s+psel") then
        PAAEnabled = true
        PAA_isUsingSelected = true
        refreshPAA()
        return
    end
end

localPlayer.Chatted:Connect(onLocalPlayerChatted)

-- Primary loop (handles both Target All and Target Selected)
local function startPrimaryLoop()
    if primaryLoopRunning then return end
    primaryLoopRunning = true
    if not Attachment1 or not Attachment1.Parent then
        -- ensure Attachment1 exists
        local Folder = Workspace:FindFirstChild("ÆS_BlackHole_Folder")
        if not Folder then Folder = Instance.new("Folder", Workspace); Folder.Name = "ÆS_BlackHole_Folder" end
        local existing = Folder:FindFirstChild("BH_Center_Part")
        if existing and existing:IsA("BasePart") then
            local att = existing:FindFirstChildOfClass("Attachment")
            if att then Attachment1 = att end
        end
        if not Attachment1 then
            Attachment1 = setupPlayer()
        end
    end

    anchoredOnce = false
    processWorkspaceParts()

    spawn(function()
        local phaseT = 0
        local lastHeartbeat = tick()
        while targetAllActive or targetSelectedActive do
            local now = tick()
            local dt = now - lastHeartbeat
            lastHeartbeat = now
            phaseT = phaseT + dt

            local targetPlayer
            if targetSelectedActive then
                local selectedPlayers = getSelectedPlayers(true)
                if #selectedPlayers > 0 then
                    targetPlayer = selectedPlayers[math.random(1, #selectedPlayers)]
                else
                    targetPlayer = nil
                end
            elseif targetAllActive then
                targetPlayer = getRandomPlayer()
            else
                targetPlayer = nil
            end

            if targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") and isPlayerAlive(targetPlayer) then
                local hrp = targetPlayer.Character.HumanoidRootPart
                local vel = hrp.Velocity or Vector3.new(0,0,0)
                local speed = vel.Magnitude
                local dir = (speed > 0.5) and vel.Unit or hrp.CFrame.LookVector

                -- Keep Attachment1 roughly near the primary target (smooth)
                local amplitude = clamp(speed * 0.22, 0.6, 80)
                local phase = phaseT * (2 * math.pi * (1/(0.01*2)))
                local primaryOffset = dir * (math.sin(phase) * amplitude)
                local lateral = hrp.CFrame.RightVector * (math.sin(phase * 1.27) * amplitude * 0.35)
                local vertical = hrp.CFrame.UpVector * (math.sin(phase * 1.0) * amplitude * 0.5)
                local targetCFrame = hrp.CFrame * CFrame.new(primaryOffset + lateral + vertical)
                if Attachment1 then
                    local success, cur = pcall(function() return Attachment1.WorldCFrame end)
                    local curCF = success and cur or Attachment1.WorldCFrame or hrp.CFrame
                    Attachment1.WorldCFrame = smoothLerpCFrame(curCF, targetCFrame, dt)
                end
            end

            wait(switchDelay)
        end

        primaryLoopRunning = false
        if unanchorTimerRunning and unanchorCoroutine then
            unanchorTimerRunning = false
            for part, anchored in pairs(initiallyAnchoredParts) do
                if part and part.Parent and anchored == false then
                    part.Anchored = false
                    ForcePart(part)
                end
            end
        end
        clearProcessedParts()

        if PAAEnabled then deleteBHsBySource("PAA") end
    end)
end

local function setTargetAll(value)
    targetAllActive = value
    if (targetAllActive or targetSelectedActive) then startPrimaryLoop() end

    if LifeCycleMode then
        if targetAllActive then
            if not cycleActive then startCycleSnapshot() end
        else
            stopCycle()
        end
    end

    if PAAEnabled then
        if targetAllActive then
            PAA_isUsingSelected = false
            refreshPAA()
            if #paaConnections == 0 then
                paaConnections[#paaConnections+1] = Players.PlayerAdded:Connect(onPlayerAddedForPAA)
                paaConnections[#paaConnections+1] = Players.PlayerRemoving:Connect(onPlayerRemovingForPAA)
            end
        else
            deleteBHsBySource("PAA")
        end
    end
end

local function setTargetSelected(value)
    targetSelectedActive = value
    if (targetAllActive or targetSelectedActive) then startPrimaryLoop() end

    if LifeCycleMode then
        if targetSelectedActive then
            if not cycleActive then startCycleSnapshot() end
        else
            stopCycle()
        end
    end

    if PAAEnabled then
        if targetSelectedActive then
            PAA_isUsingSelected = true
            refreshPAA()
            if #paaConnections == 0 then
                paaConnections[#paaConnections+1] = Players.PlayerAdded:Connect(onPlayerAddedForPAA)
                paaConnections[#paaConnections+1] = Players.PlayerRemoving:Connect(onPlayerRemovingForPAA)
            end
        else
            deleteBHsBySource("PAA")
        end
    end
end

local function onCharacterAdded(character)
    if (targetAllActive or targetSelectedActive) then
        processedParts = {}
        processWorkspaceParts()
    end
end

Players.LocalPlayer.CharacterAdded:Connect(onCharacterAdded)

-- GUI (TurtleLib) — removed create/delete BH buttons per request
local library = loadstring(game:HttpGet("https://raw.githubusercontent.com/miroeramaa/TurtleLib/main/TurtleUiLib.lua"))()
local window = library:Window("Fix it you panis negor🗣🔥")

window:Toggle("Unanchored Target All", false, function(Value) setTargetAll(Value) end)
window:Toggle("Target Selected Players", false, function(Value) setTargetSelected(Value) end)

window:Toggle("Life Cycle Mode", false, function(Value)
    LifeCycleMode = Value
    if LifeCycleMode then
        if (targetAllActive or targetSelectedActive) then startCycleSnapshot() end
    else
        stopCycle()
    end
end)

window:Button("Reset Cycle", function()
    startCycleSnapshot()
end)

window:Button("Load Player List Script", function()
    loadstring(game:HttpGet("https://raw.githubusercontent.com/Jlchris1/Udklol/refs/heads/main/Playerlistv6"))()
end)
window:Button("telekinesis/fix target", function()
    loadstring(game:HttpGet(('https://raw.githubusercontent.com/SAZXHUB/Control-update/main/README.md'), true))()
end)

local loopCheckActive = false
window:Toggle("Continuous Loop Check", false, function(Value)
    loopCheckActive = Value
    if loopCheckActive then
        spawn(function()
            while loopCheckActive do
                if targetAllActive or targetSelectedActive then
                    for _, v in ipairs(Workspace:GetDescendants()) do
                        if v:IsA("BasePart") and not v.Anchored and not processedParts[v] and not isPartPlayerCharacter(v) and not (localPlayer.Character and v:IsDescendantOf(localPlayer.Character)) then
                            if initiallyMasslessParts[v] == nil then pcall(function() initiallyMasslessParts[v] = v.Massless end) end
                            pcall(function() v.Massless = true end)
                            ForcePart(v)
                        end
                    end
                end
                wait(0.5)
            end
        end)
    end
end)

-- PAA toggle (keeps PAA functionality)
window:Toggle("PAA/unPAA (player amount BHs)", false, function(Value)
    PAAEnabled = Value
    if PAAEnabled then
        PAA_isUsingSelected = false
        refreshPAA()
        paaConnections[#paaConnections+1] = Players.PlayerAdded:Connect(onPlayerAddedForPAA)
        paaConnections[#paaConnections+1] = Players.PlayerRemoving:Connect(onPlayerRemovingForPAA)
    else
        for _, c in ipairs(paaConnections) do pcall(function() c:Disconnect() end) end
        paaConnections = {}
        deleteBHsBySource("PAA")
    end
end)

-- continuous refresh for PAA depending on matching primary mode:
spawn(function()
    while true do
        if PAAEnabled then
            if PAA_isUsingSelected then
                if targetSelectedActive then refreshPAA() end
            else
                if targetAllActive then refreshPAA() end
            end
        end
        wait(2)
    end
end)

-- start/stop rebalancer
spawn(function()
    while true do
        if #extraBlackHoles > 0 and not rebalancerRunning then startRebalancer()
        elseif #extraBlackHoles == 0 and rebalancerRunning then stopRebalancer() end
        if cycleRestartPending then scheduleCycleRestart() end
        wait(0.5)
    end
end)

-- HUD: BH count (keeps it)
do
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "ÆS_BHCountGui"
    screenGui.ResetOnSpawn = false
    screenGui.Parent = localPlayer:WaitForChild("PlayerGui")

    local txt = Instance.new("TextLabel")
    txt.Name = "BlackHoleCount"
    txt.AnchorPoint = Vector2.new(0.5, 0)
    txt.Position = UDim2.new(0.5, 0, 0, 6)
    txt.Size = UDim2.new(0, 220, 0, 24)
    txt.BackgroundTransparency = 1
    txt.TextTransparency = 0
    txt.Text = "BlackHoles: 0"
    txt.TextScaled = false
    txt.TextSize = 18
    txt.Font = Enum.Font.SourceSansSemibold
    txt.TextColor3 = Color3.new(1,1,1)
    txt.Parent = screenGui

    local function countBlackHolePartsInFolders()
        local count = 0
        for _, obj in ipairs(Workspace:GetDescendants()) do
            if obj:IsA("Folder") then
                local lname = obj.Name:lower()
                if string.find(lname, "blackhole") or string.find(lname, "bh") or string.find(lname, "aes_blackhole") or string.find(lname, "æs_blackhole") then
                    for _, child in ipairs(obj:GetDescendants()) do
                        if child:IsA("BasePart") then
                            local cname = child.Name:lower()
                            if string.find(cname, "extrabh_center") or string.find(cname, "bh_center") or string.find(cname, "bh_center_part") or string.find(cname, "extra") then
                                count = count + 1
                            end
                        end
                    end
                end
            end
        end
        return count
    end

    spawn(function()
        while true do
            local count = 0
            pcall(function() count = countBlackHolePartsInFolders() end)
            txt.Text = "BlackHoles: "..tostring(count)
            wait(0.5)
        end
    end)
end

-- End of script
